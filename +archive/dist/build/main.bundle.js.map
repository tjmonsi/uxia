{"version":3,"sources":["webpack:///main.bundle.js","webpack:///webpack/bootstrap 8cdb686a67e5601fae6f","webpack:///../bower_components/polymer/lib/utils/boot.html","webpack:///../bower_components/polymer/lib/utils/mixin.html","webpack:///../bower_components/polymer/lib/utils/resolve-url.html","webpack:///../bower_components/polymer/lib/utils/case-map.html","webpack:///../bower_components/polymer/lib/utils/async.html","webpack:///../bower_components/polymer/polymer-element.html","webpack:///../bower_components/polymer/lib/mixins/property-effects.html","webpack:///../bower_components/polymer/lib/mixins/element-mixin.html","webpack:///../bower_components/polymer/lib/utils/settings.html","webpack:///../bower_components/polymer/lib/utils/style-gather.html","webpack:///../bower_components/polymer/lib/utils/flattened-nodes-observer.html","webpack:///../bower_components/polymer/lib/utils/array-splice.html","webpack:///../core/shell/index.js","webpack:///../bower_components/polymer/lib/elements/dom-module.html","webpack:///../bower_components/polymer/lib/utils/path.html","webpack:///../bower_components/polymer/lib/mixins/property-accessors.html","webpack:///../bower_components/polymer/lib/mixins/template-stamp.html","webpack:///../core/mixins/location-mixin.js","webpack:///../core/utils/resolve-url.js","webpack:///../core/mixins/query-params-mixin.js","webpack:///../node_modules/path-to-regexp/index.js","webpack:///../node_modules/isarray/index.js","webpack:///../src/routing.js","webpack:///../src/http-codes.js","webpack:///../src/authentication/index.js","webpack:///./node_modules/polymer-webpack-loader/register-html-template.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","parentJsonpFunction","window","chunkIds","moreModules","executeModules","chunkId","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","shift","5","e","onScriptComplete","script","onerror","onload","clearTimeout","timeout","chunk","Error","undefined","installedChunkData","Promise","resolve","promise","reject","head","document","getElementsByTagName","createElement","type","charset","async","nc","setAttribute","src","p","0","1","2","3","4","setTimeout","appendChild","m","c","d","name","getter","o","defineProperty","configurable","enumerable","get","n","__esModule","object","property","oe","err","console","error","s","userPolymer","Polymer","info","_polymerFn","assign","version","JSCompiler_renameProperty","prop","obj","MixinFunction","dedupeId","__mixinApplications","__mixinSet","dedupingMixin","mixin","base","baseSet","mixinDedupeId","map","mixinApplications","extended","set","mixinSet","create","WeakMap","resolveUrl","url","baseURI","ABS_URL","test","workingURL","u","URL","pathname","href","location","resolveDoc","implementation","createHTMLDocument","anchor","body","resolveCss","cssText","replace","CSS_URL_RX","pre","post","pathFromUrl","substring","lastIndexOf","ResolveUrl","caseMap","DASH_TO_CAMEL","CAMEL_TO_DASH","CaseMap","dashToCamelCase","dash","indexOf","toUpperCase","camelToDashCase","camel","toLowerCase","microtaskFlush","len","microtaskCallbacks","cb","splice","microtaskLastHandle","microtaskCurrHandle","microtaskNodeContent","microtaskNode","createTextNode","MutationObserver","observe","characterData","Async","timeOut","after","delay","run","fn","cancel","bind","animationFrame","requestAnimationFrame","cancelAnimationFrame","idlePeriod","requestIdleCallback","handle","cancelIdleCallback","microTask","callback","textContent","idx","Element","ElementMixin","HTMLElement","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","constructor","value","writable","setPrototypeOf","__proto__","_createClass","defineProperties","target","props","descriptor","key","protoProps","staticProps","_get","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_typeof","Symbol","iterator","ensureOwnEffectMap","model","effects","protoFx","instFx","Array","runEffects","inst","oldProps","hasPaths","extraArgs","ran","id","runEffectsForProperty","rootProperty","Path","root","fxs","fx","lastRun","pathMatchesTrigger","trigger","path","triggerPath","structured","isAncestor","wildcard","isDescendant","runObserverEffect","methodName","changedProp","__data","dynamicFn","warn","runNotifyEffects","notifyProps","TYPES","NOTIFY","notified","notifyPath","host","__dataHost","_invalidateProperties","dispatchNotifyEvent","eventName","detail","queueProperty","dispatchEvent","CustomEvent","runNotifyEffect","handleNotification","event","fromProp","toPath","negate","fromPath","translate","READ_ONLY","_setPendingPropertyOrPath","Boolean","runReflectEffect","sanitizeDOMValue","attrName","_propertyToAttribute","runComputedEffects","changedProps","computeEffects","COMPUTE","inputProps","__dataOld","__dataPending","runComputedEffect","result","runMethodEffect","computedProp","methodInfo","__dataHasAccessor","_setPendingProperty","computeLinkedPaths","links","__dataLinkedPaths","link","a","b","addBinding","templateInfo","nodeInfo","kind","parts","literal","bindings","binding","isCompound","shouldAddListener","_binding$parts$","listenerEvent","listenerNegate","index","nodeInfoList","part","compoundIndex","addEffectForBindingPart","dependencies","evaluator","j","parseArg","_addTemplatePropertyEffect","runBindingEffect","nodeList","node","source","_enqueueClient","applyBindingValue","_evaluateBinding","computeBindingValue","_valueToNodeAttribute","_setUnmanagedPropertyToNode","storage","__dataCompoundStorage","join","localName","mode","setupBindings","_i","setupCompoundStorage","addNotifyListener","literals","addEventListener","createMethodEffect","sig","effectFn","static","arg","args","_addPropertyEffect","context","_methodHost","marshalArgs","apply","literalFromParts","parseMethod","expression","match","emptyArray","trim","parseArgs","split","argList","rawArg","this","fc","slice","Number","isPath","data","values","v","baseChanged","matches","_notifySplices","array","splices","splicesPath","indexSplices","notifySplice","addedCount","removed","upper","REFLECT","PROPAGATE","OBSERVE","PropertyEffectsType","bindingRegex","RegExp","OPEN_BRACKET","PropertyEffects","propertyEffectsBase","TemplateStamp","PropertyAccessors","_propertyEffectsBase","_this","__dataClientsReady","__dataPendingClients","__dataToNotify","__dataHasPaths","__dataTemp","__dataClientsInitialized","__computeEffects","__reflectEffects","__notifyEffects","__propagateEffects","__observeEffects","__readOnly","__dataCounter","__templateInfo","hostStack","registerHost","readOnly","effect","_createPropertyAccessor","_hasPropertyEffect","shouldNotify","isPathNotification","isArray","old","prevProps","_shouldPropertyChange","__dataReady","_flushProperties","client","__enableOrFlushClients","_readyClients","clients","__dataEnabled","_enableProperties","setReadOnly","_flushClients","currentProps","_propagatePropertyChanges","propertyEffects","nextTemplateInfo","to","from","normalize","_len","arguments","items","_key","ret","hadLength","pop","start","deleteCount","Math","floor","_len2","_key2","concat","_len3","_key3","unshift","propPath","protectedSetter","_setProperty","attr","template","instanceBinding","_parseTemplate","wasPreBound","last","__templateInfoLast","previousTemplateInfo","beginHosting","dom","endHosting","_bindTemplate","nodes","childNodes","firstChild","nextSibling","parentNode","removeChild","_createPropertyObserver","_createMethodObserver","_createNotifyingProperty","_createReadOnlyProperty","_createReflectedProperty","_createComputedProperty","hostProps","noted","nodeType","Node","TEXT_NODE","_parseBindings","origName","removeAttribute","text","lastIndex","exec","customEvent","notifyEvent","colon","signature","dynamicFns","stack","stackLen","ownPropertiesForClass","klass","__ownProperties","properties","ownObserversForClass","__ownObservers","observers","flattenProperties","flattenedProps","propertiesForClass","__classProperties","superCtor","PolymerElement","propertyDefaultsForClass","__classPropertyDefaults","hasClassFinalized","finalizeClassAndSuper","proto","finalize","finalizeClass","__finalized","is","telemetry","register","finalizeProperties","finalizeObservers","t","innerHTML","cloneNode","_template","createPropertyFromConfig","allProps","computed","_hasReadOnlyEffect","reflectToAttribute","_hasReflectEffect","notify","_hasNotifyEffect","observer","finalizeTemplate","ext","StyleGather","cssFromTemplate","cssFromModuleImports","style","content","insertBefore","ShadyCSS","prepareTemplate","polymerElementBase","_polymerElementBase","instanceCount","importPath","__polymerFinalized","rootPath","p$","_hasAccessor","styleElement","_stampTemplate","$","_attachDom","attachShadow","shadowRoot","_attributeToProperty","styleSubtree","list","__observedAttributes","DomModule","import","_importPath","assetpath","registrations","_regLog","log","dumpRegistrations","forEach","updateStyles","styleDocument","settings","Settings","useShadow","ShadyDOM","useNativeCSSProperties","nativeCss","useNativeCustomElements","customElements","polyfillWrapFlushCallback","setRootPath","importModule","cssFromModules","moduleIds","cssFromModule","_cssText","querySelector","e$","querySelectorAll","include","getAttribute","importDoc","container","isSlot","FlattenedNodesObserver","_shadyChildrenObserver","_nativeChildrenObserver","_connected","_target","_effectiveNodes","_observer","_scheduled","_boundSchedule","_schedule","connect","assignedNodes","flatten","reduce","_this2","_listenSlots","children","observeChildren","mutations","_processMutations","childList","_unlistenSlots","unobserveChildren","disconnect","_this3","flush","_processSlotMutations","mutation","addedNodes","removedNodes","takeRecords","newNodes","getFlattenedNodes","ArraySplice","calculateSplices","_s","_j","didFlush","removeEventListener","newSplice","calcEditDistances","current","currentStart","currentEnd","oldStart","oldEnd","rowCount","columnCount","distances","equals","north","west","spliceOperationsFromEditDistances","edits","northWest","min","EDIT_LEAVE","EDIT_UPDATE","EDIT_DELETE","EDIT_ADD","reverse","calcSplices","prefixCount","suffixCount","minLength","sharedPrefix","sharedSuffix","ops","oldIndex","searchLength","index1","index2","count","previous","currentValue","previousValue","_interopRequireDefault","default","_locationMixin","_locationMixin2","_queryParamsMixin","_queryParamsMixin2","_pathToRegexp","_pathToRegexp2","_routing","_routing2","_httpCodes","_httpCodes2","_partials","_partials2","_index","_index2","messages","AppShell","_QueryParamsMixin","_routes","params","queryParams","currentRoute","String","query","urlSpaceRegex","hash","dwellTime","_urlSpaceRegExp","_lastChangedAt","_initialized","paramsString","paramsObject","_dontReact","_contentAdded","filter","ELEMENT_NODE","then","messageInterval","setInterval","_messages$pop","message","optTapHandler","optAction","optActionHandler","optDuration","showMessage","clearInterval","close","pages","page","classList","add","element","auth","_pathChanged","_this4","routeName","entries","route","keys","re","_checkAuth","_this5","res","_loadPage","catch","_this6","routes","remove","ga","define","findModule","lcModules","styleOutsideTemplateCheck","_HTMLElement","__assetpath","owner","HTMLImports","importForElement","ownerDocument","selector","dotIndex","newBase","toString","isDeep","saveAccessorValue","nativeProperties","__dataProto","microtask","getOwnPropertyNames","_superClass","__serializing","__dataInvalid","__dataInstanceProps","_initializeProperties","a$","observedAttributes","_initializeProtoProperties","attribute","hasAttribute","_deserializeValue","str","_serializeValue","Date","JSON","stringify","x","outValue","parse","changed","_initializeInstanceProperties","ready","_propertiesChanged","wrapTemplateExtension","templateExtensions","replaceChild","attributes","findTemplateNode","parentInfo","parentIndex","applyIdToMap","applyEventListener","events","_addMethodEventListenerToNode","applyTemplateContent","_templateInfo","createNodeEventHandler","dom-if","dom-repeat","HTMLTemplateElement","decorate","importNode","__noInsertionPoint","hasInsertionPoint","handler","_addEventListenerToNode","outerTemplateInfo","stripWhiteSpace","_parseTemplateContent","_parseTemplateNode","_parseTemplateNestedTemplate","_parseTemplateChildNodes","hasAttributes","_parseTemplateNodeAttributes","next","childInfo","infoIndex","createDocumentFragment","attrs","_parseTemplateNodeAttribute","_resolveUrl","_resolveUrl2","_class","_boundHashChanged","_hashChanged","_boundUrlChanged","_urlChanged","_boundGlobalOnClick","_globalOnClick","performance","now","decodeURIComponent","search","_dontUpdateUrl","_updateUrl","partiallyEncodedPath","encodeURI","partiallyEncodedQuery","partiallyEncodedHash","newUrl","_getUrl","fullNewUrl","protocol","shouldReplace","history","replaceState","pushState","defaultPrevented","_getSameOriginLinkHref","preventDefault","button","metaKey","ctrlKey","eventPath","composedPath","tagName","top","origin","normalizedHref","urlDoc","urlBase","_decodeParams","_encodeParams","encodedParams","encodeURIComponent","paramString","paramList","param","options","tokens","defaultDelimiter","delimiter","PATH_REGEXP","escaped","offset","prefix","capture","group","modifier","asterisk","partial","repeat","optional","pattern","escapeGroup","escapeString","substr","compile","tokensToFunction","encodeURIComponentPretty","charCodeAt","encodeAsterisk","opts","encode","pretty","token","segment","isarray","attachKeys","flags","sensitive","regexpToRegexp","groups","arrayToRegexp","pathToRegexp","stringToRegexp","tokensToRegExp","strict","end","endsWithDelimiter","arr","/","style-guide","not-found","not-authorized","exampleAuthentication","RegisterHtmlTemplate","val","trimmedVal","div"],"mappings":"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","file":"main.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, resolves = [], result;\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId]) {\n/******/ \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n/******/ \t\t\t}\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n/******/ \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);\n/******/ \t\twhile(resolves.length) {\n/******/ \t\t\tresolves.shift()();\n/******/ \t\t}\n/******/\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// objects to store loaded and loading chunks\n/******/ \tvar installedChunks = {\n/******/ \t\t5: 0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId) {\n/******/ \t\tvar installedChunkData = installedChunks[chunkId];\n/******/ \t\tif(installedChunkData === 0) {\n/******/ \t\t\treturn new Promise(function(resolve) { resolve(); });\n/******/ \t\t}\n/******/\n/******/ \t\t// a Promise means \"currently loading\".\n/******/ \t\tif(installedChunkData) {\n/******/ \t\t\treturn installedChunkData[2];\n/******/ \t\t}\n/******/\n/******/ \t\t// setup Promise in chunk cache\n/******/ \t\tvar promise = new Promise(function(resolve, reject) {\n/******/ \t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n/******/ \t\t});\n/******/ \t\tinstalledChunkData[2] = promise;\n/******/\n/******/ \t\t// start chunk loading\n/******/ \t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\tvar script = document.createElement('script');\n/******/ \t\tscript.type = 'text/javascript';\n/******/ \t\tscript.charset = 'utf-8';\n/******/ \t\tscript.async = true;\n/******/ \t\tscript.timeout = 120000;\n/******/\n/******/ \t\tif (__webpack_require__.nc) {\n/******/ \t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n/******/ \t\t}\n/******/ \t\tscript.src = __webpack_require__.p + \"\" + ({\"0\":\"uxia-home-page\",\"1\":\"app-toast\",\"2\":\"example-style-guide-page\",\"3\":\"example-not-found-page\",\"4\":\"example-not-authorized-page\"}[chunkId]||chunkId) + \".\" + chunkId + \".bundle.js\";\n/******/ \t\tvar timeout = setTimeout(onScriptComplete, 120000);\n/******/ \t\tscript.onerror = script.onload = onScriptComplete;\n/******/ \t\tfunction onScriptComplete() {\n/******/ \t\t\t// avoid mem leaks in IE.\n/******/ \t\t\tscript.onerror = script.onload = null;\n/******/ \t\t\tclearTimeout(timeout);\n/******/ \t\t\tvar chunk = installedChunks[chunkId];\n/******/ \t\t\tif(chunk !== 0) {\n/******/ \t\t\t\tif(chunk) {\n/******/ \t\t\t\t\tchunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));\n/******/ \t\t\t\t}\n/******/ \t\t\t\tinstalledChunks[chunkId] = undefined;\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t\thead.appendChild(script);\n/******/\n/******/ \t\treturn promise;\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// on error function for async loading\n/******/ \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 12);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n(function () {\n  'use strict';\n\n  var userPolymer = window.Polymer;\n\n  /**\n   * @namespace Polymer\n   * @summary Polymer is a lightweight library built on top of the web\n   *   standards-based Web Components API's, and makes it easy to build your\n   *   own custom HTML elements.\n   * @param {!PolymerInit} info Prototype for the custom element. It must contain\n   *   an `is` property to specify the element name. Other properties populate\n   *   the element prototype. The `properties`, `observers`, `hostAttributes`,\n   *   and `listeners` properties are processed to create element features.\n   * @return {!Object} Returns a custom element class for the given provided\n   *   prototype `info` object. The name of the element if given by `info.is`.\n   */\n  window.Polymer = function (info) {\n    return window.Polymer._polymerFn(info);\n  };\n\n  // support user settings on the Polymer object\n  if (userPolymer) {\n    Object.assign(Polymer, userPolymer);\n  }\n\n  // To be plugged by legacy implementation if loaded\n  /* eslint-disable valid-jsdoc */\n  /**\n   * @param {!PolymerInit} info Prototype for the custom element. It must contain\n   *   an `is` property to specify the element name. Other properties populate\n   *   the element prototype. The `properties`, `observers`, `hostAttributes`,\n   *   and `listeners` properties are processed to create element features.\n   * @return {!Object} Returns a custom element class for the given provided\n   *   prototype `info` object. The name of the element if given by `info.is`.\n   */\n  window.Polymer._polymerFn = function (info) {\n    // eslint-disable-line no-unused-vars\n    throw new Error('Load polymer.html to use the Polymer() function.');\n  };\n  /* eslint-enable */\n\n  window.Polymer.version = '2.0.1';\n\n  /* eslint-disable no-unused-vars */\n  /*\n  When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]\n  We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.\n  */\n  window.JSCompiler_renameProperty = function (prop, obj) {\n    return prop;\n  };\n  /* eslint-enable */\n})();\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(0);\n\n(function () {\n\n  'use strict';\n\n  // unique global id for deduping mixins.\n\n  var dedupeId = 0;\n\n  /**\n   * @constructor\n   * @extends {Function}\n   */\n  function MixinFunction() {}\n  /** @type {(WeakMap | undefined)} */\n  MixinFunction.prototype.__mixinApplications;\n  /** @type {(Object | undefined)} */\n  MixinFunction.prototype.__mixinSet;\n\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Wraps an ES6 class expression mixin such that the mixin is only applied\n   * if it has not already been applied its base argument.  Also memoizes mixin\n   * applications.\n   *\n   * @memberof Polymer\n   * @template T\n   * @param {T} mixin ES6 class expression mixin to wrap\n   * @suppress {invalidCasts}\n   */\n  Polymer.dedupingMixin = function (mixin) {\n    var mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;\n    if (!mixinApplications) {\n      mixinApplications = new WeakMap();\n      /** @type {!MixinFunction} */mixin.__mixinApplications = mixinApplications;\n    }\n    // maintain a unique id for each mixin\n    var mixinDedupeId = dedupeId++;\n    function dedupingMixin(base) {\n      var baseSet = /** @type {!MixinFunction} */base.__mixinSet;\n      if (baseSet && baseSet[mixinDedupeId]) {\n        return base;\n      }\n      var map = mixinApplications;\n      var extended = map.get(base);\n      if (!extended) {\n        extended = /** @type {!Function} */mixin(base);\n        map.set(base, extended);\n      }\n      // copy inherited mixin set from the extended class, or the base class\n      // NOTE: we avoid use of Set here because some browser (IE11)\n      // cannot extend a base Set via the constructor.\n      var mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);\n      mixinSet[mixinDedupeId] = true;\n      /** @type {!MixinFunction} */extended.__mixinSet = mixinSet;\n      return extended;\n    }\n\n    return dedupingMixin;\n  };\n  /* eslint-enable valid-jsdoc */\n})();\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(0);\n\n(function () {\n  'use strict';\n\n  var CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\n  var ABS_URL = /(^\\/)|(^#)|(^[\\w-\\d]*:)/;\n  var workingURL = void 0;\n  var resolveDoc = void 0;\n  /**\n   * Resolves the given URL against the provided `baseUri'.\n   *\n   * @memberof Polymer.ResolveUrl\n   * @param {string} url Input URL to resolve\n   * @param {?string=} baseURI Base URI to resolve the URL against\n   * @return {string} resolved URL\n   */\n  function resolveUrl(url, baseURI) {\n    if (url && ABS_URL.test(url)) {\n      return url;\n    }\n    // Lazy feature detection.\n    if (workingURL === undefined) {\n      workingURL = false;\n      try {\n        var u = new URL('b', 'http://a');\n        u.pathname = 'c%20d';\n        workingURL = u.href === 'http://a/c%20d';\n      } catch (e) {\n        // silently fail\n      }\n    }\n    if (!baseURI) {\n      baseURI = document.baseURI || window.location.href;\n    }\n    if (workingURL) {\n      return new URL(url, baseURI).href;\n    }\n    // Fallback to creating an anchor into a disconnected document.\n    if (!resolveDoc) {\n      resolveDoc = document.implementation.createHTMLDocument('temp');\n      resolveDoc.base = resolveDoc.createElement('base');\n      resolveDoc.head.appendChild(resolveDoc.base);\n      resolveDoc.anchor = resolveDoc.createElement('a');\n      resolveDoc.body.appendChild(resolveDoc.anchor);\n    }\n    resolveDoc.base.href = baseURI;\n    resolveDoc.anchor.href = url;\n    return resolveDoc.anchor.href || url;\n  }\n\n  /**\n   * Resolves any relative URL's in the given CSS text against the provided\n   * `ownerDocument`'s `baseURI`.\n   *\n   * @memberof Polymer.ResolveUrl\n   * @param {string} cssText CSS text to process\n   * @param {string} baseURI Base URI to resolve the URL against\n   * @return {string} Processed CSS text with resolved URL's\n   */\n  function resolveCss(cssText, baseURI) {\n    return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {\n      return pre + '\\'' + resolveUrl(url.replace(/[\"']/g, ''), baseURI) + '\\'' + post;\n    });\n  }\n\n  /**\n   * Returns a path from a given `url`. The path includes the trailing\n   * `/` from the url.\n   *\n   * @memberof Polymer.ResolveUrl\n   * @param {string} url Input URL to transform\n   * @return {string} resolved path\n   */\n  function pathFromUrl(url) {\n    return url.substring(0, url.lastIndexOf('/') + 1);\n  }\n\n  /**\n   * Module with utilities for resolving relative URL's.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module with utilities for resolving relative URL's.\n   */\n  Polymer.ResolveUrl = {\n    resolveCss: resolveCss,\n    resolveUrl: resolveUrl,\n    pathFromUrl: pathFromUrl\n  };\n})();\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(0);\n\n(function () {\n  'use strict';\n\n  var caseMap = {};\n  var DASH_TO_CAMEL = /-[a-z]/g;\n  var CAMEL_TO_DASH = /([A-Z])/g;\n\n  /**\n   * Module with utilities for converting between \"dash-case\" and \"camelCase\"\n   * identifiers.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module that provides utilities for converting between \"dash-case\"\n   *   and \"camelCase\".\n   */\n  var CaseMap = {\n\n    /**\n     * Converts \"dash-case\" identifier (e.g. `foo-bar-baz`) to \"camelCase\"\n     * (e.g. `fooBarBaz`).\n     *\n     * @memberof Polymer.CaseMap\n     * @param {string} dash Dash-case identifier\n     * @return {string} Camel-case representation of the identifier\n     */\n    dashToCamelCase: function dashToCamelCase(dash) {\n      return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, function (m) {\n        return m[1].toUpperCase();\n      }));\n    },\n\n\n    /**\n     * Converts \"camelCase\" identifier (e.g. `fooBarBaz`) to \"dash-case\"\n     * (e.g. `foo-bar-baz`).\n     *\n     * @memberof Polymer.CaseMap\n     * @param {string} camel Camel-case identifier\n     * @return {string} Dash-case representation of the identifier\n     */\n    camelToDashCase: function camelToDashCase(camel) {\n      return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());\n    }\n  };\n\n  Polymer.CaseMap = CaseMap;\n})();\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(0);\n\n(function () {\n\n  'use strict';\n\n  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */\n\n  var AsyncInterface = void 0; // eslint-disable-line no-unused-vars\n\n  // Microtask implemented using Mutation Observer\n  var microtaskCurrHandle = 0;\n  var microtaskLastHandle = 0;\n  var microtaskCallbacks = [];\n  var microtaskNodeContent = 0;\n  var microtaskNode = document.createTextNode('');\n  new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });\n\n  function microtaskFlush() {\n    var len = microtaskCallbacks.length;\n    for (var i = 0; i < len; i++) {\n      var cb = microtaskCallbacks[i];\n      if (cb) {\n        try {\n          cb();\n        } catch (e) {\n          setTimeout(function () {\n            throw e;\n          });\n        }\n      }\n    }\n    microtaskCallbacks.splice(0, len);\n    microtaskLastHandle += len;\n  }\n\n  /**\n   * Module that provides a number of strategies for enqueuing asynchronous\n   * tasks.  Each sub-module provides a standard `run(fn)` interface that returns a\n   * handle, and a `cancel(handle)` interface for canceling async tasks before\n   * they run.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module that provides a number of strategies for enqueuing asynchronous\n   * tasks.\n   */\n  Polymer.Async = {\n\n    /**\n     * Async interface wrapper around `setTimeout`.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface wrapper around `setTimeout`.\n     */\n    timeOut: {\n      /**\n       * Returns a sub-module with the async interface providing the provided\n       * delay.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {number} delay Time to wait before calling callbacks in ms\n       * @return {AsyncInterface} An async timeout interface\n       */\n      after: function after(delay) {\n        return {\n          run: function run(fn) {\n            return setTimeout(fn, delay);\n          },\n\n          cancel: window.clearTimeout.bind(window)\n        };\n      },\n\n      /**\n       * Enqueues a function called in the next task.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {Function} fn Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run: window.setTimeout.bind(window),\n      /**\n       * Cancels a previously enqueued `timeOut` callback.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel: window.clearTimeout.bind(window)\n    },\n\n    /**\n     * Async interface wrapper around `requestAnimationFrame`.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface wrapper around `requestAnimationFrame`.\n     */\n    animationFrame: {\n      /**\n       * Enqueues a function called at `requestAnimationFrame` timing.\n       *\n       * @memberof Polymer.Async.animationFrame\n       * @param {Function} fn Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run: window.requestAnimationFrame.bind(window),\n      /**\n       * Cancels a previously enqueued `animationFrame` callback.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel: window.cancelAnimationFrame.bind(window)\n    },\n\n    /**\n     * Async interface wrapper around `requestIdleCallback`.  Falls back to\n     * `setTimeout` on browsers that do not support `requestIdleCallback`.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface wrapper around `requestIdleCallback`.\n     */\n    idlePeriod: {\n      /**\n       * Enqueues a function called at `requestIdleCallback` timing.\n       *\n       * @memberof Polymer.Async.idlePeriod\n       * @param {function(IdleDeadline)} fn Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run: function run(fn) {\n        return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);\n      },\n\n      /**\n       * Cancels a previously enqueued `idlePeriod` callback.\n       *\n       * @memberof Polymer.Async.idlePeriod\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel: function cancel(handle) {\n        window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);\n      }\n    },\n\n    /**\n     * Async interface for enqueueing callbacks that run at microtask timing.\n     *\n     * Note that microtask timing is achieved via a single `MutationObserver`,\n     * and thus callbacks enqueued with this API will all run in a single\n     * batch, and not interleaved with other microtasks such as promises.\n     * Promises are avoided as an implementation choice for the time being\n     * due to Safari bugs that cause Promises to lack microtask guarantees.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface for enqueueing callbacks that run at microtask\n     *   timing.\n     */\n    microTask: {\n\n      /**\n       * Enqueues a function called at microtask timing.\n       *\n       * @memberof Polymer.Async.microTask\n       * @param {Function} callback Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run: function run(callback) {\n        microtaskNode.textContent = microtaskNodeContent++;\n        microtaskCallbacks.push(callback);\n        return microtaskCurrHandle++;\n      },\n\n\n      /**\n       * Cancels a previously enqueued `microTask` callback.\n       *\n       * @memberof Polymer.Async.microTask\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel: function cancel(handle) {\n        var idx = handle - microtaskLastHandle;\n        if (idx >= 0) {\n          if (!microtaskCallbacks[idx]) {\n            throw new Error('invalid async handle: ' + handle);\n          }\n          microtaskCallbacks[idx] = null;\n        }\n      }\n    }\n  };\n})();\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(7);\n\n(function () {\n  'use strict';\n\n  /**\n   * Base class that provides the core API for Polymer's meta-programming\n   * features including template stamping, data-binding, attribute deserialization,\n   * and property change observation.\n   *\n   * @customElement\n   * @polymer\n   * @memberof Polymer\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @extends HTMLElement\n   * @appliesMixin Polymer.ElementMixin\n   * @summary Custom element base class that provides the core API for Polymer's\n   *   key meta-programming features including template stamping, data-binding,\n   *   attribute deserialization, and property change observation\n   */\n\n  var Element = Polymer.ElementMixin(HTMLElement);\n  /**\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @extends {HTMLElement}\n   */\n  Polymer.Element = Element;\n})();\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n__webpack_require__(14);\n\n__webpack_require__(3);\n\n__webpack_require__(15);\n\n__webpack_require__(16);\n\n(function () {\n\n  'use strict';\n\n  /** @const {Object} */\n\n  var CaseMap = Polymer.CaseMap;\n\n  // Monotonically increasing unique ID used for de-duping effects triggered\n  // from multiple properties in the same turn\n  var dedupeId = 0;\n\n  /**\n   * Property effect types; effects are stored on the prototype using these keys\n   * @enum {string}\n   */\n  var TYPES = {\n    COMPUTE: '__computeEffects',\n    REFLECT: '__reflectEffects',\n    NOTIFY: '__notifyEffects',\n    PROPAGATE: '__propagateEffects',\n    OBSERVE: '__observeEffects',\n    READ_ONLY: '__readOnly'\n\n    /**\n     * @typedef {{\n     * name: (string | undefined),\n     * structured: (boolean | undefined),\n     * wildcard: (boolean | undefined)\n     * }}\n     */\n  };var DataTrigger = void 0; //eslint-disable-line no-unused-vars\n\n  /**\n   * @typedef {{\n   * info: ?,\n   * trigger: (!DataTrigger | undefined),\n   * fn: (!Function | undefined)\n   * }}\n   */\n  var DataEffect = void 0; //eslint-disable-line no-unused-vars\n\n  var PropertyEffectsType = void 0; //eslint-disable-line no-unused-vars\n\n  /**\n   * Ensures that the model has an own-property map of effects for the given type.\n   * The model may be a prototype or an instance.\n   *\n   * Property effects are stored as arrays of effects by property in a map,\n   * by named type on the model. e.g.\n   *\n   *   __computeEffects: {\n   *     foo: [ ... ],\n   *     bar: [ ... ]\n   *   }\n   *\n   * If the model does not yet have an effect map for the type, one is created\n   * and returned.  If it does, but it is not an own property (i.e. the\n   * prototype had effects), the the map is deeply cloned and the copy is\n   * set on the model and returned, ready for new effects to be added.\n   *\n   * @param {Object} model Prototype or instance\n   * @param {string} type Property effect type\n   * @return {Object} The own-property map of effects for the given type\n   * @private\n   */\n  function ensureOwnEffectMap(model, type) {\n    var effects = model[type];\n    if (!effects) {\n      effects = model[type] = {};\n    } else if (!model.hasOwnProperty(type)) {\n      effects = model[type] = Object.create(model[type]);\n      for (var p in effects) {\n        var protoFx = effects[p];\n        var instFx = effects[p] = Array(protoFx.length);\n        for (var i = 0; i < protoFx.length; i++) {\n          instFx[i] = protoFx[i];\n        }\n      }\n    }\n    return effects;\n  }\n\n  // -- effects ----------------------------------------------\n\n  /**\n   * Runs all effects of a given type for the given set of property changes\n   * on an instance.\n   *\n   * @param {!PropertyEffectsType} inst The instance with effects to run\n   * @param {Object} effects Object map of property-to-Array of effects\n   * @param {Object} props Bag of current property changes\n   * @param {Object=} oldProps Bag of previous values for changed properties\n   * @param {boolean=} hasPaths True with `props` contains one or more paths\n   * @param {*=} extraArgs Additional metadata to pass to effect function\n   * @return {boolean} True if an effect ran for this property\n   * @private\n   */\n  function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n    if (effects) {\n      var ran = false;\n      var id = dedupeId++;\n      for (var prop in props) {\n        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {\n          ran = true;\n        }\n      }\n      return ran;\n    }\n    return false;\n  }\n\n  /**\n   * Runs a list of effects for a given property.\n   *\n   * @param {!PropertyEffectsType} inst The instance with effects to run\n   * @param {Object} effects Object map of property-to-Array of effects\n   * @param {number} dedupeId Counter used for de-duping effects\n   * @param {string} prop Name of changed property\n   * @param {*} props Changed properties\n   * @param {*} oldProps Old properties\n   * @param {boolean=} hasPaths True with `props` contains one or more paths\n   * @param {*=} extraArgs Additional metadata to pass to effect function\n   * @return {boolean} True if an effect ran for this property\n   * @private\n   */\n  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n    var ran = false;\n    var rootProperty = hasPaths ? Polymer.Path.root(prop) : prop;\n    var fxs = effects[rootProperty];\n    if (fxs) {\n      for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {\n        if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n          if (fx.info) {\n            fx.info.lastRun = dedupeId;\n          }\n          fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n          ran = true;\n        }\n      }\n    }\n    return ran;\n  }\n\n  /**\n   * Determines whether a property/path that has changed matches the trigger\n   * criteria for an effect.  A trigger is a descriptor with the following\n   * structure, which matches the descriptors returned from `parseArg`.\n   * e.g. for `foo.bar.*`:\n   * ```\n   * trigger: {\n   *   name: 'a.b',\n   *   structured: true,\n   *   wildcard: true\n   * }\n   * ```\n   * If no trigger is given, the path is deemed to match.\n   *\n   * @param {string} path Path or property that changed\n   * @param {DataTrigger} trigger Descriptor\n   * @return {boolean} Whether the path matched the trigger\n   */\n  function pathMatchesTrigger(path, trigger) {\n    if (trigger) {\n      var triggerPath = trigger.name;\n      return triggerPath == path || trigger.structured && Polymer.Path.isAncestor(triggerPath, path) || trigger.wildcard && Polymer.Path.isDescendant(triggerPath, path);\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * Implements the \"observer\" effect.\n   *\n   * Calls the method with `info.methodName` on the instance, passing the\n   * new and old values.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @private\n   */\n  function runObserverEffect(inst, property, props, oldProps, info) {\n    var fn = inst[info.methodName];\n    var changedProp = info.property;\n    if (fn) {\n      fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n    } else if (!info.dynamicFn) {\n      console.warn('observer method `' + info.methodName + '` not defined');\n    }\n  }\n\n  /**\n   * Runs \"notify\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * will dispatch path notification events in the case that the property\n   * changed was a path and the root property for that path didn't have a\n   * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n   * `notify: true` to ensure object sub-property notifications were\n   * sent.\n   *\n   * @param {!PropertyEffectsType} inst The instance with effects to run\n   * @param {Object} notifyProps Bag of properties to notify\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @private\n   */\n  function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n    // Notify\n    var fxs = inst[TYPES.NOTIFY];\n    var notified = void 0;\n    var id = dedupeId++;\n    // Try normal notify effects; if none, fall back to try path notification\n    for (var prop in notifyProps) {\n      if (notifyProps[prop]) {\n        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n          notified = true;\n        } else if (hasPaths && notifyPath(inst, prop, props)) {\n          notified = true;\n        }\n      }\n    }\n    // Flush host if we actually notified and host was batching\n    // And the host has already initialized clients; this prevents\n    // an issue with a host observing data changes before clients are ready.\n    var host = void 0;\n    if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n      host._invalidateProperties();\n    }\n  }\n\n  /**\n   * Dispatches {property}-changed events with path information in the detail\n   * object to indicate a sub-path of the property was changed.\n   *\n   * @param {!PropertyEffectsType} inst The element from which to fire the event\n   * @param {string} path The path that was changed\n   * @param {Object} props Bag of current property changes\n   * @return {boolean} Returns true if the path was notified\n   * @private\n   */\n  function notifyPath(inst, path, props) {\n    var rootProperty = Polymer.Path.root(path);\n    if (rootProperty !== path) {\n      var eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';\n      dispatchNotifyEvent(inst, eventName, props[path], path);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Dispatches {property}-changed events to indicate a property (or path)\n   * changed.\n   *\n   * @param {!PropertyEffectsType} inst The element from which to fire the event\n   * @param {string} eventName The name of the event to send ('{property}-changed')\n   * @param {*} value The value of the changed property\n   * @param {string | null | undefined} path If a sub-path of this property changed, the path\n   *   that changed (optional).\n   * @private\n   * @suppress {invalidCasts}\n   */\n  function dispatchNotifyEvent(inst, eventName, value, path) {\n    var detail = {\n      value: value,\n      queueProperty: true\n    };\n    if (path) {\n      detail.path = path;\n    }\n    /** @type {!HTMLElement} */inst.dispatchEvent(new CustomEvent(eventName, { detail: detail }));\n  }\n\n  /**\n   * Implements the \"notify\" effect.\n   *\n   * Dispatches a non-bubbling event named `info.eventName` on the instance\n   * with a detail object containing the new `value`.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @private\n   */\n  function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n    var rootProperty = hasPaths ? Polymer.Path.root(property) : property;\n    var path = rootProperty != property ? property : null;\n    var value = path ? Polymer.Path.get(inst, path) : inst.__data[property];\n    if (path && value === undefined) {\n      value = props[property]; // specifically for .splices\n    }\n    dispatchNotifyEvent(inst, info.eventName, value, path);\n  }\n\n  /**\n   * Handler function for 2-way notification events. Receives context\n   * information captured in the `addNotifyListener` closure from the\n   * `__notifyListeners` metadata.\n   *\n   * Sets the value of the notified property to the host property or path.  If\n   * the event contained path information, translate that path to the host\n   * scope's name for that path first.\n   *\n   * @param {CustomEvent} event Notification event (e.g. '<property>-changed')\n   * @param {!PropertyEffectsType} inst Host element instance handling the notification event\n   * @param {string} fromProp Child element property that was bound\n   * @param {string} toPath Host property/path that was bound\n   * @param {boolean} negate Whether the binding was negated\n   * @private\n   */\n  function handleNotification(event, inst, fromProp, toPath, negate) {\n    var value = void 0;\n    var detail = /** @type {Object} */event.detail;\n    var fromPath = detail && detail.path;\n    if (fromPath) {\n      toPath = Polymer.Path.translate(fromProp, toPath, fromPath);\n      value = detail && detail.value;\n    } else {\n      value = event.target[fromProp];\n    }\n    value = negate ? !value : value;\n    if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {\n      if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {\n        inst._invalidateProperties();\n      }\n    }\n  }\n\n  /**\n   * Implements the \"reflect\" effect.\n   *\n   * Sets the attribute named `info.attrName` to the given property value.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @private\n   */\n  function runReflectEffect(inst, property, props, oldProps, info) {\n    var value = inst.__data[property];\n    if (Polymer.sanitizeDOMValue) {\n      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */inst);\n    }\n    inst._propertyToAttribute(property, info.attrName, value);\n  }\n\n  /**\n   * Runs \"computed\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * continues to run computed effects based on the output of each pass until\n   * there are no more newly computed properties.  This ensures that all\n   * properties that will be computed by the initial set of changes are\n   * computed before other effects (binding propagation, observers, and notify)\n   * run.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {!Object} changedProps Bag of changed properties\n   * @param {!Object} oldProps Bag of previous values for changed properties\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @private\n   */\n  function runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n    var computeEffects = inst[TYPES.COMPUTE];\n    if (computeEffects) {\n      var inputProps = changedProps;\n      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n        Object.assign(oldProps, inst.__dataOld);\n        Object.assign(changedProps, inst.__dataPending);\n        inputProps = inst.__dataPending;\n        inst.__dataPending = null;\n      }\n    }\n  }\n\n  /**\n   * Implements the \"computed property\" effect by running the method with the\n   * values of the arguments specified in the `info` object and setting the\n   * return value to the computed property specified.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @private\n   */\n  function runComputedEffect(inst, property, props, oldProps, info) {\n    var result = runMethodEffect(inst, property, props, oldProps, info);\n    var computedProp = info.methodInfo;\n    if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n      inst._setPendingProperty(computedProp, result, true);\n    } else {\n      inst[computedProp] = result;\n    }\n  }\n\n  /**\n   * Computes path changes based on path links set up using the `linkPaths`\n   * API.\n   *\n   * @param {!PropertyEffectsType} inst The instance whose props are changing\n   * @param {string | !Array<(string|number)>} path Path that has changed\n   * @param {*} value Value of changed path\n   * @private\n   */\n  function computeLinkedPaths(inst, path, value) {\n    var links = inst.__dataLinkedPaths;\n    if (links) {\n      var link = void 0;\n      for (var a in links) {\n        var b = links[a];\n        if (Polymer.Path.isDescendant(a, path)) {\n          link = Polymer.Path.translate(a, b, path);\n          inst._setPendingPropertyOrPath(link, value, true, true);\n        } else if (Polymer.Path.isDescendant(b, path)) {\n          link = Polymer.Path.translate(b, a, path);\n          inst._setPendingPropertyOrPath(link, value, true, true);\n        }\n      }\n    }\n  }\n\n  // -- bindings ----------------------------------------------\n\n  /**\n   * Adds binding metadata to the current `nodeInfo`, and binding effects\n   * for all part dependencies to `templateInfo`.\n   *\n   * @param {Function} constructor Class that `_parseTemplate` is currently\n   *   running on\n   * @param {TemplateInfo} templateInfo Template metadata for current template\n   * @param {NodeInfo} nodeInfo Node metadata for current template node\n   * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n   * @param {string} target Target property name\n   * @param {!Array<!BindingPart>} parts Array of binding part metadata\n   * @param {string=} literal Literal text surrounding binding parts (specified\n   *   only for 'property' bindings, since these must be initialized as part\n   *   of boot-up)\n   * @private\n   */\n  function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n    // Create binding metadata and add to nodeInfo\n    nodeInfo.bindings = nodeInfo.bindings || [];\n    var /** Binding */binding = { kind: kind, target: target, parts: parts, literal: literal, isCompound: parts.length !== 1 };\n    nodeInfo.bindings.push(binding);\n    // Add listener info to binding metadata\n    if (shouldAddListener(binding)) {\n      var _binding$parts$ = binding.parts[0],\n          event = _binding$parts$.event,\n          negate = _binding$parts$.negate;\n\n      binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';\n      binding.listenerNegate = negate;\n    }\n    // Add \"propagate\" property effects to templateInfo\n    var index = templateInfo.nodeInfoList.length;\n    for (var i = 0; i < binding.parts.length; i++) {\n      var part = binding.parts[i];\n      part.compoundIndex = i;\n      addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n    }\n  }\n\n  /**\n   * Adds property effects to the given `templateInfo` for the given binding\n   * part.\n   *\n   * @param {Function} constructor Class that `_parseTemplate` is currently\n   *   running on\n   * @param {TemplateInfo} templateInfo Template metadata for current template\n   * @param {!Binding} binding Binding metadata\n   * @param {!BindingPart} part Binding part metadata\n   * @param {number} index Index into `nodeInfoList` for this node\n   */\n  function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n    if (!part.literal) {\n      if (binding.kind === 'attribute' && binding.target[0] === '-') {\n        console.warn('Cannot set attribute ' + binding.target + ' because \"-\" is not a valid attribute starting character');\n      } else {\n        var dependencies = part.dependencies;\n        var info = { index: index, binding: binding, part: part, evaluator: constructor };\n        for (var j = 0; j < dependencies.length; j++) {\n          var trigger = dependencies[j];\n          if (typeof trigger == 'string') {\n            trigger = parseArg(trigger);\n            trigger.wildcard = true;\n          }\n          constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n            fn: runBindingEffect,\n            info: info, trigger: trigger\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Implements the \"binding\" (property/path binding) effect.\n   *\n   * Note that binding syntax is overridable via `_parseBindings` and\n   * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n   * non-literal parts returned from `_parseBindings`.  However,\n   * there is no support for _path_ bindings via custom binding parts,\n   * as this is specific to Polymer's path binding syntax.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} path Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n   *   metadata\n   * @private\n   */\n  function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n    var node = nodeList[info.index];\n    var binding = info.binding;\n    var part = info.part;\n    // Subpath notification: transform path and set to client\n    // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n    if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n      var value = props[path];\n      path = Polymer.Path.translate(part.source, binding.target, path);\n      if (node._setPendingPropertyOrPath(path, value, false, true)) {\n        inst._enqueueClient(node);\n      }\n    } else {\n      var _value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);\n      // Propagate value to child\n      applyBindingValue(inst, node, binding, part, _value);\n    }\n  }\n\n  /**\n   * Sets the value for an \"binding\" (binding) effect to a node,\n   * either as a property or attribute.\n   *\n   * @param {!PropertyEffectsType} inst The instance owning the binding effect\n   * @param {Node} node Target node for binding\n   * @param {!Binding} binding Binding metadata\n   * @param {!BindingPart} part Binding part metadata\n   * @param {*} value Value to set\n   * @private\n   */\n  function applyBindingValue(inst, node, binding, part, value) {\n    value = computeBindingValue(node, value, binding, part);\n    if (Polymer.sanitizeDOMValue) {\n      value = Polymer.sanitizeDOMValue(value, binding.target, binding.kind, node);\n    }\n    if (binding.kind == 'attribute') {\n      // Attribute binding\n      inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);\n    } else {\n      // Property binding\n      var prop = binding.target;\n      if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n        if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {\n          if (node._setPendingProperty(prop, value)) {\n            inst._enqueueClient(node);\n          }\n        }\n      } else {\n        inst._setUnmanagedPropertyToNode(node, prop, value);\n      }\n    }\n  }\n\n  /**\n   * Transforms an \"binding\" effect value based on compound & negation\n   * effect metadata, as well as handling for special-case properties\n   *\n   * @param {Node} node Node the value will be set to\n   * @param {*} value Value to set\n   * @param {!Binding} binding Binding metadata\n   * @param {!BindingPart} part Binding part metadata\n   * @return {*} Transformed value to set\n   * @private\n   */\n  function computeBindingValue(node, value, binding, part) {\n    if (binding.isCompound) {\n      var storage = node.__dataCompoundStorage[binding.target];\n      storage[part.compoundIndex] = value;\n      value = storage.join('');\n    }\n    if (binding.kind !== 'attribute') {\n      // Some browsers serialize `undefined` to `\"undefined\"`\n      if (binding.target === 'textContent' || node.localName == 'input' && binding.target == 'value') {\n        value = value == undefined ? '' : value;\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Returns true if a binding's metadata meets all the requirements to allow\n   * 2-way binding, and therefore a `<property>-changed` event listener should be\n   * added:\n   * - used curly braces\n   * - is a property (not attribute) binding\n   * - is not a textContent binding\n   * - is not compound\n   *\n   * @param {!Binding} binding Binding metadata\n   * @return {boolean} True if 2-way listener should be added\n   * @private\n   */\n  function shouldAddListener(binding) {\n    return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';\n  }\n\n  /**\n   * Setup compound binding storage structures, notify listeners, and dataHost\n   * references onto the bound nodeList.\n   *\n   * @param {!PropertyEffectsType} inst Instance that bas been previously bound\n   * @param {TemplateInfo} templateInfo Template metadata\n   * @private\n   */\n  function setupBindings(inst, templateInfo) {\n    // Setup compound storage, dataHost, and notify listeners\n    var nodeList = templateInfo.nodeList,\n        nodeInfoList = templateInfo.nodeInfoList;\n\n    if (nodeInfoList.length) {\n      for (var i = 0; i < nodeInfoList.length; i++) {\n        var info = nodeInfoList[i];\n        var node = nodeList[i];\n        var bindings = info.bindings;\n        if (bindings) {\n          for (var _i = 0; _i < bindings.length; _i++) {\n            var binding = bindings[_i];\n            setupCompoundStorage(node, binding);\n            addNotifyListener(node, inst, binding);\n          }\n        }\n        node.__dataHost = inst;\n      }\n    }\n  }\n\n  /**\n   * Initializes `__dataCompoundStorage` local storage on a bound node with\n   * initial literal data for compound bindings, and sets the joined\n   * literal parts to the bound property.\n   *\n   * When changes to compound parts occur, they are first set into the compound\n   * storage array for that property, and then the array is joined to result in\n   * the final value set to the property/attribute.\n   *\n   * @param {Node} node Bound node to initialize\n   * @param {Binding} binding Binding metadata\n   * @private\n   */\n  function setupCompoundStorage(node, binding) {\n    if (binding.isCompound) {\n      // Create compound storage map\n      var storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});\n      var parts = binding.parts;\n      // Copy literals from parts into storage for this binding\n      var literals = new Array(parts.length);\n      for (var j = 0; j < parts.length; j++) {\n        literals[j] = parts[j].literal;\n      }\n      var target = binding.target;\n      storage[target] = literals;\n      // Configure properties with their literal parts\n      if (binding.literal && binding.kind == 'property') {\n        node[target] = binding.literal;\n      }\n    }\n  }\n\n  /**\n   * Adds a 2-way binding notification event listener to the node specified\n   *\n   * @param {Object} node Child element to add listener to\n   * @param {!PropertyEffectsType} inst Host element instance to handle notification event\n   * @param {Binding} binding Binding metadata\n   * @private\n   */\n  function addNotifyListener(node, inst, binding) {\n    if (binding.listenerEvent) {\n      var part = binding.parts[0];\n      node.addEventListener(binding.listenerEvent, function (e) {\n        handleNotification(e, inst, binding.target, part.source, part.negate);\n      });\n    }\n  }\n\n  // -- for method-based effects (complexObserver & computed) --------------\n\n  /**\n   * Adds property effects for each argument in the method signature (and\n   * optionally, for the method name if `dynamic` is true) that calls the\n   * provided effect function.\n   *\n   * @param {Element | Object} model Prototype or instance\n   * @param {!MethodSignature} sig Method signature metadata\n   * @param {string} type Type of property effect to add\n   * @param {Function} effectFn Function to run when arguments change\n   * @param {*=} methodInfo Effect-specific information to be included in\n   *   method effect metadata\n   * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n   *   method names should be included as a dependency to the effect. Note,\n   *   defaults to true if the signature is static (sig.static is true).\n   * @private\n   */\n  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n    dynamicFn = sig.static || dynamicFn && ((typeof dynamicFn === 'undefined' ? 'undefined' : _typeof(dynamicFn)) !== 'object' || dynamicFn[sig.methodName]);\n    var info = {\n      methodName: sig.methodName,\n      args: sig.args,\n      methodInfo: methodInfo,\n      dynamicFn: dynamicFn\n    };\n    for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {\n      if (!arg.literal) {\n        model._addPropertyEffect(arg.rootProperty, type, {\n          fn: effectFn, info: info, trigger: arg\n        });\n      }\n    }\n    if (dynamicFn) {\n      model._addPropertyEffect(sig.methodName, type, {\n        fn: effectFn, info: info\n      });\n    }\n  }\n\n  /**\n   * Calls a method with arguments marshaled from properties on the instance\n   * based on the method signature contained in the effect metadata.\n   *\n   * Multi-property observers, computed properties, and inline computing\n   * functions call this function to invoke the method, then use the return\n   * value accordingly.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @return {*} Returns the return value from the method invocation\n   * @private\n   */\n  function runMethodEffect(inst, property, props, oldProps, info) {\n    // Instances can optionally have a _methodHost which allows redirecting where\n    // to find methods. Currently used by `templatize`.\n    var context = inst._methodHost || inst;\n    var fn = context[info.methodName];\n    if (fn) {\n      var args = marshalArgs(inst.__data, info.args, property, props);\n      return fn.apply(context, args);\n    } else if (!info.dynamicFn) {\n      console.warn('method `' + info.methodName + '` not defined');\n    }\n  }\n\n  var emptyArray = [];\n\n  // Regular expressions used for binding\n  var IDENT = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\n  var NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\n  var SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\n  var DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\n  var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\n  var ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\\\s*' + ')';\n  var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\n  var ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\\\)\\\\s*' + ')';\n  var BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\n  var OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\n  var CLOSE_BRACKET = '(?:]]|}})';\n  var NEGATE = '(?:(!)\\\\s*)?'; // Group 2\n  var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\n  var bindingRegex = new RegExp(EXPRESSION, \"g\");\n\n  /**\n   * Create a string from binding parts of all the literal parts\n   *\n   * @param {!Array<BindingPart>} parts All parts to stringify\n   * @return {string} String made from the literal parts\n   */\n  function literalFromParts(parts) {\n    var s = '';\n    for (var i = 0; i < parts.length; i++) {\n      var literal = parts[i].literal;\n      s += literal || '';\n    }\n    return s;\n  }\n\n  /**\n   * Parses an expression string for a method signature, and returns a metadata\n   * describing the method in terms of `methodName`, `static` (whether all the\n   * arguments are literals), and an array of `args`\n   *\n   * @param {string} expression The expression to parse\n   * @return {?MethodSignature} The method metadata object if a method expression was\n   *   found, otherwise `undefined`\n   * @private\n   */\n  function parseMethod(expression) {\n    // tries to match valid javascript property names\n    var m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n    if (m) {\n      var methodName = m[1];\n      var sig = { methodName: methodName, static: true, args: emptyArray };\n      if (m[2].trim()) {\n        // replace escaped commas with comma entity, split on un-escaped commas\n        var args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n        return parseArgs(args, sig);\n      } else {\n        return sig;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Parses an array of arguments and sets the `args` property of the supplied\n   * signature metadata object. Sets the `static` property to false if any\n   * argument is a non-literal.\n   *\n   * @param {!Array<string>} argList Array of argument names\n   * @param {!MethodSignature} sig Method signature metadata object\n   * @return {!MethodSignature} The updated signature metadata object\n   * @private\n   */\n  function parseArgs(argList, sig) {\n    sig.args = argList.map(function (rawArg) {\n      var arg = parseArg(rawArg);\n      if (!arg.literal) {\n        sig.static = false;\n      }\n      return arg;\n    }, this);\n    return sig;\n  }\n\n  /**\n   * Parses an individual argument, and returns an argument metadata object\n   * with the following fields:\n   *\n   *   {\n   *     value: 'prop',        // property/path or literal value\n   *     literal: false,       // whether argument is a literal\n   *     structured: false,    // whether the property is a path\n   *     rootProperty: 'prop', // the root property of the path\n   *     wildcard: false       // whether the argument was a wildcard '.*' path\n   *   }\n   *\n   * @param {string} rawArg The string value of the argument\n   * @return {!MethodArg} Argument metadata object\n   * @private\n   */\n  function parseArg(rawArg) {\n    // clean up whitespace\n    var arg = rawArg.trim()\n    // replace comma entity with comma\n    .replace(/&comma;/g, ',')\n    // repair extra escape sequences; note only commas strictly need\n    // escaping, but we allow any other char to be escaped since its\n    // likely users will do this\n    .replace(/\\\\(.)/g, '\\$1');\n    // basic argument descriptor\n    var a = {\n      name: arg,\n      value: '',\n      literal: false\n    };\n    // detect literal value (must be String or Number)\n    var fc = arg[0];\n    if (fc === '-') {\n      fc = arg[1];\n    }\n    if (fc >= '0' && fc <= '9') {\n      fc = '#';\n    }\n    switch (fc) {\n      case \"'\":\n      case '\"':\n        a.value = arg.slice(1, -1);\n        a.literal = true;\n        break;\n      case '#':\n        a.value = Number(arg);\n        a.literal = true;\n        break;\n    }\n    // if not literal, look for structured path\n    if (!a.literal) {\n      a.rootProperty = Polymer.Path.root(arg);\n      // detect structured path (has dots)\n      a.structured = Polymer.Path.isPath(arg);\n      if (a.structured) {\n        a.wildcard = arg.slice(-2) == '.*';\n        if (a.wildcard) {\n          a.name = arg.slice(0, -2);\n        }\n      }\n    }\n    return a;\n  }\n\n  /**\n   * Gather the argument values for a method specified in the provided array\n   * of argument metadata.\n   *\n   * The `path` and `value` arguments are used to fill in wildcard descriptor\n   * when the method is being called as a result of a path notification.\n   *\n   * @param {Object} data Instance data storage object to read properties from\n   * @param {!Array<!MethodArg>} args Array of argument metadata\n   * @param {string} path Property/path name that triggered the method effect\n   * @param {Object} props Bag of current property changes\n   * @return {Array<*>} Array of argument values\n   * @private\n   */\n  function marshalArgs(data, args, path, props) {\n    var values = [];\n    for (var i = 0, l = args.length; i < l; i++) {\n      var arg = args[i];\n      var name = arg.name;\n      var v = void 0;\n      if (arg.literal) {\n        v = arg.value;\n      } else {\n        if (arg.structured) {\n          v = Polymer.Path.get(data, name);\n          // when data is not stored e.g. `splices`\n          if (v === undefined) {\n            v = props[name];\n          }\n        } else {\n          v = data[name];\n        }\n      }\n      if (arg.wildcard) {\n        // Only send the actual path changed info if the change that\n        // caused the observer to run matched the wildcard\n        var baseChanged = name.indexOf(path + '.') === 0;\n        var matches = path.indexOf(name) === 0 && !baseChanged;\n        values[i] = {\n          path: matches ? path : name,\n          value: matches ? props[path] : v,\n          base: v\n        };\n      } else {\n        values[i] = v;\n      }\n    }\n    return values;\n  }\n\n  // data api\n\n  /**\n   * Sends array splice notifications (`.splices` and `.length`)\n   *\n   * Note: this implementation only accepts normalized paths\n   *\n   * @param {!PropertyEffectsType} inst Instance to send notifications to\n   * @param {Array} array The array the mutations occurred on\n   * @param {string} path The path to the array that was mutated\n   * @param {Array} splices Array of splice records\n   * @private\n   */\n  function _notifySplices(inst, array, path, splices) {\n    var splicesPath = path + '.splices';\n    inst.notifyPath(splicesPath, { indexSplices: splices });\n    inst.notifyPath(path + '.length', array.length);\n    // Null here to allow potentially large splice records to be GC'ed.\n    inst.__data[splicesPath] = { indexSplices: null };\n  }\n\n  /**\n   * Creates a splice record and sends an array splice notification for\n   * the described mutation\n   *\n   * Note: this implementation only accepts normalized paths\n   *\n   * @param {!PropertyEffectsType} inst Instance to send notifications to\n   * @param {Array} array The array the mutations occurred on\n   * @param {string} path The path to the array that was mutated\n   * @param {number} index Index at which the array mutation occurred\n   * @param {number} addedCount Number of added items\n   * @param {Array} removed Array of removed items\n   * @private\n   */\n  function notifySplice(inst, array, path, index, addedCount, removed) {\n    _notifySplices(inst, array, path, [{\n      index: index,\n      addedCount: addedCount,\n      removed: removed,\n      object: array,\n      type: 'splice'\n    }]);\n  }\n\n  /**\n   * Returns an upper-cased version of the string.\n   *\n   * @param {string} name String to uppercase\n   * @return {string} Uppercased string\n   * @private\n   */\n  function upper(name) {\n    return name[0].toUpperCase() + name.substring(1);\n  }\n\n  /**\n   * Element class mixin that provides meta-programming for Polymer's template\n   * binding and data observation (collectively, \"property effects\") system.\n   *\n   * This mixin uses provides the following key static methods for adding\n   * property effects to an element class:\n   * - `addPropertyEffect`\n   * - `createPropertyObserver`\n   * - `createMethodObserver`\n   * - `createNotifyingProperty`\n   * - `createReadOnlyProperty`\n   * - `createReflectedProperty`\n   * - `createComputedProperty`\n   * - `bindTemplate`\n   *\n   * Each method creates one or more property accessors, along with metadata\n   * used by this mixin's implementation of `_propertiesChanged` to perform\n   * the property effects.\n   *\n   * Underscored versions of the above methods also exist on the element\n   * prototype for adding property effects on instances at runtime.\n   *\n   * Note that this mixin overrides several `PropertyAccessors` methods, in\n   * many cases to maintain guarantees provided by the Polymer 1.x features;\n   * notably it changes property accessors to be synchronous by default\n   * whereas the default when using `PropertyAccessors` standalone is to be\n   * async by default.\n   *\n   * @mixinFunction\n   * @polymer\n   * @appliesMixin Polymer.TemplateStamp\n   * @appliesMixin Polymer.PropertyAccessors\n   * @memberof Polymer\n   * @summary Element class mixin that provides meta-programming for Polymer's\n   * template binding and data observation system.\n   */\n  Polymer.PropertyEffects = Polymer.dedupingMixin(function (superClass) {\n\n    /**\n     * @constructor\n     * @extends {superClass}\n     * @implements {Polymer_PropertyAccessors}\n     * @implements {Polymer_TemplateStamp}\n     * @unrestricted\n     */\n    var propertyEffectsBase = Polymer.TemplateStamp(Polymer.PropertyAccessors(superClass));\n\n    /**\n     * @polymer\n     * @mixinClass\n     * @implements {Polymer_PropertyEffects}\n     * @extends {propertyEffectsBase}\n     * @unrestricted\n     */\n\n    var PropertyEffects = function (_propertyEffectsBase) {\n      _inherits(PropertyEffects, _propertyEffectsBase);\n\n      function PropertyEffects() {\n        _classCallCheck(this, PropertyEffects);\n\n        /** @type {boolean} */\n        var _this = _possibleConstructorReturn(this, (PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects)).call(this));\n\n        _this.__dataClientsReady;\n        /** @type {Array} */\n        _this.__dataPendingClients;\n        /** @type {Object} */\n        _this.__dataToNotify;\n        /** @type {Object} */\n        _this.__dataLinkedPaths;\n        /** @type {boolean} */\n        _this.__dataHasPaths;\n        /** @type {Object} */\n        _this.__dataCompoundStorage;\n        /** @type {Polymer_PropertyEffects} */\n        _this.__dataHost;\n        /** @type {!Object} */\n        _this.__dataTemp;\n        /** @type {boolean} */\n        _this.__dataClientsInitialized;\n        /** @type {!Object} */\n        _this.__data;\n        /** @type {!Object} */\n        _this.__dataPending;\n        /** @type {!Object} */\n        _this.__dataOld;\n        /** @type {Object} */\n        _this.__computeEffects;\n        /** @type {Object} */\n        _this.__reflectEffects;\n        /** @type {Object} */\n        _this.__notifyEffects;\n        /** @type {Object} */\n        _this.__propagateEffects;\n        /** @type {Object} */\n        _this.__observeEffects;\n        /** @type {Object} */\n        _this.__readOnly;\n        /** @type {number} */\n        _this.__dataCounter;\n        /** @type {!TemplateInfo} */\n        _this.__templateInfo;\n        return _this;\n      }\n\n      _createClass(PropertyEffects, [{\n        key: '_initializeProperties',\n        value: function _initializeProperties() {\n          _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_initializeProperties', this).call(this);\n          hostStack.registerHost(this);\n          this.__dataClientsReady = false;\n          this.__dataPendingClients = null;\n          this.__dataToNotify = null;\n          this.__dataLinkedPaths = null;\n          this.__dataHasPaths = false;\n          // May be set on instance prior to upgrade\n          this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n          this.__dataHost = this.__dataHost || null;\n          this.__dataTemp = {};\n          this.__dataClientsInitialized = false;\n        }\n\n        /**\n         * Overrides `Polymer.PropertyAccessors` implementation to provide a\n         * more efficient implementation of initializing properties from\n         * the prototype on the instance.\n         *\n         * @override\n         * @param {Object} props Properties to initialize on the prototype\n         */\n\n      }, {\n        key: '_initializeProtoProperties',\n        value: function _initializeProtoProperties(props) {\n          this.__data = Object.create(props);\n          this.__dataPending = Object.create(props);\n          this.__dataOld = {};\n        }\n\n        /**\n         * Overrides `Polymer.PropertyAccessors` implementation to avoid setting\n         * `_setProperty`'s `shouldNotify: true`.\n         *\n         * @override\n         * @param {Object} props Properties to initialize on the instance\n         */\n\n      }, {\n        key: '_initializeInstanceProperties',\n        value: function _initializeInstanceProperties(props) {\n          var readOnly = this[TYPES.READ_ONLY];\n          for (var prop in props) {\n            if (!readOnly || !readOnly[prop]) {\n              this.__dataPending = this.__dataPending || {};\n              this.__dataOld = this.__dataOld || {};\n              this.__data[prop] = this.__dataPending[prop] = props[prop];\n            }\n          }\n        }\n\n        // Prototype setup ----------------------------------------\n\n        /**\n         * Equivalent to static `addPropertyEffect` API but can be called on\n         * an instance to add effects at runtime.  See that method for\n         * full API docs.\n         *\n         * @param {string} property Property that should trigger the effect\n         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n         * @param {Object=} effect Effect metadata object\n         * @protected\n         */\n\n      }, {\n        key: '_addPropertyEffect',\n        value: function _addPropertyEffect(property, type, effect) {\n          this._createPropertyAccessor(property, type == TYPES.READ_ONLY);\n          // effects are accumulated into arrays per property based on type\n          var effects = ensureOwnEffectMap(this, type)[property];\n          if (!effects) {\n            effects = this[type][property] = [];\n          }\n          effects.push(effect);\n        }\n\n        /**\n         * Removes the given property effect.\n         *\n         * @param {string} property Property the effect was associated with\n         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n         * @param {Object=} effect Effect metadata object to remove\n         */\n\n      }, {\n        key: '_removePropertyEffect',\n        value: function _removePropertyEffect(property, type, effect) {\n          var effects = ensureOwnEffectMap(this, type)[property];\n          var idx = effects.indexOf(effect);\n          if (idx >= 0) {\n            effects.splice(idx, 1);\n          }\n        }\n\n        /**\n         * Returns whether the current prototype/instance has a property effect\n         * of a certain type.\n         *\n         * @param {string} property Property name\n         * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n         * @return {boolean} True if the prototype/instance has an effect of this type\n         * @protected\n         */\n\n      }, {\n        key: '_hasPropertyEffect',\n        value: function _hasPropertyEffect(property, type) {\n          var effects = this[type];\n          return Boolean(effects && effects[property]);\n        }\n\n        /**\n         * Returns whether the current prototype/instance has a \"read only\"\n         * accessor for the given property.\n         *\n         * @param {string} property Property name\n         * @return {boolean} True if the prototype/instance has an effect of this type\n         * @protected\n         */\n\n      }, {\n        key: '_hasReadOnlyEffect',\n        value: function _hasReadOnlyEffect(property) {\n          return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n        }\n\n        /**\n         * Returns whether the current prototype/instance has a \"notify\"\n         * property effect for the given property.\n         *\n         * @param {string} property Property name\n         * @return {boolean} True if the prototype/instance has an effect of this type\n         * @protected\n         */\n\n      }, {\n        key: '_hasNotifyEffect',\n        value: function _hasNotifyEffect(property) {\n          return this._hasPropertyEffect(property, TYPES.NOTIFY);\n        }\n\n        /**\n         * Returns whether the current prototype/instance has a \"reflect to attribute\"\n         * property effect for the given property.\n         *\n         * @param {string} property Property name\n         * @return {boolean} True if the prototype/instance has an effect of this type\n         * @protected\n         */\n\n      }, {\n        key: '_hasReflectEffect',\n        value: function _hasReflectEffect(property) {\n          return this._hasPropertyEffect(property, TYPES.REFLECT);\n        }\n\n        /**\n         * Returns whether the current prototype/instance has a \"computed\"\n         * property effect for the given property.\n         *\n         * @param {string} property Property name\n         * @return {boolean} True if the prototype/instance has an effect of this type\n         * @protected\n         */\n\n      }, {\n        key: '_hasComputedEffect',\n        value: function _hasComputedEffect(property) {\n          return this._hasPropertyEffect(property, TYPES.COMPUTE);\n        }\n\n        // Runtime ----------------------------------------\n\n        /**\n         * Sets a pending property or path.  If the root property of the path in\n         * question had no accessor, the path is set, otherwise it is enqueued\n         * via `_setPendingProperty`.\n         *\n         * This function isolates relatively expensive functionality necessary\n         * for the public API (`set`, `setProperties`, `notifyPath`, and property\n         * change listeners via {{...}} bindings), such that it is only done\n         * when paths enter the system, and not at every propagation step.  It\n         * also sets a `__dataHasPaths` flag on the instance which is used to\n         * fast-path slower path-matching code in the property effects host paths.\n         *\n         * `path` can be a path string or array of path parts as accepted by the\n         * public API.\n         *\n         * @param {string | !Array<number|string>} path Path to set\n         * @param {*} value Value to set\n         * @param {boolean=} shouldNotify Set to true if this change should\n         *  cause a property notification event dispatch\n         * @param {boolean=} isPathNotification If the path being set is a path\n         *   notification of an already changed value, as opposed to a request\n         *   to set and notify the change.  In the latter `false` case, a dirty\n         *   check is performed and then the value is set to the path before\n         *   enqueuing the pending property change.\n         * @return {boolean} Returns true if the property/path was enqueued in\n         *   the pending changes bag.\n         * @protected\n         */\n\n      }, {\n        key: '_setPendingPropertyOrPath',\n        value: function _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n          if (isPathNotification || Polymer.Path.root(Array.isArray(path) ? path[0] : path) !== path) {\n            // Dirty check changes being set to a path against the actual object,\n            // since this is the entry point for paths into the system; from here\n            // the only dirty checks are against the `__dataTemp` cache to prevent\n            // duplicate work in the same turn only. Note, if this was a notification\n            // of a change already set to a path (isPathNotification: true),\n            // we always let the change through and skip the `set` since it was\n            // already dirty checked at the point of entry and the underlying\n            // object has already been updated\n            if (!isPathNotification) {\n              var old = Polymer.Path.get(this, path);\n              path = /** @type {string} */Polymer.Path.set(this, path, value);\n              // Use property-accessor's simpler dirty check\n              if (!path || !_get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_shouldPropertyChange', this).call(this, path, value, old)) {\n                return false;\n              }\n            }\n            this.__dataHasPaths = true;\n            if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {\n              computeLinkedPaths(this, path, value);\n              return true;\n            }\n          } else {\n            if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n              return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);\n            } else {\n              this[path] = value;\n            }\n          }\n          return false;\n        }\n\n        /**\n         * Applies a value to a non-Polymer element/node's property.\n         *\n         * The implementation makes a best-effort at binding interop:\n         * Some native element properties have side-effects when\n         * re-setting the same value (e.g. setting `<input>.value` resets the\n         * cursor position), so we do a dirty-check before setting the value.\n         * However, for better interop with non-Polymer custom elements that\n         * accept objects, we explicitly re-set object changes coming from the\n         * Polymer world (which may include deep object changes without the\n         * top reference changing), erring on the side of providing more\n         * information.\n         *\n         * Users may override this method to provide alternate approaches.\n         *\n         * @param {Node} node The node to set a property on\n         * @param {string} prop The property to set\n         * @param {*} value The value to set\n         * @protected\n         */\n\n      }, {\n        key: '_setUnmanagedPropertyToNode',\n        value: function _setUnmanagedPropertyToNode(node, prop, value) {\n          // It is a judgment call that resetting primitives is\n          // \"bad\" and resettings objects is also \"good\"; alternatively we could\n          // implement a whitelist of tag & property values that should never\n          // be reset (e.g. <input>.value && <select>.value)\n          if (value !== node[prop] || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {\n            node[prop] = value;\n          }\n        }\n\n        /**\n         * Overrides the `PropertyAccessors` implementation to introduce special\n         * dirty check logic depending on the property & value being set:\n         *\n         * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n         *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n         * 2. Object set to simple property (e.g. 'prop': {...})\n         *    Stored in `__dataTemp` and `__data`, dirty checked against\n         *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n         * 3. Primitive value set to simple property (e.g. 'prop': 42)\n         *    Stored in `__data`, dirty checked against `__data`\n         *\n         * The dirty-check is important to prevent cycles due to two-way\n         * notification, but paths and objects are only dirty checked against any\n         * previous value set during this turn via a \"temporary cache\" that is\n         * cleared when the last `_propertiesChaged` exits. This is so:\n         * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n         *    due to array mutations like shift/unshift/splice; this is fine\n         *    since path changes are dirty-checked at user entry points like `set`\n         * b. dirty-checking for objects only lasts one turn to allow the user\n         *    to mutate the object in-place and re-set it with the same identity\n         *    and have all sub-properties re-propagated in a subsequent turn.\n         *\n         * The temp cache is not necessarily sufficient to prevent invalid array\n         * paths, since a splice can happen during the same turn (with pathological\n         * user code); we could introduce a \"fixup\" for temporarily cached array\n         * paths if needed: https://github.com/Polymer/polymer/issues/4227\n         *\n         * @param {string} property Name of the property\n         * @param {*} value Value to set\n         * @param {boolean=} shouldNotify True if property should fire notification\n         *   event (applies only for `notify: true` properties)\n         * @return {boolean} Returns true if the property changed\n         * @override\n         */\n\n      }, {\n        key: '_setPendingProperty',\n        value: function _setPendingProperty(property, value, shouldNotify) {\n          var isPath = this.__dataHasPaths && Polymer.Path.isPath(property);\n          var prevProps = isPath ? this.__dataTemp : this.__data;\n          if (this._shouldPropertyChange(property, value, prevProps[property])) {\n            if (!this.__dataPending) {\n              this.__dataPending = {};\n              this.__dataOld = {};\n            }\n            // Ensure old is captured from the last turn\n            if (!(property in this.__dataOld)) {\n              this.__dataOld[property] = this.__data[property];\n            }\n            // Paths are stored in temporary cache (cleared at end of turn),\n            // which is used for dirty-checking, all others stored in __data\n            if (isPath) {\n              this.__dataTemp[property] = value;\n            } else {\n              this.__data[property] = value;\n            }\n            // All changes go into pending property bag, passed to _propertiesChanged\n            this.__dataPending[property] = value;\n            // Track properties that should notify separately\n            if (isPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {\n              this.__dataToNotify = this.__dataToNotify || {};\n              this.__dataToNotify[property] = shouldNotify;\n            }\n            return true;\n          }\n          return false;\n        }\n\n        /**\n         * Overrides base implementation to ensure all accessors set `shouldNotify`\n         * to true, for per-property notification tracking.\n         *\n         * @override\n         */\n\n      }, {\n        key: '_setProperty',\n        value: function _setProperty(property, value) {\n          if (this._setPendingProperty(property, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n\n        /**\n         * Overrides `PropertyAccessor`'s default async queuing of\n         * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n         * manually flushed), the function no-ops; otherwise flushes\n         * `_propertiesChanged` synchronously.\n         *\n         * @override\n         */\n\n      }, {\n        key: '_invalidateProperties',\n        value: function _invalidateProperties() {\n          if (this.__dataReady) {\n            this._flushProperties();\n          }\n        }\n\n        /**\n         * Enqueues the given client on a list of pending clients, whose\n         * pending property changes can later be flushed via a call to\n         * `_flushClients`.\n         *\n         * @param {Object} client PropertyEffects client to enqueue\n         * @protected\n         */\n\n      }, {\n        key: '_enqueueClient',\n        value: function _enqueueClient(client) {\n          this.__dataPendingClients = this.__dataPendingClients || [];\n          if (client !== this) {\n            this.__dataPendingClients.push(client);\n          }\n        }\n\n        /**\n         * Flushes any clients previously enqueued via `_enqueueClient`, causing\n         * their `_flushProperties` method to run.\n         *\n         * @protected\n         */\n\n      }, {\n        key: '_flushClients',\n        value: function _flushClients() {\n          if (!this.__dataClientsReady) {\n            this.__dataClientsReady = true;\n            this._readyClients();\n            // Override point where accessors are turned on; importantly,\n            // this is after clients have fully readied, providing a guarantee\n            // that any property effects occur only after all clients are ready.\n            this.__dataReady = true;\n          } else {\n            this.__enableOrFlushClients();\n          }\n        }\n\n        // NOTE: We ensure clients either enable or flush as appropriate. This\n        // handles two corner cases:\n        // (1) clients flush properly when connected/enabled before the host\n        // enables; e.g.\n        //   (a) Templatize stamps with no properties and does not flush and\n        //   (b) the instance is inserted into dom and\n        //   (c) then the instance flushes.\n        // (2) clients enable properly when not connected/enabled when the host\n        // flushes; e.g.\n        //   (a) a template is runtime stamped and not yet connected/enabled\n        //   (b) a host sets a property, causing stamped dom to flush\n        //   (c) the stamped dom enables.\n\n      }, {\n        key: '__enableOrFlushClients',\n        value: function __enableOrFlushClients() {\n          var clients = this.__dataPendingClients;\n          if (clients) {\n            this.__dataPendingClients = null;\n            for (var i = 0; i < clients.length; i++) {\n              var client = clients[i];\n              if (!client.__dataEnabled) {\n                client._enableProperties();\n              } else if (client.__dataPending) {\n                client._flushProperties();\n              }\n            }\n          }\n        }\n\n        /**\n         * Perform any initial setup on client dom. Called before the first\n         * `_flushProperties` call on client dom and before any element\n         * observers are called.\n         *\n         * @protected\n         */\n\n      }, {\n        key: '_readyClients',\n        value: function _readyClients() {\n          this.__enableOrFlushClients();\n        }\n\n        /**\n         * Sets a bag of property changes to this instance, and\n         * synchronously processes all effects of the properties as a batch.\n         *\n         * Property names must be simple properties, not paths.  Batched\n         * path propagation is not supported.\n         *\n         * @param {Object} props Bag of one or more key-value pairs whose key is\n         *   a property and value is the new value to set for that property.\n         * @param {boolean=} setReadOnly When true, any private values set in\n         *   `props` will be set. By default, `setProperties` will not set\n         *   `readOnly: true` root properties.\n         * @public\n         */\n\n      }, {\n        key: 'setProperties',\n        value: function setProperties(props, setReadOnly) {\n          for (var path in props) {\n            if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {\n              //TODO(kschaaf): explicitly disallow paths in setProperty?\n              // wildcard observers currently only pass the first changed path\n              // in the `info` object, and you could do some odd things batching\n              // paths, e.g. {'foo.bar': {...}, 'foo': null}\n              this._setPendingPropertyOrPath(path, props[path], true);\n            }\n          }\n          this._invalidateProperties();\n        }\n\n        /**\n         * Overrides `PropertyAccessors` so that property accessor\n         * side effects are not enabled until after client dom is fully ready.\n         * Also calls `_flushClients` callback to ensure client dom is enabled\n         * that was not enabled as a result of flushing properties.\n         *\n         * @override\n         */\n\n      }, {\n        key: 'ready',\n        value: function ready() {\n          // It is important that `super.ready()` is not called here as it\n          // immediately turns on accessors. Instead, we wait until `readyClients`\n          // to enable accessors to provide a guarantee that clients are ready\n          // before processing any accessors side effects.\n          this._flushProperties();\n          // If no data was pending, `_flushProperties` will not `flushClients`\n          // so ensure this is done.\n          if (!this.__dataClientsReady) {\n            this._flushClients();\n          }\n          // Before ready, client notifications do not trigger _flushProperties.\n          // Therefore a flush is necessary here if data has been set.\n          if (this.__dataPending) {\n            this._flushProperties();\n          }\n        }\n\n        /**\n         * Implements `PropertyAccessors`'s properties changed callback.\n         *\n         * Runs each class of effects for the batch of changed properties in\n         * a specific order (compute, propagate, reflect, observe, notify).\n         *\n         * @override\n         */\n\n      }, {\n        key: '_propertiesChanged',\n        value: function _propertiesChanged(currentProps, changedProps, oldProps) {\n          // ----------------------------\n          // let c = Object.getOwnPropertyNames(changedProps || {});\n          // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n          // if (window.debug) { debugger; }\n          // ----------------------------\n          var hasPaths = this.__dataHasPaths;\n          this.__dataHasPaths = false;\n          // Compute properties\n          runComputedEffects(this, changedProps, oldProps, hasPaths);\n          // Clear notify properties prior to possible reentry (propagate, observe),\n          // but after computing effects have a chance to add to them\n          var notifyProps = this.__dataToNotify;\n          this.__dataToNotify = null;\n          // Propagate properties to clients\n          this._propagatePropertyChanges(changedProps, oldProps, hasPaths);\n          // Flush clients\n          this._flushClients();\n          // Reflect properties\n          runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);\n          // Observe properties\n          runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);\n          // Notify properties to host\n          if (notifyProps) {\n            runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n          }\n          // Clear temporary cache at end of turn\n          if (this.__dataCounter == 1) {\n            this.__dataTemp = {};\n          }\n          // ----------------------------\n          // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n          // ----------------------------\n        }\n\n        /**\n         * Called to propagate any property changes to stamped template nodes\n         * managed by this element.\n         *\n         * @param {Object} changedProps Bag of changed properties\n         * @param {Object} oldProps Bag of previous values for changed properties\n         * @param {boolean} hasPaths True with `props` contains one or more paths\n         * @protected\n         */\n\n      }, {\n        key: '_propagatePropertyChanges',\n        value: function _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n          if (this[TYPES.PROPAGATE]) {\n            runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);\n          }\n          var templateInfo = this.__templateInfo;\n          while (templateInfo) {\n            runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);\n            templateInfo = templateInfo.nextTemplateInfo;\n          }\n        }\n\n        /**\n         * Aliases one data path as another, such that path notifications from one\n         * are routed to the other.\n         *\n         * @param {string | !Array<string|number>} to Target path to link.\n         * @param {string | !Array<string|number>} from Source path to link.\n         * @public\n         */\n\n      }, {\n        key: 'linkPaths',\n        value: function linkPaths(to, from) {\n          to = Polymer.Path.normalize(to);\n          from = Polymer.Path.normalize(from);\n          this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n          this.__dataLinkedPaths[to] = from;\n        }\n\n        /**\n         * Removes a data path alias previously established with `_linkPaths`.\n         *\n         * Note, the path to unlink should be the target (`to`) used when\n         * linking the paths.\n         *\n         * @param {string | !Array<string|number>} path Target path to unlink.\n         * @public\n         */\n\n      }, {\n        key: 'unlinkPaths',\n        value: function unlinkPaths(path) {\n          path = Polymer.Path.normalize(path);\n          if (this.__dataLinkedPaths) {\n            delete this.__dataLinkedPaths[path];\n          }\n        }\n\n        /**\n         * Notify that an array has changed.\n         *\n         * Example:\n         *\n         *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n         *     ...\n         *     this.items.splice(1, 1, {name: 'Sam'});\n         *     this.items.push({name: 'Bob'});\n         *     this.notifySplices('items', [\n         *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },\n         *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}\n         *     ]);\n         *\n         * @param {string} path Path that should be notified.\n         * @param {Array} splices Array of splice records indicating ordered\n         *   changes that occurred to the array. Each record should have the\n         *   following fields:\n         *    * index: index at which the change occurred\n         *    * removed: array of items that were removed from this index\n         *    * addedCount: number of new items added at this index\n         *    * object: a reference to the array in question\n         *    * type: the string literal 'splice'\n         *\n         *   Note that splice records _must_ be normalized such that they are\n         *   reported in index order (raw results from `Object.observe` are not\n         *   ordered and must be normalized/merged before notifying).\n         * @public\n        */\n\n      }, {\n        key: 'notifySplices',\n        value: function notifySplices(path, splices) {\n          var info = { path: '' };\n          var array = /** @type {Array} */Polymer.Path.get(this, path, info);\n          _notifySplices(this, array, info.path, splices);\n        }\n\n        /**\n         * Convenience method for reading a value from a path.\n         *\n         * Note, if any part in the path is undefined, this method returns\n         * `undefined` (this method does not throw when dereferencing undefined\n         * paths).\n         *\n         * @param {(string|!Array<(string|number)>)} path Path to the value\n         *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n         *   bracketed expressions are not supported; string-based path parts\n         *   *must* be separated by dots.  Note that when dereferencing array\n         *   indices, the index may be used as a dotted part directly\n         *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n         * @param {Object=} root Root object from which the path is evaluated.\n         * @return {*} Value at the path, or `undefined` if any part of the path\n         *   is undefined.\n         * @public\n         */\n\n      }, {\n        key: 'get',\n        value: function get(path, root) {\n          return Polymer.Path.get(root || this, path);\n        }\n\n        /**\n         * Convenience method for setting a value to a path and notifying any\n         * elements bound to the same path.\n         *\n         * Note, if any part in the path except for the last is undefined,\n         * this method does nothing (this method does not throw when\n         * dereferencing undefined paths).\n         *\n         * @param {(string|!Array<(string|number)>)} path Path to the value\n         *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n         *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n         *   bracketed expressions are not supported; string-based path parts\n         *   *must* be separated by dots.  Note that when dereferencing array\n         *   indices, the index may be used as a dotted part directly\n         *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n         * @param {*} value Value to set at the specified path.\n         * @param {Object=} root Root object from which the path is evaluated.\n         *   When specified, no notification will occur.\n         * @public\n        */\n\n      }, {\n        key: 'set',\n        value: function set(path, value, root) {\n          if (root) {\n            Polymer.Path.set(root, path, value);\n          } else {\n            if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {\n              if (this._setPendingPropertyOrPath(path, value, true)) {\n                this._invalidateProperties();\n              }\n            }\n          }\n        }\n\n        /**\n         * Adds items onto the end of the array at the path specified.\n         *\n         * The arguments after `path` and return value match that of\n         * `Array.prototype.push`.\n         *\n         * This method notifies other paths to the same array that a\n         * splice occurred to the array.\n         *\n         * @param {string} path Path to array.\n         * @param {...*} items Items to push onto array\n         * @return {number} New length of the array.\n         * @public\n         */\n\n      }, {\n        key: 'push',\n        value: function push(path) {\n          var info = { path: '' };\n          var array = /** @type {Array}*/Polymer.Path.get(this, path, info);\n          var len = array.length;\n\n          for (var _len = arguments.length, items = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            items[_key - 1] = arguments[_key];\n          }\n\n          var ret = array.push.apply(array, items);\n          if (items.length) {\n            notifySplice(this, array, info.path, len, items.length, []);\n          }\n          return ret;\n        }\n\n        /**\n         * Removes an item from the end of array at the path specified.\n         *\n         * The arguments after `path` and return value match that of\n         * `Array.prototype.pop`.\n         *\n         * This method notifies other paths to the same array that a\n         * splice occurred to the array.\n         *\n         * @param {string} path Path to array.\n         * @return {*} Item that was removed.\n         * @public\n         */\n\n      }, {\n        key: 'pop',\n        value: function pop(path) {\n          var info = { path: '' };\n          var array = /** @type {Array} */Polymer.Path.get(this, path, info);\n          var hadLength = Boolean(array.length);\n          var ret = array.pop();\n          if (hadLength) {\n            notifySplice(this, array, info.path, array.length, 0, [ret]);\n          }\n          return ret;\n        }\n\n        /**\n         * Starting from the start index specified, removes 0 or more items\n         * from the array and inserts 0 or more new items in their place.\n         *\n         * The arguments after `path` and return value match that of\n         * `Array.prototype.splice`.\n         *\n         * This method notifies other paths to the same array that a\n         * splice occurred to the array.\n         *\n         * @param {string} path Path to array.\n         * @param {number} start Index from which to start removing/inserting.\n         * @param {number} deleteCount Number of items to remove.\n         * @param {...*} items Items to insert into array.\n         * @return {Array} Array of removed items.\n         * @public\n         */\n\n      }, {\n        key: 'splice',\n        value: function splice(path, start, deleteCount) {\n          var info = { path: '' };\n          var array = /** @type {Array} */Polymer.Path.get(this, path, info);\n          // Normalize fancy native splice handling of crazy start values\n          if (start < 0) {\n            start = array.length - Math.floor(-start);\n          } else {\n            start = Math.floor(start);\n          }\n          if (!start) {\n            start = 0;\n          }\n\n          for (var _len2 = arguments.length, items = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n            items[_key2 - 3] = arguments[_key2];\n          }\n\n          var ret = array.splice.apply(array, [start, deleteCount].concat(items));\n          if (items.length || ret.length) {\n            notifySplice(this, array, info.path, start, items.length, ret);\n          }\n          return ret;\n        }\n\n        /**\n         * Removes an item from the beginning of array at the path specified.\n         *\n         * The arguments after `path` and return value match that of\n         * `Array.prototype.pop`.\n         *\n         * This method notifies other paths to the same array that a\n         * splice occurred to the array.\n         *\n         * @param {string} path Path to array.\n         * @return {*} Item that was removed.\n         * @public\n         */\n\n      }, {\n        key: 'shift',\n        value: function shift(path) {\n          var info = { path: '' };\n          var array = /** @type {Array} */Polymer.Path.get(this, path, info);\n          var hadLength = Boolean(array.length);\n          var ret = array.shift();\n          if (hadLength) {\n            notifySplice(this, array, info.path, 0, 0, [ret]);\n          }\n          return ret;\n        }\n\n        /**\n         * Adds items onto the beginning of the array at the path specified.\n         *\n         * The arguments after `path` and return value match that of\n         * `Array.prototype.push`.\n         *\n         * This method notifies other paths to the same array that a\n         * splice occurred to the array.\n         *\n         * @param {string} path Path to array.\n         * @param {...*} items Items to insert info array\n         * @return {number} New length of the array.\n         * @public\n         */\n\n      }, {\n        key: 'unshift',\n        value: function unshift(path) {\n          var info = { path: '' };\n          var array = /** @type {Array} */Polymer.Path.get(this, path, info);\n\n          for (var _len3 = arguments.length, items = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n            items[_key3 - 1] = arguments[_key3];\n          }\n\n          var ret = array.unshift.apply(array, items);\n          if (items.length) {\n            notifySplice(this, array, info.path, 0, items.length, []);\n          }\n          return ret;\n        }\n\n        /**\n         * Notify that a path has changed.\n         *\n         * Example:\n         *\n         *     this.item.user.name = 'Bob';\n         *     this.notifyPath('item.user.name');\n         *\n         * @param {string} path Path that should be notified.\n         * @param {*=} value Value at the path (optional).\n         * @public\n        */\n\n      }, {\n        key: 'notifyPath',\n        value: function notifyPath(path, value) {\n          /** @type {string} */\n          var propPath = void 0;\n          if (arguments.length == 1) {\n            // Get value if not supplied\n            var info = { path: '' };\n            value = Polymer.Path.get(this, path, info);\n            propPath = info.path;\n          } else if (Array.isArray(path)) {\n            // Normalize path if needed\n            propPath = Polymer.Path.normalize(path);\n          } else {\n            propPath = /** @type{string} */path;\n          }\n          if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n            this._invalidateProperties();\n          }\n        }\n\n        /**\n         * Equivalent to static `createReadOnlyProperty` API but can be called on\n         * an instance to add effects at runtime.  See that method for\n         * full API docs.\n         *\n         * @param {string} property Property name\n         * @param {boolean=} protectedSetter Creates a custom protected setter\n         *   when `true`.\n         * @protected\n         */\n\n      }, {\n        key: '_createReadOnlyProperty',\n        value: function _createReadOnlyProperty(property, protectedSetter) {\n          this._addPropertyEffect(property, TYPES.READ_ONLY);\n          if (protectedSetter) {\n            this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {\n              this._setProperty(property, value);\n            };\n          }\n        }\n\n        /**\n         * Equivalent to static `createPropertyObserver` API but can be called on\n         * an instance to add effects at runtime.  See that method for\n         * full API docs.\n         *\n         * @param {string} property Property name\n         * @param {string} methodName Name of observer method to call\n         * @param {boolean=} dynamicFn Whether the method name should be included as\n         *   a dependency to the effect.\n         * @protected\n         */\n\n      }, {\n        key: '_createPropertyObserver',\n        value: function _createPropertyObserver(property, methodName, dynamicFn) {\n          var info = { property: property, methodName: methodName, dynamicFn: Boolean(dynamicFn) };\n          this._addPropertyEffect(property, TYPES.OBSERVE, {\n            fn: runObserverEffect, info: info, trigger: { name: property }\n          });\n          if (dynamicFn) {\n            this._addPropertyEffect(methodName, TYPES.OBSERVE, {\n              fn: runObserverEffect, info: info, trigger: { name: methodName }\n            });\n          }\n        }\n\n        /**\n         * Equivalent to static `createMethodObserver` API but can be called on\n         * an instance to add effects at runtime.  See that method for\n         * full API docs.\n         *\n         * @param {string} expression Method expression\n         * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n         *   whether method names should be included as a dependency to the effect.\n         * @protected\n         */\n\n      }, {\n        key: '_createMethodObserver',\n        value: function _createMethodObserver(expression, dynamicFn) {\n          var sig = parseMethod(expression);\n          if (!sig) {\n            throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n          }\n          createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n        }\n\n        /**\n         * Equivalent to static `createNotifyingProperty` API but can be called on\n         * an instance to add effects at runtime.  See that method for\n         * full API docs.\n         *\n         * @param {string} property Property name\n         * @protected\n         */\n\n      }, {\n        key: '_createNotifyingProperty',\n        value: function _createNotifyingProperty(property) {\n          this._addPropertyEffect(property, TYPES.NOTIFY, {\n            fn: runNotifyEffect,\n            info: {\n              eventName: CaseMap.camelToDashCase(property) + '-changed',\n              property: property\n            }\n          });\n        }\n\n        /**\n         * Equivalent to static `createReflectedProperty` API but can be called on\n         * an instance to add effects at runtime.  See that method for\n         * full API docs.\n         *\n         * @param {string} property Property name\n         * @protected\n         */\n\n      }, {\n        key: '_createReflectedProperty',\n        value: function _createReflectedProperty(property) {\n          var attr = CaseMap.camelToDashCase(property);\n          if (attr[0] === '-') {\n            console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');\n          } else {\n            this._addPropertyEffect(property, TYPES.REFLECT, {\n              fn: runReflectEffect,\n              info: {\n                attrName: attr\n              }\n            });\n          }\n        }\n\n        /**\n         * Equivalent to static `createComputedProperty` API but can be called on\n         * an instance to add effects at runtime.  See that method for\n         * full API docs.\n         *\n         * @param {string} property Name of computed property to set\n         * @param {string} expression Method expression\n         * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n         *   whether method names should be included as a dependency to the effect.\n         * @protected\n         */\n\n      }, {\n        key: '_createComputedProperty',\n        value: function _createComputedProperty(property, expression, dynamicFn) {\n          var sig = parseMethod(expression);\n          if (!sig) {\n            throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n          }\n          createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\n        }\n\n        // -- static class methods ------------\n\n        /**\n         * Ensures an accessor exists for the specified property, and adds\n         * to a list of \"property effects\" that will run when the accessor for\n         * the specified property is set.  Effects are grouped by \"type\", which\n         * roughly corresponds to a phase in effect processing.  The effect\n         * metadata should be in the following form:\n         *\n         *   {\n         *     fn: effectFunction, // Reference to function to call to perform effect\n         *     info: { ... }       // Effect metadata passed to function\n         *     trigger: {          // Optional triggering metadata; if not provided\n         *       name: string      // the property is treated as a wildcard\n         *       structured: boolean\n         *       wildcard: boolean\n         *     }\n         *   }\n         *\n         * Effects are called from `_propertiesChanged` in the following order by\n         * type:\n         *\n         * 1. COMPUTE\n         * 2. PROPAGATE\n         * 3. REFLECT\n         * 4. OBSERVE\n         * 5. NOTIFY\n         *\n         * Effect functions are called with the following signature:\n         *\n         *   effectFunction(inst, path, props, oldProps, info, hasPaths)\n         *\n         * @param {string} property Property that should trigger the effect\n         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n         * @param {Object=} effect Effect metadata object\n         * @protected\n         */\n\n      }, {\n        key: '_bindTemplate',\n\n\n        // -- binding ----------------------------------------------\n\n        /**\n         * Equivalent to static `bindTemplate` API but can be called on\n         * an instance to add effects at runtime.  See that method for\n         * full API docs.\n         *\n         * This method may be called on the prototype (for prototypical template\n         * binding, to avoid creating accessors every instance) once per prototype,\n         * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n         * create and link an instance of the template metadata associated with a\n         * particular stamping.\n         *\n         * @param {HTMLTemplateElement} template Template containing binding\n         *   bindings\n         * @param {boolean=} instanceBinding When false (default), performs\n         *   \"prototypical\" binding of the template and overwrites any previously\n         *   bound template for the class. When true (as passed from\n         *   `_stampTemplate`), the template info is instanced and linked into\n         *   the list of bound templates.\n         * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,\n         *   this is an instance of the prototypical template info\n         * @protected\n         */\n        value: function _bindTemplate(template, instanceBinding) {\n          var templateInfo = this.constructor._parseTemplate(template);\n          var wasPreBound = this.__templateInfo == templateInfo;\n          // Optimization: since this is called twice for proto-bound templates,\n          // don't attempt to recreate accessors if this template was pre-bound\n          if (!wasPreBound) {\n            for (var prop in templateInfo.propertyEffects) {\n              this._createPropertyAccessor(prop);\n            }\n          }\n          if (instanceBinding) {\n            // For instance-time binding, create instance of template metadata\n            // and link into list of templates if necessary\n            templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);\n            templateInfo.wasPreBound = wasPreBound;\n            if (!wasPreBound && this.__templateInfo) {\n              var last = this.__templateInfoLast || this.__templateInfo;\n              this.__templateInfoLast = last.nextTemplateInfo = templateInfo;\n              templateInfo.previousTemplateInfo = last;\n              return templateInfo;\n            }\n          }\n          return this.__templateInfo = templateInfo;\n        }\n\n        /**\n         * Adds a property effect to the given template metadata, which is run\n         * at the \"propagate\" stage of `_propertiesChanged` when the template\n         * has been bound to the element via `_bindTemplate`.\n         *\n         * The `effect` object should match the format in `_addPropertyEffect`.\n         *\n         * @param {Object} templateInfo Template metadata to add effect to\n         * @param {string} prop Property that should trigger the effect\n         * @param {Object=} effect Effect metadata object\n         * @protected\n         */\n\n      }, {\n        key: '_stampTemplate',\n\n\n        /**\n         * Stamps the provided template and performs instance-time setup for\n         * Polymer template features, including data bindings, declarative event\n         * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n         * is returned containing the stamped DOM, ready for insertion into the\n         * DOM.\n         *\n         * This method may be called more than once; however note that due to\n         * `shadycss` polyfill limitations, only styles from templates prepared\n         * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n         * to the shadow root and support CSS custom properties), and note that\n         * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n         * any styles required by in runtime-stamped templates must be included\n         * in the main element template.\n         *\n         * @param {!HTMLTemplateElement} template Template to stamp\n         * @return {!StampedTemplate} Cloned template content\n         * @override\n         * @protected\n         */\n        value: function _stampTemplate(template) {\n          // Ensures that created dom is `_enqueueClient`'d to this element so\n          // that it can be flushed on next call to `_flushProperties`\n          hostStack.beginHosting(this);\n          var dom = _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_stampTemplate', this).call(this, template);\n          hostStack.endHosting(this);\n          var templateInfo = /** @type {!TemplateInfo} */this._bindTemplate(template, true);\n          // Add template-instance-specific data to instanced templateInfo\n          templateInfo.nodeList = dom.nodeList;\n          // Capture child nodes to allow unstamping of non-prototypical templates\n          if (!templateInfo.wasPreBound) {\n            var nodes = templateInfo.childNodes = [];\n            for (var n = dom.firstChild; n; n = n.nextSibling) {\n              nodes.push(n);\n            }\n          }\n          dom.templateInfo = templateInfo;\n          // Setup compound storage, 2-way listeners, and dataHost for bindings\n          setupBindings(this, templateInfo);\n          // Flush properties into template nodes if already booted\n          if (this.__dataReady) {\n            runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);\n          }\n          return dom;\n        }\n\n        /**\n         * Removes and unbinds the nodes previously contained in the provided\n         * DocumentFragment returned from `_stampTemplate`.\n         *\n         * @param {!StampedTemplate} dom DocumentFragment previously returned\n         *   from `_stampTemplate` associated with the nodes to be removed\n         * @protected\n         */\n\n      }, {\n        key: '_removeBoundDom',\n        value: function _removeBoundDom(dom) {\n          // Unlink template info\n          var templateInfo = dom.templateInfo;\n          if (templateInfo.previousTemplateInfo) {\n            templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;\n          }\n          if (templateInfo.nextTemplateInfo) {\n            templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;\n          }\n          if (this.__templateInfoLast == templateInfo) {\n            this.__templateInfoLast = templateInfo.previousTemplateInfo;\n          }\n          templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;\n          // Remove stamped nodes\n          var nodes = templateInfo.childNodes;\n          for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            node.parentNode.removeChild(node);\n          }\n        }\n\n        /**\n         * Overrides default `TemplateStamp` implementation to add support for\n         * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n         * array is added to `nodeInfo` and populated with binding metadata\n         * with information capturing the binding target, and a `parts` array\n         * with one or more metadata objects capturing the source(s) of the\n         * binding.\n         *\n         * @override\n         * @param {Node} node Node to parse\n         * @param {TemplateInfo} templateInfo Template metadata for current template\n         * @param {NodeInfo} nodeInfo Node metadata for current template node\n         * @return {boolean} `true` if the visited node added node-specific\n         *   metadata to `nodeInfo`\n         * @protected\n         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n         */\n\n      }, {\n        key: 'PROPERTY_EFFECT_TYPES',\n        get: function get() {\n          return TYPES;\n        }\n      }], [{\n        key: 'addPropertyEffect',\n        value: function addPropertyEffect(property, type, effect) {\n          this.prototype._addPropertyEffect(property, type, effect);\n        }\n\n        /**\n         * Creates a single-property observer for the given property.\n         *\n         * @param {string} property Property name\n         * @param {string} methodName Name of observer method to call\n         * @param {boolean=} dynamicFn Whether the method name should be included as\n         *   a dependency to the effect.\n         * @protected\n         */\n\n      }, {\n        key: 'createPropertyObserver',\n        value: function createPropertyObserver(property, methodName, dynamicFn) {\n          this.prototype._createPropertyObserver(property, methodName, dynamicFn);\n        }\n\n        /**\n         * Creates a multi-property \"method observer\" based on the provided\n         * expression, which should be a string in the form of a normal Javascript\n         * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n         * should correspond to a property or path in the context of this\n         * prototype (or instance), or may be a literal string or number.\n         *\n         * @param {string} expression Method expression\n         * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n         *   whether method names should be included as a dependency to the effect.\n         * @protected\n         */\n\n      }, {\n        key: 'createMethodObserver',\n        value: function createMethodObserver(expression, dynamicFn) {\n          this.prototype._createMethodObserver(expression, dynamicFn);\n        }\n\n        /**\n         * Causes the setter for the given property to dispatch `<property>-changed`\n         * events to notify of changes to the property.\n         *\n         * @param {string} property Property name\n         * @protected\n         */\n\n      }, {\n        key: 'createNotifyingProperty',\n        value: function createNotifyingProperty(property) {\n          this.prototype._createNotifyingProperty(property);\n        }\n\n        /**\n         * Creates a read-only accessor for the given property.\n         *\n         * To set the property, use the protected `_setProperty` API.\n         * To create a custom protected setter (e.g. `_setMyProp()` for\n         * property `myProp`), pass `true` for `protectedSetter`.\n         *\n         * Note, if the property will have other property effects, this method\n         * should be called first, before adding other effects.\n         *\n         * @param {string} property Property name\n         * @param {boolean=} protectedSetter Creates a custom protected setter\n         *   when `true`.\n         * @protected\n         */\n\n      }, {\n        key: 'createReadOnlyProperty',\n        value: function createReadOnlyProperty(property, protectedSetter) {\n          this.prototype._createReadOnlyProperty(property, protectedSetter);\n        }\n\n        /**\n         * Causes the setter for the given property to reflect the property value\n         * to a (dash-cased) attribute of the same name.\n         *\n         * @param {string} property Property name\n         * @protected\n         */\n\n      }, {\n        key: 'createReflectedProperty',\n        value: function createReflectedProperty(property) {\n          this.prototype._createReflectedProperty(property);\n        }\n\n        /**\n         * Creates a computed property whose value is set to the result of the\n         * method described by the given `expression` each time one or more\n         * arguments to the method changes.  The expression should be a string\n         * in the form of a normal Javascript function signature:\n         * `'methodName(arg1, [..., argn])'`\n         *\n         * @param {string} property Name of computed property to set\n         * @param {string} expression Method expression\n         * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n         *   method names should be included as a dependency to the effect.\n         * @protected\n         */\n\n      }, {\n        key: 'createComputedProperty',\n        value: function createComputedProperty(property, expression, dynamicFn) {\n          this.prototype._createComputedProperty(property, expression, dynamicFn);\n        }\n\n        /**\n         * Parses the provided template to ensure binding effects are created\n         * for them, and then ensures property accessors are created for any\n         * dependent properties in the template.  Binding effects for bound\n         * templates are stored in a linked list on the instance so that\n         * templates can be efficiently stamped and unstamped.\n         *\n         * @param {HTMLTemplateElement} template Template containing binding\n         *   bindings\n         * @return {Object} Template metadata object\n         * @protected\n         */\n\n      }, {\n        key: 'bindTemplate',\n        value: function bindTemplate(template) {\n          return this.prototype._bindTemplate(template);\n        }\n      }, {\n        key: '_addTemplatePropertyEffect',\n        value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {\n          var hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n          hostProps[prop] = true;\n          var effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n          var propEffects = effects[prop] = effects[prop] || [];\n          propEffects.push(effect);\n        }\n      }, {\n        key: '_parseTemplateNode',\n        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {\n          var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNode', this).call(this, node, templateInfo, nodeInfo);\n          if (node.nodeType === Node.TEXT_NODE) {\n            var parts = this._parseBindings(node.textContent, templateInfo);\n            if (parts) {\n              // Initialize the textContent with any literal parts\n              // NOTE: default to a space here so the textNode remains; some browsers\n              // (IE) evacipate an empty textNode following cloneNode/importNode.\n              node.textContent = literalFromParts(parts) || ' ';\n              addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n              noted = true;\n            }\n          }\n          return noted;\n        }\n\n        /**\n         * Overrides default `TemplateStamp` implementation to add support for\n         * parsing bindings from attributes.  A `bindings`\n         * array is added to `nodeInfo` and populated with binding metadata\n         * with information capturing the binding target, and a `parts` array\n         * with one or more metadata objects capturing the source(s) of the\n         * binding.\n         *\n         * @override\n         * @param {Element} node Node to parse\n         * @param {TemplateInfo} templateInfo Template metadata for current template\n         * @param {NodeInfo} nodeInfo Node metadata for current template node\n         * @return {boolean} `true` if the visited node added node-specific\n         *   metadata to `nodeInfo`\n         * @protected\n         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n         */\n\n      }, {\n        key: '_parseTemplateNodeAttribute',\n        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n          var parts = this._parseBindings(value, templateInfo);\n          if (parts) {\n            // Attribute or property\n            var origName = name;\n            var kind = 'property';\n            if (name[name.length - 1] == '$') {\n              name = name.slice(0, -1);\n              kind = 'attribute';\n            }\n            // Initialize attribute bindings with any literal parts\n            var literal = literalFromParts(parts);\n            if (literal && kind == 'attribute') {\n              node.setAttribute(name, literal);\n            }\n            // Clear attribute before removing, since IE won't allow removing\n            // `value` attribute if it previously had a value (can't\n            // unconditionally set '' before removing since attributes with `$`\n            // can't be set using setAttribute)\n            if (node.localName === 'input' && origName === 'value') {\n              node.setAttribute(origName, '');\n            }\n            // Remove annotation\n            node.removeAttribute(origName);\n            // Case hackery: attributes are lower-case, but bind targets\n            // (properties) are case sensitive. Gambit is to map dash-case to\n            // camel-case: `foo-bar` becomes `fooBar`.\n            // Attribute bindings are excepted.\n            if (kind === 'property') {\n              name = Polymer.CaseMap.dashToCamelCase(name);\n            }\n            addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n            return true;\n          } else {\n            return _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNodeAttribute', this).call(this, node, templateInfo, nodeInfo, name, value);\n          }\n        }\n\n        /**\n         * Overrides default `TemplateStamp` implementation to add support for\n         * binding the properties that a nested template depends on to the template\n         * as `_host_<property>`.\n         *\n         * @override\n         * @param {Node} node Node to parse\n         * @param {TemplateInfo} templateInfo Template metadata for current template\n         * @param {NodeInfo} nodeInfo Node metadata for current template node\n         * @return {boolean} `true` if the visited node added node-specific\n         *   metadata to `nodeInfo`\n         * @protected\n         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n         */\n\n      }, {\n        key: '_parseTemplateNestedTemplate',\n        value: function _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n          var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNestedTemplate', this).call(this, node, templateInfo, nodeInfo);\n          // Merge host props into outer template and add bindings\n          var hostProps = nodeInfo.templateInfo.hostProps;\n          var mode = '{';\n          for (var source in hostProps) {\n            var parts = [{ mode: mode, source: source, dependencies: [source] }];\n            addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n          }\n          return noted;\n        }\n\n        /**\n         * Called to parse text in a template (either attribute values or\n         * textContent) into binding metadata.\n         *\n         * Any overrides of this method should return an array of binding part\n         * metadata  representing one or more bindings found in the provided text\n         * and any \"literal\" text in between.  Any non-literal parts will be passed\n         * to `_evaluateBinding` when any dependencies change.  The only required\n         * fields of each \"part\" in the returned array are as follows:\n         *\n         * - `dependencies` - Array containing trigger metadata for each property\n         *   that should trigger the binding to update\n         * - `literal` - String containing text if the part represents a literal;\n         *   in this case no `dependencies` are needed\n         *\n         * Additional metadata for use by `_evaluateBinding` may be provided in\n         * each part object as needed.\n         *\n         * The default implementation handles the following types of bindings\n         * (one or more may be intermixed with literal strings):\n         * - Property binding: `[[prop]]`\n         * - Path binding: `[[object.prop]]`\n         * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n         * - Two-way property or path bindings (supports negation):\n         *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n         * - Inline computed method (supports negation):\n         *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n         *\n         * @param {string} text Text to parse from attribute or textContent\n         * @param {Object} templateInfo Current template metadata\n         * @return {Array<!BindingPart>} Array of binding part metadata\n         * @protected\n         */\n\n      }, {\n        key: '_parseBindings',\n        value: function _parseBindings(text, templateInfo) {\n          var parts = [];\n          var lastIndex = 0;\n          var m = void 0;\n          // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n          // Regex matches:\n          //        Iteration 1:  Iteration 2:\n          // m[1]: '{{'          '[['\n          // m[2]: ''            '!'\n          // m[3]: 'prop'        'compute(foo,bar)'\n          while ((m = bindingRegex.exec(text)) !== null) {\n            // Add literal part\n            if (m.index > lastIndex) {\n              parts.push({ literal: text.slice(lastIndex, m.index) });\n            }\n            // Add binding part\n            var mode = m[1][0];\n            var negate = Boolean(m[2]);\n            var source = m[3].trim();\n            var customEvent = false,\n                notifyEvent = '',\n                colon = -1;\n            if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n              notifyEvent = source.substring(colon + 2);\n              source = source.substring(0, colon);\n              customEvent = true;\n            }\n            var signature = parseMethod(source);\n            var dependencies = [];\n            if (signature) {\n              // Inline computed function\n              var args = signature.args,\n                  methodName = signature.methodName;\n\n              for (var i = 0; i < args.length; i++) {\n                var arg = args[i];\n                if (!arg.literal) {\n                  dependencies.push(arg);\n                }\n              }\n              var dynamicFns = templateInfo.dynamicFns;\n              if (dynamicFns && dynamicFns[methodName] || signature.static) {\n                dependencies.push(methodName);\n                signature.dynamicFn = true;\n              }\n            } else {\n              // Property or path\n              dependencies.push(source);\n            }\n            parts.push({\n              source: source, mode: mode, negate: negate, customEvent: customEvent, signature: signature, dependencies: dependencies,\n              event: notifyEvent\n            });\n            lastIndex = bindingRegex.lastIndex;\n          }\n          // Add a final literal part\n          if (lastIndex && lastIndex < text.length) {\n            var literal = text.substring(lastIndex);\n            if (literal) {\n              parts.push({\n                literal: literal\n              });\n            }\n          }\n          if (parts.length) {\n            return parts;\n          } else {\n            return null;\n          }\n        }\n\n        /**\n         * Called to evaluate a previously parsed binding part based on a set of\n         * one or more changed dependencies.\n         *\n         * @param {this} inst Element that should be used as scope for\n         *   binding dependencies\n         * @param {BindingPart} part Binding part metadata\n         * @param {string} path Property/path that triggered this effect\n         * @param {Object} props Bag of current property changes\n         * @param {Object} oldProps Bag of previous values for changed properties\n         * @param {boolean} hasPaths True with `props` contains one or more paths\n         * @return {*} Value the binding part evaluated to\n         * @protected\n         */\n\n      }, {\n        key: '_evaluateBinding',\n        value: function _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n          var value = void 0;\n          if (part.signature) {\n            value = runMethodEffect(inst, path, props, oldProps, part.signature);\n          } else if (path != part.source) {\n            value = Polymer.Path.get(inst, part.source);\n          } else {\n            if (hasPaths && Polymer.Path.isPath(path)) {\n              value = Polymer.Path.get(inst, path);\n            } else {\n              value = inst.__data[path];\n            }\n          }\n          if (part.negate) {\n            value = !value;\n          }\n          return value;\n        }\n      }]);\n\n      return PropertyEffects;\n    }(propertyEffectsBase);\n\n    // make a typing for closure :P\n\n\n    PropertyEffectsType = PropertyEffects;\n\n    return PropertyEffects;\n  });\n\n  /**\n   * Helper api for enqueing client dom created by a host element.\n   *\n   * By default elements are flushed via `_flushProperties` when\n   * `connectedCallback` is called. Elements attach their client dom to\n   * themselves at `ready` time which results from this first flush.\n   * This provides an ordering guarantee that the client dom an element\n   * creates is flushed before the element itself (i.e. client `ready`\n   * fires before host `ready`).\n   *\n   * However, if `_flushProperties` is called *before* an element is connected,\n   * as for example `Templatize` does, this ordering guarantee cannot be\n   * satisfied because no elements are connected. (Note: Bound elements that\n   * receive data do become enqueued clients and are properly ordered but\n   * unbound elements are not.)\n   *\n   * To maintain the desired \"client before host\" ordering guarantee for this\n   * case we rely on the \"host stack. Client nodes registers themselves with\n   * the creating host element when created. This ensures that all client dom\n   * is readied in the proper order, maintaining the desired guarantee.\n   *\n   * @private\n   */\n  var hostStack = {\n\n    stack: [],\n\n    /**\n     * @param {*} inst Instance to add to hostStack\n     * @this {hostStack}\n     */\n    registerHost: function registerHost(inst) {\n      if (this.stack.length) {\n        var host = this.stack[this.stack.length - 1];\n        host._enqueueClient(inst);\n      }\n    },\n\n\n    /**\n     * @param {*} inst Instance to begin hosting\n     * @this {hostStack}\n     */\n    beginHosting: function beginHosting(inst) {\n      this.stack.push(inst);\n    },\n\n\n    /**\n     * @param {*} inst Instance to end hosting\n     * @this {hostStack}\n     */\n    endHosting: function endHosting(inst) {\n      var stackLen = this.stack.length;\n      if (stackLen && this.stack[stackLen - 1] == inst) {\n        this.stack.pop();\n      }\n    }\n  };\n})();\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n__webpack_require__(0);\n\n__webpack_require__(8);\n\n__webpack_require__(1);\n\n__webpack_require__(3);\n\n__webpack_require__(9);\n\n__webpack_require__(2);\n\n__webpack_require__(13);\n\n__webpack_require__(6);\n\n(function () {\n  'use strict';\n\n  /**\n   * Element class mixin that provides the core API for Polymer's meta-programming\n   * features including template stamping, data-binding, attribute deserialization,\n   * and property change observation.\n   *\n   * Subclassers may provide the following static getters to return metadata\n   * used to configure Polymer's features for the class:\n   *\n   * - `static get is()`: When the template is provided via a `dom-module`,\n   *   users should return the `dom-module` id from a static `is` getter.  If\n   *   no template is needed or the template is provided directly via the\n   *   `template` getter, there is no need to define `is` for the element.\n   *\n   * - `static get template()`: Users may provide the template directly (as\n   *   opposed to via `dom-module`) by implementing a static `template` getter.\n   *   The getter may return an `HTMLTemplateElement` or a string, which will\n   *   automatically be parsed into a template.\n   *\n   * - `static get properties()`: Should return an object describing\n   *   property-related metadata used by Polymer features (key: property name\n   *   value: object containing property metadata). Valid keys in per-property\n   *   metadata include:\n   *   - `type` (String|Number|Object|Array|...): Used by\n   *     `attributeChangedCallback` to determine how string-based attributes\n   *     are deserialized to JavaScript property values.\n   *   - `notify` (boolean): Causes a change in the property to fire a\n   *     non-bubbling event called `<property>-changed`. Elements that have\n   *     enabled two-way binding to the property use this event to observe changes.\n   *   - `readOnly` (boolean): Creates a getter for the property, but no setter.\n   *     To set a read-only property, use the private setter method\n   *     `_setProperty(property, value)`.\n   *   - `observer` (string): Observer method name that will be called when\n   *     the property changes. The arguments of the method are\n   *     `(value, previousValue)`.\n   *   - `computed` (string): String describing method and dependent properties\n   *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n   *     Computed properties are read-only by default and can only be changed\n   *     via the return value of the computing method.\n   *\n   * - `static get observers()`: Array of strings describing multi-property\n   *   observer methods and their dependent properties (e.g.\n   *   `'observeABC(a, b, c)'`).\n   *\n   * The base class provides default implementations for the following standard\n   * custom element lifecycle callbacks; users may override these, but should\n   * call the super method to ensure\n   * - `constructor`: Run when the element is created or upgraded\n   * - `connectedCallback`: Run each time the element is connected to the\n   *   document\n   * - `disconnectedCallback`: Run each time the element is disconnected from\n   *   the document\n   * - `attributeChangedCallback`: Run each time an attribute in\n   *   `observedAttributes` is set or removed (note: this element's default\n   *   `observedAttributes` implementation will automatically return an array\n   *   of dash-cased attributes based on `properties`)\n   *\n   * @mixinFunction\n   * @polymer\n   * @appliesMixin Polymer.PropertyEffects\n   * @memberof Polymer\n   * @property rootPath {string} Set to the value of `Polymer.rootPath`,\n   *   which defaults to the main document path\n   * @property importPath {string} Set to the value of the class's static\n   *   `importPath` property, which defaults to the path of this element's\n   *   `dom-module` (when `is` is used), but can be overridden for other\n   *   import strategies.\n   * @summary Element class mixin that provides the core API for Polymer's\n   * meta-programming features.\n   */\n\n  Polymer.ElementMixin = Polymer.dedupingMixin(function (base) {\n\n    /**\n     * @constructor\n     * @extends {base}\n     * @implements {Polymer_PropertyEffects}\n     */\n    var polymerElementBase = Polymer.PropertyEffects(base);\n\n    var caseMap = Polymer.CaseMap;\n\n    /**\n     * Returns the `properties` object specifically on `klass`. Use for:\n     * (1) super chain mixes togther to make `propertiesForClass` which is\n     * then used to make `observedAttributes`.\n     * (2) properties effects and observers are created from it at `finalize` time.\n     *\n     * @param {HTMLElement} klass Element class\n     * @return {Object} Object containing own properties for this class\n     * @private\n     */\n    function ownPropertiesForClass(klass) {\n      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', klass))) {\n        klass.__ownProperties = klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?\n        /** @type PolymerElementConstructor */klass.properties : {};\n      }\n      return klass.__ownProperties;\n    }\n\n    /**\n     * Returns the `observers` array specifically on `klass`. Use for\n     * setting up observers.\n     *\n     * @param {HTMLElement} klass Element class\n     * @return {Array} Array containing own observers for this class\n     * @private\n     */\n    function ownObserversForClass(klass) {\n      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', klass))) {\n        klass.__ownObservers = klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?\n        /** @type PolymerElementConstructor */klass.observers : [];\n      }\n      return klass.__ownObservers;\n    }\n\n    /**\n     * Mixes `props` into `flattenedProps` but upgrades shorthand type\n     * syntax to { type: Type}.\n     *\n     * @param {Object} flattenedProps Bag to collect flattened properties into\n     * @param {Object} props Bag of properties to add to `flattenedProps`\n     * @return {Object} The input `flattenedProps` bag\n     * @private\n     */\n    function flattenProperties(flattenedProps, props) {\n      for (var p in props) {\n        var o = props[p];\n        if (typeof o == 'function') {\n          o = { type: o };\n        }\n        flattenedProps[p] = o;\n      }\n      return flattenedProps;\n    }\n\n    /**\n     * Returns a flattened list of properties mixed together from the chain of all\n     * constructor's `config.properties`. This list is used to create\n     * (1) observedAttributes,\n     * (2) class property default values\n     *\n     * @param {PolymerElementConstructor} klass Element class\n     * @return {PolymerElementProperties} Flattened properties for this class\n     * @suppress {missingProperties} class.prototype is not a property for some reason?\n     * @private\n     */\n    function propertiesForClass(klass) {\n      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classProperties', klass))) {\n        klass.__classProperties = flattenProperties({}, ownPropertiesForClass(klass));\n        var superCtor = Object.getPrototypeOf(klass.prototype).constructor;\n        if (superCtor.prototype instanceof PolymerElement) {\n          klass.__classProperties = Object.assign(Object.create(propertiesForClass( /** @type PolymerElementConstructor */superCtor)), klass.__classProperties);\n        }\n      }\n      return klass.__classProperties;\n    }\n\n    /**\n     * Returns a list of properties with default values.\n     * This list is created as an optimization since it is a subset of\n     * the list returned from `propertiesForClass`.\n     * This list is used in `_initializeProperties` to set property defaults.\n     *\n     * @param {PolymerElementConstructor} klass Element class\n     * @return {PolymerElementProperties} Flattened properties for this class\n     *   that have default values\n     * @private\n     */\n    function propertyDefaultsForClass(klass) {\n      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classPropertyDefaults', klass))) {\n        klass.__classPropertyDefaults = null;\n        var props = propertiesForClass(klass);\n        for (var p in props) {\n          var info = props[p];\n          if ('value' in info) {\n            klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};\n            klass.__classPropertyDefaults[p] = info;\n          }\n        }\n      }\n      return klass.__classPropertyDefaults;\n    }\n\n    /**\n     * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`\n     * @param {PolymerElementConstructor} klass Element class\n     * @return {boolean} True if all metaprogramming for this class has been\n     *   completed\n     * @private\n     */\n    function hasClassFinalized(klass) {\n      return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));\n    }\n\n    /**\n     * Called by `ElementClass.finalize()`. Ensures this `klass` and\n     * *all superclasses* are finalized by traversing the prototype chain\n     * and calling `klass.finalize()`.\n     *\n     * @param {PolymerElementConstructor} klass Element class\n     * @private\n     */\n    function finalizeClassAndSuper(klass) {\n      var proto = /** @type PolymerElementConstructor */klass.prototype;\n      var superCtor = Object.getPrototypeOf(proto).constructor;\n      if (superCtor.prototype instanceof PolymerElement) {\n        superCtor.finalize();\n      }\n      finalizeClass(klass);\n    }\n\n    /**\n     * Configures a `klass` based on a staic `klass.config` object and\n     * a `template`. This includes creating accessors and effects\n     * for properties in `config` and the `template` as well as preparing the\n     * `template` for stamping.\n     *\n     * @param {PolymerElementConstructor} klass Element class\n     * @private\n     */\n    function finalizeClass(klass) {\n      klass.__finalized = true;\n      var proto = /** @type PolymerElementConstructor */klass.prototype;\n      if (klass.hasOwnProperty(JSCompiler_renameProperty('is', klass)) && klass.is) {\n        Polymer.telemetry.register(proto);\n      }\n      var props = ownPropertiesForClass(klass);\n      if (props) {\n        finalizeProperties(proto, props);\n      }\n      var observers = ownObserversForClass(klass);\n      if (observers) {\n        finalizeObservers(proto, observers, props);\n      }\n      // note: create \"working\" template that is finalized at instance time\n      var template = /** @type PolymerElementConstructor */klass.template;\n      if (template) {\n        if (typeof template === 'string') {\n          var t = document.createElement('template');\n          t.innerHTML = template;\n          template = t;\n        } else {\n          template = template.cloneNode(true);\n        }\n        proto._template = template;\n      }\n    }\n\n    /**\n     * Configures a `proto` based on a `properties` object.\n     * Leverages `PropertyEffects` to create property accessors and effects\n     * supporting, observers, reflecting to attributes, change notification,\n     * computed properties, and read only properties.\n     * @param {PolymerElement} proto Element class prototype to add accessors\n     *    and effects to\n     * @param {Object} properties Flattened bag of property descriptors for\n     *    this class\n     * @private\n     */\n    function finalizeProperties(proto, properties) {\n      for (var p in properties) {\n        createPropertyFromConfig(proto, p, properties[p], properties);\n      }\n    }\n\n    /**\n     * Configures a `proto` based on a `observers` array.\n     * Leverages `PropertyEffects` to create observers.\n     * @param {PolymerElement} proto Element class prototype to add accessors\n     *   and effects to\n     * @param {Object} observers Flattened array of observer descriptors for\n     *   this class\n     * @param {Object} dynamicFns Object containing keys for any properties\n     *   that are functions and should trigger the effect when the function\n     *   reference is changed\n     * @private\n     */\n    function finalizeObservers(proto, observers, dynamicFns) {\n      for (var i = 0; i < observers.length; i++) {\n        proto._createMethodObserver(observers[i], dynamicFns);\n      }\n    }\n\n    /**\n     * Creates effects for a property.\n     *\n     * Note, once a property has been set to\n     * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n     * these values may not be changed. For example, a subclass cannot\n     * alter these settings. However, additional `observers` may be added\n     * by subclasses.\n     *\n     * The info object should may contain property metadata as follows:\n     *\n     * * `type`: {function} type to which an attribute matching the property\n     * is deserialized. Note the property is camel-cased from a dash-cased\n     * attribute. For example, 'foo-bar' attribute is dersialized to a\n     * property named 'fooBar'.\n     *\n     * * `readOnly`: {boolean} creates a readOnly property and\n     * makes a private setter for the private of the form '_setFoo' for a\n     * property 'foo',\n     *\n     * * `computed`: {string} creates a computed property. A computed property\n     * also automatically is set to `readOnly: true`. The value is calculated\n     * by running a method and arguments parsed from the given string. For\n     * example 'compute(foo)' will compute a given property when the\n     * 'foo' property changes by executing the 'compute' method. This method\n     * must return the computed value.\n     *\n     * * `reflectToAttriute`: {boolean} If true, the property value is reflected\n     * to an attribute of the same name. Note, the attribute is dash-cased\n     * so a property named 'fooBar' is reflected as 'foo-bar'.\n     *\n     * * `notify`: {boolean} sends a non-bubbling notification event when\n     * the property changes. For example, a property named 'foo' sends an\n     * event named 'foo-changed' with `event.detail` set to the value of\n     * the property.\n     *\n     * * observer: {string} name of a method that runs when the property\n     * changes. The arguments of the method are (value, previousValue).\n     *\n     * Note: Users may want control over modifying property\n     * effects via subclassing. For example, a user might want to make a\n     * reflectToAttribute property not do so in a subclass. We've chosen to\n     * disable this because it leads to additional complication.\n     * For example, a readOnly effect generates a special setter. If a subclass\n     * disables the effect, the setter would fail unexpectedly.\n     * Based on feedback, we may want to try to make effects more malleable\n     * and/or provide an advanced api for manipulating them.\n     * Also consider adding warnings when an effect cannot be changed.\n     *\n     * @param {PolymerElement} proto Element class prototype to add accessors\n     *   and effects to\n     * @param {string} name Name of the property.\n     * @param {Object} info Info object from which to create property effects.\n     * Supported keys:\n     * @param {Object} allProps Flattened map of all properties defined in this\n     *   element (including inherited properties)\n     * @private\n     */\n    function createPropertyFromConfig(proto, name, info, allProps) {\n      // computed forces readOnly...\n      if (info.computed) {\n        info.readOnly = true;\n      }\n      // Note, since all computed properties are readOnly, this prevents\n      // adding additional computed property effects (which leads to a confusing\n      // setup where multiple triggers for setting a property)\n      // While we do have `hasComputedEffect` this is set on the property's\n      // dependencies rather than itself.\n      if (info.computed && !proto._hasReadOnlyEffect(name)) {\n        proto._createComputedProperty(name, info.computed, allProps);\n      }\n      if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n        proto._createReadOnlyProperty(name, !info.computed);\n      }\n      if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n        proto._createReflectedProperty(name);\n      }\n      if (info.notify && !proto._hasNotifyEffect(name)) {\n        proto._createNotifyingProperty(name);\n      }\n      // always add observer\n      if (info.observer) {\n        proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n      }\n    }\n\n    /**\n     * Configures an element `proto` to function with a given `template`.\n     * The element name `is` and extends `ext` must be specified for ShadyCSS\n     * style scoping.\n     *\n     * @param {PolymerElement} proto Element class prototype to add accessors\n     *   and effects to\n     * @param {!HTMLTemplateElement} template Template to process and bind\n     * @param {string} baseURI URL against which to resolve urls in\n     *   style element cssText\n     * @param {string} is Tag name (or type extension name) for this element\n     * @param {string=} ext For type extensions, the tag name that was extended\n     * @private\n     */\n    function finalizeTemplate(proto, template, baseURI, is, ext) {\n      // support `include=\"module-name\"`\n      var cssText = Polymer.StyleGather.cssFromTemplate(template, baseURI) + Polymer.StyleGather.cssFromModuleImports(is);\n      if (cssText) {\n        var style = document.createElement('style');\n        style.textContent = cssText;\n        template.content.insertBefore(style, template.content.firstChild);\n      }\n      if (window.ShadyCSS) {\n        window.ShadyCSS.prepareTemplate(template, is, ext);\n      }\n      proto._bindTemplate(template);\n    }\n\n    /**\n     * @polymer\n     * @mixinClass\n     * @unrestricted\n     * @implements {Polymer_ElementMixin}\n     */\n\n    var PolymerElement = function (_polymerElementBase) {\n      _inherits(PolymerElement, _polymerElementBase);\n\n      function PolymerElement() {\n        _classCallCheck(this, PolymerElement);\n\n        return _possibleConstructorReturn(this, (PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement)).apply(this, arguments));\n      }\n\n      _createClass(PolymerElement, [{\n        key: '_initializeProperties',\n\n\n        /**\n         * Overrides the default `Polymer.PropertyAccessors` to ensure class\n         * metaprogramming related to property accessors and effects has\n         * completed (calls `finalize`).\n         *\n         * It also initializes any property defaults provided via `value` in\n         * `properties` metadata.\n         *\n         * @override\n         * @suppress {invalidCasts}\n         */\n        value: function _initializeProperties() {\n          Polymer.telemetry.instanceCount++;\n          this.constructor.finalize();\n          var importPath = this.constructor.importPath;\n          // note: finalize template when we have access to `localName` to\n          // avoid dependence on `is` for polyfilling styling.\n          if (this._template && !this._template.__polymerFinalized) {\n            this._template.__polymerFinalized = true;\n            var baseURI = importPath ? Polymer.ResolveUrl.resolveUrl(importPath) : '';\n            finalizeTemplate( /** @type {!PolymerElement} */this.__proto__, this._template, baseURI,\n            /**@type {!HTMLElement}*/this.localName);\n          }\n          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_initializeProperties', this).call(this);\n          // set path defaults\n          this.rootPath = Polymer.rootPath;\n          this.importPath = importPath;\n          // apply property defaults...\n          var p$ = propertyDefaultsForClass(this.constructor);\n          if (!p$) {\n            return;\n          }\n          for (var p in p$) {\n            var info = p$[p];\n            // Don't set default value if there is already an own property, which\n            // happens when a `properties` property with default but no effects had\n            // a property set (e.g. bound) by its host before upgrade\n            if (!this.hasOwnProperty(p)) {\n              var value = typeof info.value == 'function' ? info.value.call(this) : info.value;\n              // Set via `_setProperty` if there is an accessor, to enable\n              // initializing readOnly property defaults\n              if (this._hasAccessor(p)) {\n                this._setPendingProperty(p, value, true);\n              } else {\n                this[p] = value;\n              }\n            }\n          }\n        }\n\n        /**\n         * Provides a default implementation of the standard Custom Elements\n         * `connectedCallback`.\n         *\n         * The default implementation enables the property effects system and\n         * flushes any pending properties, and updates shimmed CSS properties\n         * when using the ShadyCSS scoping/custom properties polyfill.\n         *\n         * @suppress {invalidCasts}\n         */\n\n      }, {\n        key: 'connectedCallback',\n        value: function connectedCallback() {\n          if (window.ShadyCSS && this._template) {\n            window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);\n          }\n          this._enableProperties();\n        }\n\n        /**\n         * Provides a default implementation of the standard Custom Elements\n         * `disconnectedCallback`.\n         */\n\n      }, {\n        key: 'disconnectedCallback',\n        value: function disconnectedCallback() {}\n\n        /**\n         * Stamps the element template.\n         *\n         * @override\n         */\n\n      }, {\n        key: 'ready',\n        value: function ready() {\n          if (this._template) {\n            this.root = this._stampTemplate(this._template);\n            this.$ = this.root.$;\n          }\n          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), 'ready', this).call(this);\n        }\n\n        /**\n         * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n         * element dom by calling `_attachDom` with the dom stamped from the\n         * element's template via `_stampTemplate`. Note that this allows\n         * client dom to be attached to the element prior to any observers\n         * running.\n         *\n         * @override\n         */\n\n      }, {\n        key: '_readyClients',\n        value: function _readyClients() {\n          if (this._template) {\n            this.root = this._attachDom(this.root);\n          }\n          // The super._readyClients here sets the clients initialized flag.\n          // We must wait to do this until after client dom is created/attached\n          // so that this flag can be checked to prevent notifications fired\n          // during this process from being handled before clients are ready.\n          _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_readyClients', this).call(this);\n        }\n\n        /**\n         * Attaches an element's stamped dom to itself. By default,\n         * this method creates a `shadowRoot` and adds the dom to it.\n         * However, this method may be overridden to allow an element\n         * to put its dom in another location.\n         *\n         * @throws {Error}\n         * @suppress {missingReturn}\n         * @param {NodeList} dom to attach to the element.\n         * @return {Node} node to which the dom has been attached.\n         */\n\n      }, {\n        key: '_attachDom',\n        value: function _attachDom(dom) {\n          if (this.attachShadow) {\n            if (dom) {\n              if (!this.shadowRoot) {\n                this.attachShadow({ mode: 'open' });\n              }\n              this.shadowRoot.appendChild(dom);\n              return this.shadowRoot;\n            }\n            return null;\n          } else {\n            throw new Error('ShadowDOM not available. ' +\n            // TODO(sorvell): move to compile-time conditional when supported\n            'Polymer.Element can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n          }\n        }\n\n        /**\n         * Provides a default implementation of the standard Custom Elements\n         * `attributeChangedCallback`.\n         *\n         * By default, attributes declared in `properties` metadata are\n         * deserialized using their `type` information to properties of the\n         * same name.  \"Dash-cased\" attributes are deserialzed to \"camelCase\"\n         * properties.\n         *\n         * @param {string} name Name of attribute.\n         * @param {?string} old Old value of attribute.\n         * @param {?string} value Current value of attribute.\n         * @override\n         */\n\n      }, {\n        key: 'attributeChangedCallback',\n        value: function attributeChangedCallback(name, old, value) {\n          if (old !== value) {\n            var property = caseMap.dashToCamelCase(name);\n            var type = propertiesForClass(this.constructor)[property].type;\n            if (!this._hasReadOnlyEffect(property)) {\n              this._attributeToProperty(name, value, type);\n            }\n          }\n        }\n\n        /**\n         * When using the ShadyCSS scoping and custom property shim, causes all\n         * shimmed styles in this element (and its subtree) to be updated\n         * based on current custom property values.\n         *\n         * The optional parameter overrides inline custom property styles with an\n         * object of properties where the keys are CSS properties, and the values\n         * are strings.\n         *\n         * Example: `this.updateStyles({'--color': 'blue'})`\n         *\n         * These properties are retained unless a value of `null` is set.\n         *\n         * @param {Object=} properties Bag of custom property key/values to\n         *   apply to this element.\n         * @suppress {invalidCasts}\n         */\n\n      }, {\n        key: 'updateStyles',\n        value: function updateStyles(properties) {\n          if (window.ShadyCSS) {\n            window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);\n          }\n        }\n\n        /**\n         * Rewrites a given URL relative to a base URL. The base URL defaults to\n         * the original location of the document containing the `dom-module` for\n         * this element. This method will return the same URL before and after\n         * bundling.\n         *\n         * @param {string} url URL to resolve.\n         * @param {string=} base Optional base URL to resolve against, defaults\n         * to the element's `importPath`\n         * @return {string} Rewritten URL relative to base\n         */\n\n      }, {\n        key: 'resolveUrl',\n        value: function resolveUrl(url, base) {\n          if (!base && this.importPath) {\n            base = Polymer.ResolveUrl.resolveUrl(this.importPath);\n          }\n          return Polymer.ResolveUrl.resolveUrl(url, base);\n        }\n\n        /**\n         * Overrides `PropertyAccessors` to add map of dynamic functions on\n         * template info, for consumption by `PropertyEffects` template binding\n         * code. This map determines which method templates should have accessors\n         * created for them.\n         *\n         * @override\n         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n         */\n\n      }], [{\n        key: 'finalize',\n\n\n        /**\n         * Called automatically when the first element instance is created to\n         * ensure that class finalization work has been completed.\n         * May be called by users to eagerly perform class finalization work\n         * prior to the creation of the first element instance.\n         *\n         * Class finalization work generally includes meta-programming such as\n         * creating property accessors and any property effect metadata needed for\n         * the features used.\n         *\n         * @public\n         */\n        value: function finalize() {\n          if (!hasClassFinalized(this)) {\n            finalizeClassAndSuper(this);\n          }\n        }\n\n        /**\n         * Returns the template that will be stamped into this element's shadow root.\n         *\n         * If a `static get is()` getter is defined, the default implementation\n         * will return the first `<template>` in a `dom-module` whose `id`\n         * matches this element's `is`.\n         *\n         * Users may override this getter to return an arbitrary template\n         * (in which case the `is` getter is unnecessary). The template returned\n         * may be either an `HTMLTemplateElement` or a string that will be\n         * automatically parsed into a template.\n         *\n         * Note that when subclassing, if the super class overrode the default\n         * implementation and the subclass would like to provide an alternate\n         * template via a `dom-module`, it should override this getter and\n         * return `Polymer.DomModule.import(this.is, 'template')`.\n         *\n         * If a subclass would like to modify the super class template, it should\n         * clone it rather than modify it in place.  If the getter does expensive\n         * work such as cloning/modifying a template, it should memoize the\n         * template for maximum performance:\n         *\n         *   let memoizedTemplate;\n         *   class MySubClass extends MySuperClass {\n         *     static get template() {\n         *       if (!memoizedTemplate) {\n         *         memoizedTemplate = super.template.cloneNode(true);\n         *         let subContent = document.createElement('div');\n         *         subContent.textContent = 'This came from MySubClass';\n         *         memoizedTemplate.content.appendChild(subContent);\n         *       }\n         *       return memoizedTemplate;\n         *     }\n         *   }\n         *\n         * @return {HTMLTemplateElement|string} Template to be stamped\n         */\n\n      }, {\n        key: '_parseTemplateContent',\n        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {\n          templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);\n          return _get(PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement), '_parseTemplateContent', this).call(this, template, templateInfo, nodeInfo);\n        }\n      }, {\n        key: 'observedAttributes',\n\n\n        /**\n         * Standard Custom Elements V1 API.  The default implementation returns\n         * a list of dash-cased attributes based on a flattening of all properties\n         * declared in `static get properties()` for this element and any\n         * superclasses.\n         *\n         * @return {Array} Observed attribute list\n         */\n        get: function get() {\n          if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {\n            var list = [];\n            var properties = propertiesForClass(this);\n            for (var prop in properties) {\n              list.push(Polymer.CaseMap.camelToDashCase(prop));\n            }\n            this.__observedAttributes = list;\n          }\n          return this.__observedAttributes;\n        }\n      }, {\n        key: 'template',\n        get: function get() {\n          if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n            this._template = Polymer.DomModule && Polymer.DomModule.import(\n            /** @type PolymerElementConstructor*/this.is, 'template') ||\n            // note: implemented so a subclass can retrieve the super\n            // template; call the super impl this way so that `this` points\n            // to the superclass.\n            Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.template;\n          }\n          return this._template;\n        }\n\n        /**\n         * Path matching the url from which the element was imported.\n         * This path is used to resolve url's in template style cssText.\n         * The `importPath` property is also set on element instances and can be\n         * used to create bindings relative to the import path.\n         * Defaults to the path matching the url containing a `dom-module` element\n         * matching this element's static `is` property.\n         * Note, this path should contain a trailing `/`.\n         *\n         * @return {string} The import path for this element class\n         */\n\n      }, {\n        key: 'importPath',\n        get: function get() {\n          if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n            var module = Polymer.DomModule && Polymer.DomModule.import( /** @type PolymerElementConstructor */this.is);\n            this._importPath = module ? module.assetpath : '' || Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.importPath;\n          }\n          return this._importPath;\n        }\n      }]);\n\n      return PolymerElement;\n    }(polymerElementBase);\n\n    return PolymerElement;\n  });\n\n  /**\n   * Provides basic tracking of element definitions (registrations) and\n   * instance counts.\n   *\n   * @namespace\n   * @summary Provides basic tracking of element definitions (registrations) and\n   * instance counts.\n   */\n  Polymer.telemetry = {\n    /**\n     * Total number of Polymer element instances created.\n     * @type {number}\n     */\n    instanceCount: 0,\n    /**\n     * Array of Polymer element classes that have been finalized.\n     * @type {Array<Polymer.Element>}\n     */\n    registrations: [],\n    /**\n     * @param {!PolymerElementConstructor} prototype Element prototype to log\n     * @this {this}\n     * @private\n     */\n    _regLog: function _regLog(prototype) {\n      console.log('[' + prototype.is + ']: registered');\n    },\n    /**\n     * Registers a class prototype for telemetry purposes.\n     * @param {HTMLElement} prototype Element prototype to register\n     * @this {this}\n     * @protected\n     */\n    register: function register(prototype) {\n      this.registrations.push(prototype);\n      Polymer.log && this._regLog(prototype);\n    },\n    /**\n     * Logs all elements registered with an `is` to the console.\n     * @public\n     * @this {this}\n     */\n    dumpRegistrations: function dumpRegistrations() {\n      this.registrations.forEach(this._regLog);\n    }\n  };\n\n  /**\n   * When using the ShadyCSS scoping and custom property shim, causes all\n   * shimmed `styles` (via `custom-style`) in the document (and its subtree)\n   * to be updated based on current custom property values.\n   *\n   * The optional parameter overrides inline custom property styles with an\n   * object of properties where the keys are CSS properties, and the values\n   * are strings.\n   *\n   * Example: `Polymer.updateStyles({'--color': 'blue'})`\n   *\n   * These properties are retained unless a value of `null` is set.\n   *\n   * @param {Object=} props Bag of custom property key/values to\n   *   apply to the document.\n   */\n  Polymer.updateStyles = function (props) {\n    if (window.ShadyCSS) {\n      window.ShadyCSS.styleDocument(props);\n    }\n  };\n})();\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(0);\n\n__webpack_require__(2);\n\n/** @suppress {deprecated} */\n(function () {\n  'use strict';\n\n  /**\n   * Legacy settings.\n   * @namespace\n   * @memberof Polymer\n   */\n\n  var settings = Polymer.Settings || {};\n  settings.useShadow = !window.ShadyDOM;\n  settings.useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);\n  settings.useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;\n\n  /**\n   * Sets the global, legacy settings.\n   *\n   * @deprecated\n   * @memberof Polymer\n   */\n  Polymer.Settings = settings;\n\n  /**\n   * Globally settable property that is automatically assigned to\n   * `Polymer.ElementMixin` instances, useful for binding in templates to\n   * make URL's relative to an application's root.  Defaults to the main\n   * document URL, but can be overridden by users.  It may be useful to set\n   * `Polymer.rootPath` to provide a stable application mount path when\n   * using client side routing.\n   *\n   * @memberof Polymer\n   */\n  var rootPath = Polymer.rootPath || Polymer.ResolveUrl.pathFromUrl(document.baseURI || window.location.href);\n\n  Polymer.rootPath = rootPath;\n\n  /**\n   * Sets the global rootPath property used by `Polymer.ElementMixin` and\n   * available via `Polymer.rootPath`.\n   *\n   * @memberof Polymer\n   * @param {string} path The new root path\n   */\n  Polymer.setRootPath = function (path) {\n    Polymer.rootPath = path;\n  };\n})();\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(2);\n\n(function () {\n  'use strict';\n\n  var MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';\n  var INCLUDE_ATTR = 'include';\n\n  function importModule(moduleId) {\n    if (!Polymer.DomModule) {\n      return null;\n    }\n    return Polymer.DomModule.import(moduleId);\n  }\n\n  /** @typedef {{assetpath: string}} */\n  var templateWithAssetPath = void 0; // eslint-disable-line no-unused-vars\n\n  /**\n   * Module with utilities for collection CSS text from `<templates>`, external\n   * stylesheets, and `dom-module`s.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module with utilities for collection CSS text from various sources.\n   */\n  var StyleGather = {\n\n    /**\n     * Returns CSS text of styles in a space-separated list of `dom-module`s.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {string} moduleIds List of dom-module id's within which to\n     * search for css.\n     * @return {string} Concatenated CSS content from specified `dom-module`s\n     * @this {StyleGather}\n     */\n    cssFromModules: function cssFromModules(moduleIds) {\n      var modules = moduleIds.trim().split(' ');\n      var cssText = '';\n      for (var i = 0; i < modules.length; i++) {\n        cssText += this.cssFromModule(modules[i]);\n      }\n      return cssText;\n    },\n\n\n    /**\n     * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`\n     * can come either from `<style>`s within the first `<template>`, or else\n     * from one or more `<link rel=\"import\" type=\"css\">` links outside the\n     * template.\n     *\n     * Any `<styles>` processed are removed from their original location.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {string} moduleId dom-module id to gather styles from\n     * @return {string} Concatenated CSS content from specified `dom-module`\n     * @this {StyleGather}\n     */\n    cssFromModule: function cssFromModule(moduleId) {\n      var m = importModule(moduleId);\n      if (m && m._cssText === undefined) {\n        var cssText = '';\n        // include css from the first template in the module\n        var t = m.querySelector('template');\n        if (t) {\n          cssText += this.cssFromTemplate(t, /** @type {templateWithAssetPath }*/m.assetpath);\n        }\n        // module imports: <link rel=\"import\" type=\"css\">\n        cssText += this.cssFromModuleImports(moduleId);\n        m._cssText = cssText || null;\n      }\n      if (!m) {\n        console.warn('Could not find style data in module named', moduleId);\n      }\n      return m && m._cssText || '';\n    },\n\n\n    /**\n     * Returns CSS text of `<styles>` within a given template.\n     *\n     * Any `<styles>` processed are removed from their original location.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {HTMLTemplateElement} template Template to gather styles from\n     * @param {string} baseURI Base URI to resolve the URL against\n     * @return {string} Concatenated CSS content from specified template\n     * @this {StyleGather}\n     */\n    cssFromTemplate: function cssFromTemplate(template, baseURI) {\n      var cssText = '';\n      // if element is a template, get content from its .content\n      var e$ = template.content.querySelectorAll('style');\n      for (var i = 0; i < e$.length; i++) {\n        var e = e$[i];\n        // support style sharing by allowing styles to \"include\"\n        // other dom-modules that contain styling\n        var include = e.getAttribute(INCLUDE_ATTR);\n        if (include) {\n          cssText += this.cssFromModules(include);\n        }\n        e.parentNode.removeChild(e);\n        cssText += baseURI ? Polymer.ResolveUrl.resolveCss(e.textContent, baseURI) : e.textContent;\n      }\n      return cssText;\n    },\n\n\n    /**\n     * Returns CSS text from stylsheets loaded via `<link rel=\"import\" type=\"css\">`\n     * links within the specified `dom-module`.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {string} moduleId Id of `dom-module` to gather CSS from\n     * @return {string} Concatenated CSS content from links in specified `dom-module`\n     * @this {StyleGather}\n     */\n    cssFromModuleImports: function cssFromModuleImports(moduleId) {\n      var cssText = '';\n      var m = importModule(moduleId);\n      if (!m) {\n        return cssText;\n      }\n      var p$ = m.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);\n      for (var i = 0; i < p$.length; i++) {\n        var p = p$[i];\n        if (p.import) {\n          var importDoc = p.import;\n          // NOTE: polyfill affordance.\n          // under the HTMLImports polyfill, there will be no 'body',\n          // but the import pseudo-doc can be used directly.\n          var container = importDoc.body ? importDoc.body : importDoc;\n          cssText += Polymer.ResolveUrl.resolveCss(container.textContent, importDoc.baseURI);\n        }\n      }\n      return cssText;\n    }\n  };\n\n  Polymer.StyleGather = StyleGather;\n})();\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n__webpack_require__(0);\n\n__webpack_require__(11);\n\n__webpack_require__(4);\n\n(function () {\n  'use strict';\n\n  /**\n   * Returns true if `node` is a slot element\n   * @param {HTMLElement} node Node to test.\n   * @return {boolean} Returns true if the given `node` is a slot\n   * @private\n   */\n\n  function isSlot(node) {\n    return node.localName === 'slot';\n  }\n\n  /**\n   * Class that listens for changes (additions or removals) to\n   * \"flattened nodes\" on a given `node`. The list of flattened nodes consists\n   * of a node's children and, for any children that are `<slot>` elements,\n   * the expanded flattened list of `assignedNodes`.\n   * For example, if the observed node has children `<a></a><slot></slot><b></b>`\n   * and the `<slot>` has one `<div>` assigned to it, then the flattened\n   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other\n   * `<slot>` elements assigned to it, these are flattened as well.\n   *\n   * The provided `callback` is called whenever any change to this list\n   * of flattened nodes occurs, where an addition or removal of a node is\n   * considered a change. The `callback` is called with one argument, an object\n   * containing an array of any `addedNodes` and `removedNodes`.\n   *\n   * Note: the callback is called asynchronous to any changes\n   * at a microtask checkpoint. This is because observation is performed using\n   * `MutationObserver` and the `<slot>` element's `slotchange` event which\n   * are asynchronous.\n   *\n   * @memberof Polymer\n   * @summary Class that listens for changes (additions or removals) to\n   * \"flattened nodes\" on a given `node`.\n   */\n\n  var FlattenedNodesObserver = function () {\n    _createClass(FlattenedNodesObserver, null, [{\n      key: 'getFlattenedNodes',\n\n\n      /**\n       * Returns the list of flattened nodes for the given `node`.\n       * This list consists of a node's children and, for any children\n       * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.\n       * For example, if the observed node has children `<a></a><slot></slot><b></b>`\n       * and the `<slot>` has one `<div>` assigned to it, then the flattened\n       * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other\n       * `<slot>` elements assigned to it, these are flattened as well.\n       *\n       * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.\n       * @return {Array} The list of flattened nodes for the given `node`.\n      */\n      value: function getFlattenedNodes(node) {\n        if (isSlot(node)) {\n          return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })\n          );\n        } else {\n          return Array.from(node.childNodes).map(function (node) {\n            if (isSlot(node)) {\n              return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })\n              );\n            } else {\n              return [node];\n            }\n          }).reduce(function (a, b) {\n            return a.concat(b);\n          }, []);\n        }\n      }\n\n      /**\n       * @param {Node} target Node on which to listen for changes.\n       * @param {Function} callback Function called when there are additions\n       * or removals from the target's list of flattened nodes.\n      */\n\n    }]);\n\n    function FlattenedNodesObserver(target, callback) {\n      var _this = this;\n\n      _classCallCheck(this, FlattenedNodesObserver);\n\n      /** @type {MutationObserver} */\n      this._shadyChildrenObserver = null;\n      /** @type {MutationObserver} */\n      this._nativeChildrenObserver = null;\n      this._connected = false;\n      this._target = target;\n      this.callback = callback;\n      this._effectiveNodes = [];\n      this._observer = null;\n      this._scheduled = false;\n      /** @type {function()} */\n      this._boundSchedule = function () {\n        _this._schedule();\n      };\n      this.connect();\n      this._schedule();\n    }\n\n    /**\n     * Activates an observer. This method is automatically called when\n     * a `FlattenedNodesObserver` is created. It should only be called to\n     * re-activate an observer that has been deactivated via the `disconnect` method.\n     */\n\n\n    _createClass(FlattenedNodesObserver, [{\n      key: 'connect',\n      value: function connect() {\n        var _this2 = this;\n\n        if (isSlot(this._target)) {\n          this._listenSlots([this._target]);\n        } else {\n          this._listenSlots(this._target.children);\n          if (window.ShadyDOM) {\n            this._shadyChildrenObserver = ShadyDOM.observeChildren(this._target, function (mutations) {\n              _this2._processMutations(mutations);\n            });\n          } else {\n            this._nativeChildrenObserver = new MutationObserver(function (mutations) {\n              _this2._processMutations(mutations);\n            });\n            this._nativeChildrenObserver.observe(this._target, { childList: true });\n          }\n        }\n        this._connected = true;\n      }\n\n      /**\n       * Deactivates the flattened nodes observer. After calling this method\n       * the observer callback will not be called when changes to flattened nodes\n       * occur. The `connect` method may be subsequently called to reactivate\n       * the observer.\n       */\n\n    }, {\n      key: 'disconnect',\n      value: function disconnect() {\n        if (isSlot(this._target)) {\n          this._unlistenSlots([this._target]);\n        } else {\n          this._unlistenSlots(this._target.children);\n          if (window.ShadyDOM && this._shadyChildrenObserver) {\n            ShadyDOM.unobserveChildren(this._shadyChildrenObserver);\n            this._shadyChildrenObserver = null;\n          } else if (this._nativeChildrenObserver) {\n            this._nativeChildrenObserver.disconnect();\n            this._nativeChildrenObserver = null;\n          }\n        }\n        this._connected = false;\n      }\n    }, {\n      key: '_schedule',\n      value: function _schedule() {\n        var _this3 = this;\n\n        if (!this._scheduled) {\n          this._scheduled = true;\n          Polymer.Async.microTask.run(function () {\n            return _this3.flush();\n          });\n        }\n      }\n    }, {\n      key: '_processMutations',\n      value: function _processMutations(mutations) {\n        this._processSlotMutations(mutations);\n        this.flush();\n      }\n    }, {\n      key: '_processSlotMutations',\n      value: function _processSlotMutations(mutations) {\n        if (mutations) {\n          for (var i = 0; i < mutations.length; i++) {\n            var mutation = mutations[i];\n            if (mutation.addedNodes) {\n              this._listenSlots(mutation.addedNodes);\n            }\n            if (mutation.removedNodes) {\n              this._unlistenSlots(mutation.removedNodes);\n            }\n          }\n        }\n      }\n\n      /**\n       * Flushes the observer causing any pending changes to be immediately\n       * delivered the observer callback. By default these changes are delivered\n       * asynchronously at the next microtask checkpoint.\n       *\n       * @return {boolean} Returns true if any pending changes caused the observer\n       * callback to run.\n       */\n\n    }, {\n      key: 'flush',\n      value: function flush() {\n        if (!this._connected) {\n          return false;\n        }\n        if (window.ShadyDOM) {\n          ShadyDOM.flush();\n        }\n        if (this._nativeChildrenObserver) {\n          this._processSlotMutations(this._nativeChildrenObserver.takeRecords());\n        } else if (this._shadyChildrenObserver) {\n          this._processSlotMutations(this._shadyChildrenObserver.takeRecords());\n        }\n        this._scheduled = false;\n        var info = {\n          target: this._target,\n          addedNodes: [],\n          removedNodes: []\n        };\n        var newNodes = this.constructor.getFlattenedNodes(this._target);\n        var splices = Polymer.ArraySplice.calculateSplices(newNodes, this._effectiveNodes);\n        // process removals\n        for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {\n          for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\n            info.removedNodes.push(n);\n          }\n        }\n        // process adds\n        for (var _i = 0, _s; _i < splices.length && (_s = splices[_i]); _i++) {\n          for (var _j = _s.index; _j < _s.index + _s.addedCount; _j++) {\n            info.addedNodes.push(newNodes[_j]);\n          }\n        }\n        // update cache\n        this._effectiveNodes = newNodes;\n        var didFlush = false;\n        if (info.addedNodes.length || info.removedNodes.length) {\n          didFlush = true;\n          this.callback.call(this._target, info);\n        }\n        return didFlush;\n      }\n    }, {\n      key: '_listenSlots',\n      value: function _listenSlots(nodeList) {\n        for (var i = 0; i < nodeList.length; i++) {\n          var n = nodeList[i];\n          if (isSlot(n)) {\n            n.addEventListener('slotchange', this._boundSchedule);\n          }\n        }\n      }\n    }, {\n      key: '_unlistenSlots',\n      value: function _unlistenSlots(nodeList) {\n        for (var i = 0; i < nodeList.length; i++) {\n          var n = nodeList[i];\n          if (isSlot(n)) {\n            n.removeEventListener('slotchange', this._boundSchedule);\n          }\n        }\n      }\n    }]);\n\n    return FlattenedNodesObserver;\n  }();\n\n  Polymer.FlattenedNodesObserver = FlattenedNodesObserver;\n})();\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(0);\n\n(function () {\n\n  'use strict';\n\n  function newSplice(index, removed, addedCount) {\n    return {\n      index: index,\n      removed: removed,\n      addedCount: addedCount\n    };\n  }\n\n  var EDIT_LEAVE = 0;\n  var EDIT_UPDATE = 1;\n  var EDIT_ADD = 2;\n  var EDIT_DELETE = 3;\n\n  // Note: This function is *based* on the computation of the Levenshtein\n  // \"edit\" distance. The one change is that \"updates\" are treated as two\n  // edits - not one. With Array splices, an update is really a delete\n  // followed by an add. By retaining this, we optimize for \"keeping\" the\n  // maximum array items in the original array. For example:\n  //\n  //   'xxxx123' -> '123yyyy'\n  //\n  // With 1-edit updates, the shortest path would be just to update all seven\n  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n  // leaves the substring '123' intact.\n  function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n    // \"Deletion\" columns\n    var rowCount = oldEnd - oldStart + 1;\n    var columnCount = currentEnd - currentStart + 1;\n    var distances = new Array(rowCount);\n\n    // \"Addition\" rows. Initialize null column.\n    for (var i = 0; i < rowCount; i++) {\n      distances[i] = new Array(columnCount);\n      distances[i][0] = i;\n    }\n\n    // Initialize null row\n    for (var j = 0; j < columnCount; j++) {\n      distances[0][j] = j;\n    }for (var _i = 1; _i < rowCount; _i++) {\n      for (var _j = 1; _j < columnCount; _j++) {\n        if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {\n          var north = distances[_i - 1][_j] + 1;\n          var west = distances[_i][_j - 1] + 1;\n          distances[_i][_j] = north < west ? north : west;\n        }\n      }\n    }\n\n    return distances;\n  }\n\n  // This starts at the final weight, and walks \"backward\" by finding\n  // the minimum previous weight recursively until the origin of the weight\n  // matrix.\n  function spliceOperationsFromEditDistances(distances) {\n    var i = distances.length - 1;\n    var j = distances[0].length - 1;\n    var current = distances[i][j];\n    var edits = [];\n    while (i > 0 || j > 0) {\n      if (i == 0) {\n        edits.push(EDIT_ADD);\n        j--;\n        continue;\n      }\n      if (j == 0) {\n        edits.push(EDIT_DELETE);\n        i--;\n        continue;\n      }\n      var northWest = distances[i - 1][j - 1];\n      var west = distances[i - 1][j];\n      var north = distances[i][j - 1];\n\n      var min = void 0;\n      if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;\n\n      if (min == northWest) {\n        if (northWest == current) {\n          edits.push(EDIT_LEAVE);\n        } else {\n          edits.push(EDIT_UPDATE);\n          current = northWest;\n        }\n        i--;\n        j--;\n      } else if (min == west) {\n        edits.push(EDIT_DELETE);\n        i--;\n        current = west;\n      } else {\n        edits.push(EDIT_ADD);\n        j--;\n        current = north;\n      }\n    }\n\n    edits.reverse();\n    return edits;\n  }\n\n  /**\n   * Splice Projection functions:\n   *\n   * A splice map is a representation of how a previous array of items\n   * was transformed into a new array of items. Conceptually it is a list of\n   * tuples of\n   *\n   *   <index, removed, addedCount>\n   *\n   * which are kept in ascending index order of. The tuple represents that at\n   * the |index|, |removed| sequence of items were removed, and counting forward\n   * from |index|, |addedCount| items were added.\n   */\n\n  /**\n   * Lacking individual splice mutation information, the minimal set of\n   * splices can be synthesized given the previous state and final state of an\n   * array. The basic approach is to calculate the edit distance matrix and\n   * choose the shortest path through it.\n   *\n   * Complexity: O(l * p)\n   *   l: The length of the current array\n   *   p: The length of the old array\n   *\n   * @param {Array} current The current \"changed\" array for which to\n   * calculate splices.\n   * @param {number} currentStart Starting index in the `current` array for\n   * which splices are calculated.\n   * @param {number} currentEnd Ending index in the `current` array for\n   * which splices are calculated.\n   * @param {Array} old The original \"unchanged\" array to compare `current`\n   * against to determine splices.\n   * @param {number} oldStart Starting index in the `old` array for\n   * which splices are calculated.\n   * @param {number} oldEnd Ending index in the `old` array for\n   * which splices are calculated.\n   * @return {Array} Returns an array of splice record objects. Each of these\n   * contains: `index` the location where the splice occurred; `removed`\n   * the array of removed items from this location; `addedCount` the number\n   * of items added at this location.\n   */\n  function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n    var prefixCount = 0;\n    var suffixCount = 0;\n    var splice = void 0;\n\n    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n    if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);\n\n    if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n\n    currentStart += prefixCount;\n    oldStart += prefixCount;\n    currentEnd -= suffixCount;\n    oldEnd -= suffixCount;\n\n    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];\n\n    if (currentStart == currentEnd) {\n      splice = newSplice(currentStart, [], 0);\n      while (oldStart < oldEnd) {\n        splice.removed.push(old[oldStart++]);\n      }return [splice];\n    } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];\n\n    var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n\n    splice = undefined;\n    var splices = [];\n    var index = currentStart;\n    var oldIndex = oldStart;\n    for (var i = 0; i < ops.length; i++) {\n      switch (ops[i]) {\n        case EDIT_LEAVE:\n          if (splice) {\n            splices.push(splice);\n            splice = undefined;\n          }\n\n          index++;\n          oldIndex++;\n          break;\n        case EDIT_UPDATE:\n          if (!splice) splice = newSplice(index, [], 0);\n\n          splice.addedCount++;\n          index++;\n\n          splice.removed.push(old[oldIndex]);\n          oldIndex++;\n          break;\n        case EDIT_ADD:\n          if (!splice) splice = newSplice(index, [], 0);\n\n          splice.addedCount++;\n          index++;\n          break;\n        case EDIT_DELETE:\n          if (!splice) splice = newSplice(index, [], 0);\n\n          splice.removed.push(old[oldIndex]);\n          oldIndex++;\n          break;\n      }\n    }\n\n    if (splice) {\n      splices.push(splice);\n    }\n    return splices;\n  }\n\n  function sharedPrefix(current, old, searchLength) {\n    for (var i = 0; i < searchLength; i++) {\n      if (!equals(current[i], old[i])) return i;\n    }return searchLength;\n  }\n\n  function sharedSuffix(current, old, searchLength) {\n    var index1 = current.length;\n    var index2 = old.length;\n    var count = 0;\n    while (count < searchLength && equals(current[--index1], old[--index2])) {\n      count++;\n    }return count;\n  }\n\n  function calculateSplices(current, previous) {\n    return calcSplices(current, 0, current.length, previous, 0, previous.length);\n  }\n\n  function equals(currentValue, previousValue) {\n    return currentValue === previousValue;\n  }\n\n  /**\n   * @namespace\n   * @memberof Polymer\n   * @summary Module that provides utilities for diffing arrays.\n   */\n  Polymer.ArraySplice = {\n    /**\n     * Returns an array of splice records indicating the minimum edits required\n     * to transform the `previous` array into the `current` array.\n     *\n     * Splice records are ordered by index and contain the following fields:\n     * - `index`: index where edit started\n     * - `removed`: array of removed items from this index\n     * - `addedCount`: number of items added at this index\n     *\n     * This function is based on the Levenshtein \"minimum edit distance\"\n     * algorithm. Note that updates are treated as removal followed by addition.\n     *\n     * The worst-case time complexity of this algorithm is `O(l * p)`\n     *   l: The length of the current array\n     *   p: The length of the previous array\n     *\n     * However, the worst-case complexity is reduced by an `O(n)` optimization\n     * to detect any shared prefix & suffix between the two arrays and only\n     * perform the more expensive minimum edit distance calculation over the\n     * non-shared portions of the arrays.\n     *\n     * @memberof Polymer.ArraySplice\n     * @param {Array} current The \"changed\" array for which splices will be\n     * calculated.\n     * @param {Array} previous The \"unchanged\" original array to compare\n     * `current` against to determine the splices.\n     * @return {Array} Returns an array of splice record objects. Each of these\n     * contains: `index` the location where the splice occurred; `removed`\n     * the array of removed items from this location; `addedCount` the number\n     * of items added at this location.\n     */\n    calculateSplices: calculateSplices\n  };\n})();\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(5);\n\n__webpack_require__(10);\n\nvar _locationMixin = __webpack_require__(17);\n\nvar _locationMixin2 = _interopRequireDefault(_locationMixin);\n\nvar _queryParamsMixin = __webpack_require__(19);\n\nvar _queryParamsMixin2 = _interopRequireDefault(_queryParamsMixin);\n\nvar _pathToRegexp = __webpack_require__(20);\n\nvar _pathToRegexp2 = _interopRequireDefault(_pathToRegexp);\n\nvar _routing = __webpack_require__(22);\n\nvar _routing2 = _interopRequireDefault(_routing);\n\nvar _httpCodes = __webpack_require__(23);\n\nvar _httpCodes2 = _interopRequireDefault(_httpCodes);\n\nvar _partials = __webpack_require__(24);\n\nvar _partials2 = _interopRequireDefault(_partials);\n\nvar _index = __webpack_require__(25);\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar messages = [];\n\nvar AppShell = function (_QueryParamsMixin) {\n  _inherits(AppShell, _QueryParamsMixin);\n\n  _createClass(AppShell, null, [{\n    key: 'is',\n    get: function get() {\n      return 'app-shell';\n    }\n  }, {\n    key: 'properties',\n    get: function get() {\n      return {\n        params: {\n          type: Object\n        },\n\n        queryParams: {\n          type: Object\n        },\n\n        currentRoute: {\n          type: String\n        },\n\n        // location-mixin\n        path: {\n          type: String\n        },\n\n        query: {\n          type: String,\n          observer: '_queryChanged'\n        },\n\n        urlSpaceRegex: {\n          type: String\n        },\n\n        hash: {\n          type: String\n        },\n\n        dwellTime: {\n          type: Number\n        },\n\n        _urlSpaceRegExp: {\n          type: String,\n          computed: '_makeRegExp(urlSpaceRegex)'\n        },\n\n        _lastChangedAt: {\n          type: String\n        },\n\n        _initialized: {\n          type: Boolean\n        },\n\n        // query params 'paramsString', 'paramsObject', '_dontReact'\n\n        paramsString: {\n          type: String,\n          observer: '_paramsStringChanged'\n        },\n\n        paramsObject: {\n          type: Object\n        },\n\n        _dontReact: {\n          type: Boolean\n        }\n      };\n    }\n  }, {\n    key: 'observers',\n    get: function get() {\n      return ['_pathChanged(path)', '_updateUrl(path, query, hash)'];\n    }\n  }, {\n    key: 'template',\n    get: function get() {\n      return '\\n      <style is=\"custom-style\">\\n        div[role=\\'main\\'] {\\n          position: relative;\\n        }\\n\\n        ::slotted(.page) {\\n          position: absolute;\\n          background-color: white;\\n          width: 100%;\\n          top: 0;\\n          opacity: 0;\\n          z-index: -1;\\n          transition: opacity 0.3s;\\n          display: none;\\n        }\\n\\n        ::slotted(*) > .page {\\n          position: absolute;\\n          background-color: white;\\n          width: 100%;\\n          top: 0;\\n          opacity: 0;\\n          z-index: -1;\\n          transition: opacity 0.3s;\\n          display: none;\\n        }\\n\\n        ::slotted(.page--on-view) {\\n          position: relative !important;\\n          opacity: 1;\\n          z-index: 0;\\n          display: block;\\n        }\\n\\n        ::slotted(*) > .page--on-view {\\n          position: relative !important;\\n          opacity: 1;\\n          z-index: 0;\\n          display: block;\\n        }\\n      </style>\\n\\n      <div class=\"main\">\\n        <slot></slot>\\n      </div>\\n\\n      <app-toast></app-toast>\\n    ';\n    }\n  }]);\n\n  function AppShell() {\n    _classCallCheck(this, AppShell);\n\n    var _this = _possibleConstructorReturn(this, (AppShell.__proto__ || Object.getPrototypeOf(AppShell)).call(this));\n\n    _this._routes = {};\n    return _this;\n  }\n\n  _createClass(AppShell, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this2 = this;\n\n      _get(AppShell.prototype.__proto__ || Object.getPrototypeOf(AppShell.prototype), 'connectedCallback', this).call(this);\n      this._observer = new Polymer.FlattenedNodesObserver(this, function (info) {\n        _this2._contentAdded(info.addedNodes.filter(function (node) {\n          return node.nodeType === window.Node.ELEMENT_NODE;\n        }));\n      });\n      __webpack_require__.e/* import() */(1).then(__webpack_require__.bind(null, 31)).then(function () {\n        var messageInterval = setInterval(function () {\n          if (messages.length > 0) {\n            var _messages$pop = messages.pop(),\n                message = _messages$pop.message,\n                optTapHandler = _messages$pop.optTapHandler,\n                optAction = _messages$pop.optAction,\n                optActionHandler = _messages$pop.optActionHandler,\n                optDuration = _messages$pop.optDuration;\n\n            _this2.showMessage(message, optTapHandler, optAction, optActionHandler, optDuration);\n          } else {\n            clearInterval(messageInterval);\n            messageInterval = null;\n          }\n        }, 5000);\n      });\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      if (_get(AppShell.prototype.__proto__ || Object.getPrototypeOf(AppShell.prototype), 'disconnectedCallback', this)) {\n        _get(AppShell.prototype.__proto__ || Object.getPrototypeOf(AppShell.prototype), 'disconnectedCallback', this).call(this);\n      }\n      if (this._observer) this._observer.disconnect();\n    }\n  }, {\n    key: 'showMessage',\n    value: function showMessage(message, optTapHandler, optAction, optActionHandler, optDuration) {\n      if (this.shadowRoot.querySelector('app-toast').showMessage) {\n        this.shadowRoot.querySelector('app-toast').showMessage(message, optTapHandler, optAction, optActionHandler, optDuration);\n      } else {\n        messages.push({ message: message, optTapHandler: optTapHandler, optAction: optAction, optActionHandler: optActionHandler, optDuration: optDuration });\n      }\n    }\n  }, {\n    key: 'closeToast',\n    value: function closeToast() {\n      this.shadowRoot.querySelector('app-toast').close();\n    }\n  }, {\n    key: '_contentAdded',\n    value: function _contentAdded(pages) {\n      var _this3 = this;\n\n      pages.forEach(function (page) {\n        page.classList.add('page');\n        _this3._routes[page.getAttribute('route')] = {\n          element: page,\n          auth: page.getAttribute('auth')\n        };\n      });\n      this._pathChanged(this.path);\n    }\n  }, {\n    key: '_pathChanged',\n    value: function _pathChanged(path) {\n      var _this4 = this;\n\n      // load statistics if it went through here\n      if (path === '/_statistic.html' || path === '/_bundle-sizes.html') {\n        window.location.href = path;\n        return;\n      }\n\n      path = path.replace(/index\\.html$/, '');\n\n      var routeName = null;\n      Object.entries(this._routes).forEach(function (route) {\n        if (routeName) return;\n        var params = {};\n        var keys = [];\n        var re = (0, _pathToRegexp2.default)(route[0], keys);\n        var exec = re.exec(path);\n\n        if (exec) {\n          params = {};\n          for (var j = 0; j < keys.length; j++) {\n            params[keys[j].name] = exec[j + 1];\n          }\n          routeName = route[0];\n          _this4.params = params;\n        }\n      });\n\n      this._checkAuth(routeName || 'not-found');\n    }\n  }, {\n    key: '_checkAuth',\n    value: function _checkAuth(route) {\n      var _this5 = this;\n\n      if (this._routes[route] && this._routes[route].auth && _index2.default[this._routes[route].auth]) {\n        if (_index2.default[this._routes[route].auth] instanceof Promise) {\n          _index2.default[this._routes[route].auth]().then(function (res) {\n            if (res) {\n              _this5._loadPage(route);\n            } else {\n              _this5._loadPage('not-authorized');\n            }\n          }).catch(function (e) {\n            console.log(e);\n            _this5._loadPage('not-authorized');\n          });\n        } else if (typeof _index2.default[this._routes[route].auth] === 'function' && _index2.default[this._routes[route].auth](this)) {\n          this._loadPage(route);\n        } else {\n          this._loadPage('not-authorized');\n        }\n      } else {\n        this._loadPage(route);\n      }\n    }\n  }, {\n    key: '_loadPage',\n    value: function _loadPage(route) {\n      var _this6 = this;\n\n      var routes = Object.assign({}, _routing2.default, _httpCodes2.default);\n      for (var i in this._routes) {\n        if (this._routes[i] && this._routes[i].element) this._routes[i].element.classList.remove('page--on-view');\n      }\n\n      if (this._routes[route] && this._routes[route].element) {\n        this._routes[route].element.classList.add('page--on-view');\n      }\n      if (this._routes[route]) {\n        routes[route]().then(function () {\n          _this6._routes[route].element._setProperty('params', _this6.params);\n          _this6._routes[route].element._setProperty('queryParams', _this6.paramsObject);\n          if (window.ga) {\n            ga('set', 'page', _this6.path);\n            ga('send', 'pageview');\n          }\n        });\n      }\n    }\n  }]);\n\n  return AppShell;\n}((0, _queryParamsMixin2.default)((0, _locationMixin2.default)(Polymer.Element)));\n\nwindow.customElements.define(AppShell.is, AppShell);\n\n// load partials here\nfor (var p in _partials2.default) {\n  _partials2.default[p]();\n}\n\nexports.default = AppShell;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n__webpack_require__(0);\n\n__webpack_require__(2);\n\n(function () {\n  'use strict';\n\n  var modules = {};\n  var lcModules = {};\n  function findModule(id) {\n    return modules[id] || lcModules[id.toLowerCase()];\n  }\n\n  function styleOutsideTemplateCheck(inst) {\n    if (inst.querySelector('style')) {\n      console.warn('dom-module %s has style outside template', inst.id);\n    }\n  }\n\n  /**\n   * The `dom-module` element registers the dom it contains to the name given\n   * by the module's id attribute. It provides a unified database of dom\n   * accessible via its static `import` API.\n   *\n   * A key use case of `dom-module` is for providing custom element `<template>`s\n   * via HTML imports that are parsed by the native HTML parser, that can be\n   * relocated during a bundling pass and still looked up by `id`.\n   *\n   * Example:\n   *\n   *     <dom-module id=\"foo\">\n   *       <img src=\"stuff.png\">\n   *     </dom-module>\n   *\n   * Then in code in some other location that cannot access the dom-module above\n   *\n   *     let img = document.createElement('dom-module').import('foo', 'img');\n   *\n   * @customElement\n   * @extends HTMLElement\n   * @memberof Polymer\n   * @summary Custom element that provides a registry of relocatable DOM content\n   *   by `id` that is agnostic to bundling.\n   * @unrestricted\n   */\n\n  var DomModule = function (_HTMLElement) {\n    _inherits(DomModule, _HTMLElement);\n\n    function DomModule() {\n      _classCallCheck(this, DomModule);\n\n      return _possibleConstructorReturn(this, (DomModule.__proto__ || Object.getPrototypeOf(DomModule)).apply(this, arguments));\n    }\n\n    _createClass(DomModule, [{\n      key: 'attributeChangedCallback',\n      value: function attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n          this.register();\n        }\n      }\n\n      /**\n       * The absolute URL of the original location of this `dom-module`.\n       *\n       * This value will differ from this element's `ownerDocument` in the\n       * following ways:\n       * - Takes into account any `assetpath` attribute added during bundling\n       *   to indicate the original location relative to the bundled location\n       * - Uses the HTMLImports polyfill's `importForElement` API to ensure\n       *   the path is relative to the import document's location since\n       *   `ownerDocument` is not currently polyfilled\n       */\n\n    }, {\n      key: 'register',\n\n\n      /**\n       * Registers the dom-module at a given id. This method should only be called\n       * when a dom-module is imperatively created. For\n       * example, `document.createElement('dom-module').register('foo')`.\n       * @param {string=} id The id at which to register the dom-module.\n       */\n      value: function register(id) {\n        id = id || this.id;\n        if (id) {\n          this.id = id;\n          // store id separate from lowercased id so that\n          // in all cases mixedCase id will stored distinctly\n          // and lowercase version is a fallback\n          modules[id] = this;\n          lcModules[id.toLowerCase()] = this;\n          styleOutsideTemplateCheck(this);\n        }\n      }\n    }, {\n      key: 'assetpath',\n      get: function get() {\n        // Don't override existing assetpath.\n        if (!this.__assetpath) {\n          // note: assetpath set via an attribute must be relative to this\n          // element's location; accomodate polyfilled HTMLImports\n          var owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;\n          var url = Polymer.ResolveUrl.resolveUrl(this.getAttribute('assetpath') || '', owner.baseURI);\n          this.__assetpath = Polymer.ResolveUrl.pathFromUrl(url);\n        }\n        return this.__assetpath;\n      }\n    }], [{\n      key: 'import',\n\n\n      /**\n       * Retrieves the element specified by the css `selector` in the module\n       * registered by `id`. For example, this.import('foo', 'img');\n       * @param {string} id The id of the dom-module in which to search.\n       * @param {string=} selector The css selector by which to find the element.\n       * @return {Element} Returns the element which matches `selector` in the\n       * module registered at the specified `id`.\n       */\n      value: function _import(id, selector) {\n        if (id) {\n          var m = findModule(id);\n          if (m && selector) {\n            return m.querySelector(selector);\n          }\n          return m;\n        }\n        return null;\n      }\n    }, {\n      key: 'observedAttributes',\n      get: function get() {\n        return ['id'];\n      }\n    }]);\n\n    return DomModule;\n  }(HTMLElement);\n\n  DomModule.prototype['modules'] = modules;\n\n  customElements.define('dom-module', DomModule);\n\n  // export\n  Polymer.DomModule = DomModule;\n})();\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(0);\n\n(function () {\n  'use strict';\n\n  /**\n   * Module with utilities for manipulating structured data path strings.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module with utilities for manipulating structured data path strings.\n   */\n\n  var Path = {\n\n    /**\n     * Returns true if the given string is a structured data path (has dots).\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.isPath('foo.bar.baz') // true\n     * Polymer.Path.isPath('foo')         // false\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} path Path string\n     * @return {boolean} True if the string contained one or more dots\n     */\n    isPath: function isPath(path) {\n      return path.indexOf('.') >= 0;\n    },\n\n    /**\n     * Returns the root property name for the given path.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.root('foo.bar.baz') // 'foo'\n     * Polymer.Path.root('foo')         // 'foo'\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} path Path string\n     * @return {string} Root property name\n     */\n    root: function root(path) {\n      var dotIndex = path.indexOf('.');\n      if (dotIndex === -1) {\n        return path;\n      }\n      return path.slice(0, dotIndex);\n    },\n\n    /**\n     * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not\n     * Returns true if the given path is an ancestor of the base path.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.isAncestor('foo.bar', 'foo')         // true\n     * Polymer.Path.isAncestor('foo.bar', 'foo.bar')     // false\n     * Polymer.Path.isAncestor('foo.bar', 'foo.bar.baz') // false\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} base Path string to test against.\n     * @param {string} path Path string to test.\n     * @return {boolean} True if `path` is an ancestor of `base`.\n     */\n    isAncestor: function isAncestor(base, path) {\n      //     base.startsWith(path + '.');\n      return base.indexOf(path + '.') === 0;\n    },\n\n    /**\n     * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.isDescendant('foo.bar', 'foo.bar.baz') // true\n     * Polymer.Path.isDescendant('foo.bar', 'foo.bar')     // false\n     * Polymer.Path.isDescendant('foo.bar', 'foo')         // false\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} base Path string to test against.\n     * @param {string} path Path string to test.\n     * @return {boolean} True if `path` is a descendant of `base`.\n     */\n    isDescendant: function isDescendant(base, path) {\n      //     path.startsWith(base + '.');\n      return path.indexOf(base + '.') === 0;\n    },\n\n    /**\n     * Replaces a previous base path with a new base path, preserving the\n     * remainder of the path.\n     *\n     * User must ensure `path` has a prefix of `base`.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.translate('foo.bar', 'zot' 'foo.bar.baz') // 'zot.baz'\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} base Current base string to remove\n     * @param {string} newBase New base string to replace with\n     * @param {string} path Path to translate\n     * @return {string} Translated string\n     */\n    translate: function translate(base, newBase, path) {\n      return newBase + path.slice(base.length);\n    },\n\n    /**\n     * @param {string} base Path string to test against\n     * @param {string} path Path string to test\n     * @return {boolean} True if `path` is equal to `base`\n     * @this {Path}\n     */\n    matches: function matches(base, path) {\n      return base === path || this.isAncestor(base, path) || this.isDescendant(base, path);\n    },\n\n    /**\n     * Converts array-based paths to flattened path.  String-based paths\n     * are returned as-is.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'\n     * Polymer.Path.normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string | !Array<string|number>} path Input path\n     * @return {string} Flattened path\n     */\n    normalize: function normalize(path) {\n      if (Array.isArray(path)) {\n        var parts = [];\n        for (var i = 0; i < path.length; i++) {\n          var args = path[i].toString().split('.');\n          for (var j = 0; j < args.length; j++) {\n            parts.push(args[j]);\n          }\n        }\n        return parts.join('.');\n      } else {\n        return path;\n      }\n    },\n\n    /**\n     * Splits a path into an array of property names. Accepts either arrays\n     * of path parts or strings.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']\n     * Polymer.Path.split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string | !Array<string|number>} path Input path\n     * @return {!Array<string>} Array of path parts\n     * @this {Path}\n     * @suppress {checkTypes}\n     */\n    split: function split(path) {\n      if (Array.isArray(path)) {\n        return this.normalize(path).split('.');\n      }\n      return path.toString().split('.');\n    },\n\n    /**\n     * Reads a value from a path.  If any sub-property in the path is `undefined`,\n     * this method returns `undefined` (will never throw.\n     *\n     * @memberof Polymer.Path\n     * @param {Object} root Object from which to dereference path from\n     * @param {string | !Array<string|number>} path Path to read\n     * @param {Object=} info If an object is provided to `info`, the normalized\n     *  (flattened) path will be set to `info.path`.\n     * @return {*} Value at path, or `undefined` if the path could not be\n     *  fully dereferenced.\n     * @this {Path}\n     */\n    get: function get(root, path, info) {\n      var prop = root;\n      var parts = this.split(path);\n      // Loop over path parts[0..n-1] and dereference\n      for (var i = 0; i < parts.length; i++) {\n        if (!prop) {\n          return;\n        }\n        var part = parts[i];\n        prop = prop[part];\n      }\n      if (info) {\n        info.path = parts.join('.');\n      }\n      return prop;\n    },\n\n    /**\n     * Sets a value to a path.  If any sub-property in the path is `undefined`,\n     * this method will no-op.\n     *\n     * @memberof Polymer.Path\n     * @param {Object} root Object from which to dereference path from\n     * @param {string | !Array<string|number>} path Path to set\n     * @param {*} value Value to set to path\n     * @return {string | undefined} The normalized version of the input path\n     * @this {Path}\n     */\n    set: function set(root, path, value) {\n      var prop = root;\n      var parts = this.split(path);\n      var last = parts[parts.length - 1];\n      if (parts.length > 1) {\n        // Loop over path parts[0..n-2] and dereference\n        for (var i = 0; i < parts.length - 1; i++) {\n          var part = parts[i];\n          prop = prop[part];\n          if (!prop) {\n            return;\n          }\n        }\n        // Set value to object at end of path\n        prop[last] = value;\n      } else {\n        // Simple property set\n        prop[path] = value;\n      }\n      return parts.join('.');\n    }\n\n  };\n\n  /**\n   * Returns true if the given string is a structured data path (has dots).\n   *\n   * This function is deprecated.  Use `Polymer.Path.isPath` instead.\n   *\n   * Example:\n   *\n   * ```\n   * Polymer.Path.isDeep('foo.bar.baz') // true\n   * Polymer.Path.isDeep('foo')         // false\n   * ```\n   *\n   * @deprecated\n   * @memberof Polymer.Path\n   * @param {string} path Path string\n   * @return {boolean} True if the string contained one or more dots\n   */\n  Path.isDeep = Path.isPath;\n\n  Polymer.Path = Path;\n})();\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n__webpack_require__(3);\n\n__webpack_require__(4);\n\n(function () {\n\n  'use strict';\n\n  var caseMap = Polymer.CaseMap;\n\n  var microtask = Polymer.Async.microTask;\n\n  // Save map of native properties; this forms a blacklist or properties\n  // that won't have their values \"saved\" by `saveAccessorValue`, since\n  // reading from an HTMLElement accessor from the context of a prototype throws\n  var nativeProperties = {};\n  var proto = HTMLElement.prototype;\n  while (proto) {\n    var props = Object.getOwnPropertyNames(proto);\n    for (var i = 0; i < props.length; i++) {\n      nativeProperties[props[i]] = true;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  /**\n   * Used to save the value of a property that will be overridden with\n   * an accessor. If the `model` is a prototype, the values will be saved\n   * in `__dataProto`, and it's up to the user (or downstream mixin) to\n   * decide how/when to set these values back into the accessors.\n   * If `model` is already an instance (it has a `__data` property), then\n   * the value will be set as a pending property, meaning the user should\n   * call `_invalidateProperties` or `_flushProperties` to take effect\n   *\n   * @param {Object} model Prototype or instance\n   * @param {string} property Name of property\n   * @private\n   */\n  function saveAccessorValue(model, property) {\n    // Don't read/store value for any native properties since they could throw\n    if (!nativeProperties[property]) {\n      var value = model[property];\n      if (value !== undefined) {\n        if (model.__data) {\n          // Adding accessor to instance; update the property\n          // It is the user's responsibility to call _flushProperties\n          model._setPendingProperty(property, value);\n        } else {\n          // Adding accessor to proto; save proto's value for instance-time use\n          if (!model.__dataProto) {\n            model.__dataProto = {};\n          } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n            model.__dataProto = Object.create(model.__dataProto);\n          }\n          model.__dataProto[property] = value;\n        }\n      }\n    }\n  }\n\n  /**\n   * Element class mixin that provides basic meta-programming for creating one\n   * or more property accessors (getter/setter pair) that enqueue an async\n   * (batched) `_propertiesChanged` callback.\n   *\n   * For basic usage of this mixin, simply declare attributes to observe via\n   * the standard `static get observedAttributes()`, implement `_propertiesChanged`\n   * on the class, and then call `MyClass.createPropertiesForAttributes()` once\n   * on the class to generate property accessors for each observed attribute\n   * prior to instancing.  Last, call `this._flushProperties()` once to enable\n   * the accessors.\n   *\n   * Any `observedAttributes` will automatically be\n   * deserialized via `attributeChangedCallback` and set to the associated\n   * property using `dash-case`-to-`camelCase` convention.\n   *\n   * @mixinFunction\n   * @polymer\n   * @memberof Polymer\n   * @summary Element class mixin for reacting to property changes from\n   *   generated property accessors.\n   */\n  Polymer.PropertyAccessors = Polymer.dedupingMixin(function (superClass) {\n\n    /**\n     * @polymer\n     * @mixinClass\n     * @implements {Polymer_PropertyAccessors}\n     * @extends HTMLElement\n     * @unrestricted\n     */\n    var PropertyAccessors = function (_superClass) {\n      _inherits(PropertyAccessors, _superClass);\n\n      _createClass(PropertyAccessors, null, [{\n        key: 'createPropertiesForAttributes',\n\n\n        /**\n         * Generates property accessors for all attributes in the standard\n         * static `observedAttributes` array.\n         *\n         * Attribute names are mapped to property names using the `dash-case` to\n         * `camelCase` convention\n         *\n         */\n        value: function createPropertiesForAttributes() {\n          var a$ = this.observedAttributes;\n          for (var _i = 0; _i < a$.length; _i++) {\n            this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[_i]));\n          }\n        }\n      }]);\n\n      function PropertyAccessors() {\n        _classCallCheck(this, PropertyAccessors);\n\n        /** @type {boolean} */\n        var _this = _possibleConstructorReturn(this, (PropertyAccessors.__proto__ || Object.getPrototypeOf(PropertyAccessors)).call(this));\n\n        _this.__serializing;\n        /** @type {number} */\n        _this.__dataCounter;\n        /** @type {boolean} */\n        _this.__dataEnabled;\n        /** @type {boolean} */\n        _this.__dataReady;\n        /** @type {boolean} */\n        _this.__dataInvalid;\n        /** @type {!Object} */\n        _this.__data;\n        /** @type {Object} */\n        _this.__dataPending;\n        /** @type {Object} */\n        _this.__dataOld;\n        /** @type {Object} */\n        _this.__dataProto;\n        /** @type {Object} */\n        _this.__dataHasAccessor;\n        /** @type {Object} */\n        _this.__dataInstanceProps;\n        _this._initializeProperties();\n        return _this;\n      }\n\n      /**\n       * Implements native Custom Elements `attributeChangedCallback` to\n       * set an attribute value to a property via `_attributeToProperty`.\n       *\n       * @param {string} name Name of attribute that changed\n       * @param {?string} old Old attribute value\n       * @param {?string} value New attribute value\n       */\n\n\n      _createClass(PropertyAccessors, [{\n        key: 'attributeChangedCallback',\n        value: function attributeChangedCallback(name, old, value) {\n          if (old !== value) {\n            this._attributeToProperty(name, value);\n          }\n        }\n\n        /**\n         * Initializes the local storage for property accessors.\n         *\n         * Provided as an override point for performing any setup work prior\n         * to initializing the property accessor system.\n         *\n         * @protected\n         */\n\n      }, {\n        key: '_initializeProperties',\n        value: function _initializeProperties() {\n          this.__serializing = false;\n          this.__dataCounter = 0;\n          this.__dataEnabled = false;\n          this.__dataReady = false;\n          this.__dataInvalid = false;\n          this.__data = {};\n          this.__dataPending = null;\n          this.__dataOld = null;\n          if (this.__dataProto) {\n            this._initializeProtoProperties(this.__dataProto);\n            this.__dataProto = null;\n          }\n          // Capture instance properties; these will be set into accessors\n          // during first flush. Don't set them here, since we want\n          // these to overwrite defaults/constructor assignments\n          for (var p in this.__dataHasAccessor) {\n            if (this.hasOwnProperty(p)) {\n              this.__dataInstanceProps = this.__dataInstanceProps || {};\n              this.__dataInstanceProps[p] = this[p];\n              delete this[p];\n            }\n          }\n        }\n\n        /**\n         * Called at instance time with bag of properties that were overwritten\n         * by accessors on the prototype when accessors were created.\n         *\n         * The default implementation sets these properties back into the\n         * setter at instance time.  This method is provided as an override\n         * point for customizing or providing more efficient initialization.\n         *\n         * @param {Object} props Bag of property values that were overwritten\n         *   when creating property accessors.\n         * @protected\n         */\n\n      }, {\n        key: '_initializeProtoProperties',\n        value: function _initializeProtoProperties(props) {\n          for (var p in props) {\n            this._setProperty(p, props[p]);\n          }\n        }\n\n        /**\n         * Called at ready time with bag of instance properties that overwrote\n         * accessors when the element upgraded.\n         *\n         * The default implementation sets these properties back into the\n         * setter at ready time.  This method is provided as an override\n         * point for customizing or providing more efficient initialization.\n         *\n         * @param {Object} props Bag of property values that were overwritten\n         *   when creating property accessors.\n         * @protected\n         */\n\n      }, {\n        key: '_initializeInstanceProperties',\n        value: function _initializeInstanceProperties(props) {\n          Object.assign(this, props);\n        }\n\n        /**\n         * Ensures the element has the given attribute. If it does not,\n         * assigns the given value to the attribute.\n         *\n         *\n         * @param {string} attribute Name of attribute to ensure is set.\n         * @param {string} value of the attribute.\n         */\n\n      }, {\n        key: '_ensureAttribute',\n        value: function _ensureAttribute(attribute, value) {\n          if (!this.hasAttribute(attribute)) {\n            this._valueToNodeAttribute(this, value, attribute);\n          }\n        }\n\n        /**\n         * Deserializes an attribute to its associated property.\n         *\n         * This method calls the `_deserializeValue` method to convert the string to\n         * a typed value.\n         *\n         * @param {string} attribute Name of attribute to deserialize.\n         * @param {?string} value of the attribute.\n         * @param {*=} type type to deserialize to.\n         */\n\n      }, {\n        key: '_attributeToProperty',\n        value: function _attributeToProperty(attribute, value, type) {\n          // Don't deserialize back to property if currently reflecting\n          if (!this.__serializing) {\n            var property = caseMap.dashToCamelCase(attribute);\n            this[property] = this._deserializeValue(value, type);\n          }\n        }\n\n        /**\n         * Serializes a property to its associated attribute.\n         *\n         * @param {string} property Property name to reflect.\n         * @param {string=} attribute Attribute name to reflect.\n         * @param {*=} value Property value to refect.\n         */\n\n      }, {\n        key: '_propertyToAttribute',\n        value: function _propertyToAttribute(property, attribute, value) {\n          this.__serializing = true;\n          value = arguments.length < 3 ? this[property] : value;\n          this._valueToNodeAttribute(this, value, attribute || caseMap.camelToDashCase(property));\n          this.__serializing = false;\n        }\n\n        /**\n         * Sets a typed value to an HTML attribute on a node.\n         *\n         * This method calls the `_serializeValue` method to convert the typed\n         * value to a string.  If the `_serializeValue` method returns `undefined`,\n         * the attribute will be removed (this is the default for boolean\n         * type `false`).\n         *\n         * @param {Element} node Element to set attribute to.\n         * @param {*} value Value to serialize.\n         * @param {string} attribute Attribute name to serialize to.\n         */\n\n      }, {\n        key: '_valueToNodeAttribute',\n        value: function _valueToNodeAttribute(node, value, attribute) {\n          var str = this._serializeValue(value);\n          if (str === undefined) {\n            node.removeAttribute(attribute);\n          } else {\n            node.setAttribute(attribute, str);\n          }\n        }\n\n        /**\n         * Converts a typed JavaScript value to a string.\n         *\n         * This method is called by Polymer when setting JS property values to\n         * HTML attributes.  Users may override this method on Polymer element\n         * prototypes to provide serialization for custom types.\n         *\n         * @param {*} value Property value to serialize.\n         * @return {string | undefined} String serialized from the provided property value.\n         */\n\n      }, {\n        key: '_serializeValue',\n        value: function _serializeValue(value) {\n          /* eslint-disable no-fallthrough */\n          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n            case 'boolean':\n              return value ? '' : undefined;\n\n            case 'object':\n              if (value instanceof Date) {\n                return value.toString();\n              } else if (value) {\n                try {\n                  return JSON.stringify(value);\n                } catch (x) {\n                  return '';\n                }\n              }\n\n            default:\n              return value != null ? value.toString() : undefined;\n          }\n        }\n\n        /**\n         * Converts a string to a typed JavaScript value.\n         *\n         * This method is called by Polymer when reading HTML attribute values to\n         * JS properties.  Users may override this method on Polymer element\n         * prototypes to provide deserialization for custom `type`s.  Note,\n         * the `type` argument is the value of the `type` field provided in the\n         * `properties` configuration object for a given property, and is\n         * by convention the constructor for the type to deserialize.\n         *\n         * Note: The return value of `undefined` is used as a sentinel value to\n         * indicate the attribute should be removed.\n         *\n         * @param {?string} value Attribute value to deserialize.\n         * @param {*=} type Type to deserialize the string to.\n         * @return {*} Typed value deserialized from the provided string.\n         */\n\n      }, {\n        key: '_deserializeValue',\n        value: function _deserializeValue(value, type) {\n          /**\n           * @type {*}\n           */\n          var outValue = void 0;\n          switch (type) {\n            case Number:\n              outValue = Number(value);\n              break;\n\n            case Boolean:\n              outValue = value !== null;\n              break;\n\n            case Object:\n              try {\n                outValue = JSON.parse( /** @type string */value);\n              } catch (x) {\n                // allow non-JSON literals like Strings and Numbers\n              }\n              break;\n\n            case Array:\n              try {\n                outValue = JSON.parse( /** @type string */value);\n              } catch (x) {\n                outValue = null;\n                console.warn('Polymer::Attributes: couldn\\'t decode Array as JSON: ' + value);\n              }\n              break;\n\n            case Date:\n              outValue = new Date(value);\n              break;\n\n            case String:\n            default:\n              outValue = value;\n              break;\n          }\n\n          return outValue;\n        }\n        /* eslint-enable no-fallthrough */\n\n        /**\n         * Creates a setter/getter pair for the named property with its own\n         * local storage.  The getter returns the value in the local storage,\n         * and the setter calls `_setProperty`, which updates the local storage\n         * for the property and enqueues a `_propertiesChanged` callback.\n         *\n         * This method may be called on a prototype or an instance.  Calling\n         * this method may overwrite a property value that already exists on\n         * the prototype/instance by creating the accessor.  When calling on\n         * a prototype, any overwritten values are saved in `__dataProto`,\n         * and it is up to the subclasser to decide how/when to set those\n         * properties back into the accessor.  When calling on an instance,\n         * the overwritten value is set via `_setPendingProperty`, and the\n         * user should call `_invalidateProperties` or `_flushProperties`\n         * for the values to take effect.\n         *\n         * @param {string} property Name of the property\n         * @param {boolean=} readOnly When true, no setter is created; the\n         *   protected `_setProperty` function must be used to set the property\n         * @protected\n         */\n\n      }, {\n        key: '_createPropertyAccessor',\n        value: function _createPropertyAccessor(property, readOnly) {\n          if (!this.hasOwnProperty('__dataHasAccessor')) {\n            this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n          }\n          if (!this.__dataHasAccessor[property]) {\n            this.__dataHasAccessor[property] = true;\n            saveAccessorValue(this, property);\n            Object.defineProperty(this, property, {\n              /* eslint-disable valid-jsdoc */\n              /** @this {PropertyAccessors} */\n              get: function get() {\n                return this.__data[property];\n              },\n              /** @this {PropertyAccessors} */\n              set: readOnly ? function () {} : function (value) {\n                this._setProperty(property, value);\n              }\n              /* eslint-enable */\n            });\n          }\n        }\n\n        /**\n         * Returns true if this library created an accessor for the given property.\n         *\n         * @param {string} property Property name\n         * @return {boolean} True if an accessor was created\n         */\n\n      }, {\n        key: '_hasAccessor',\n        value: function _hasAccessor(property) {\n          return this.__dataHasAccessor && this.__dataHasAccessor[property];\n        }\n\n        /**\n         * Updates the local storage for a property (via `_setPendingProperty`)\n         * and enqueues a `_proeprtiesChanged` callback.\n         *\n         * @param {string} property Name of the property\n         * @param {*} value Value to set\n         * @protected\n         */\n\n      }, {\n        key: '_setProperty',\n        value: function _setProperty(property, value) {\n          if (this._setPendingProperty(property, value)) {\n            this._invalidateProperties();\n          }\n        }\n\n        /**\n         * Updates the local storage for a property, records the previous value,\n         * and adds it to the set of \"pending changes\" that will be passed to the\n         * `_propertiesChanged` callback.  This method does not enqueue the\n         * `_propertiesChanged` callback.\n         *\n         * @param {string} property Name of the property\n         * @param {*} value Value to set\n         * @return {boolean} Returns true if the property changed\n         * @protected\n         */\n\n      }, {\n        key: '_setPendingProperty',\n        value: function _setPendingProperty(property, value) {\n          var old = this.__data[property];\n          var changed = this._shouldPropertyChange(property, value, old);\n          if (changed) {\n            if (!this.__dataPending) {\n              this.__dataPending = {};\n              this.__dataOld = {};\n            }\n            // Ensure old is captured from the last turn\n            if (this.__dataOld && !(property in this.__dataOld)) {\n              this.__dataOld[property] = old;\n            }\n            this.__data[property] = value;\n            this.__dataPending[property] = value;\n          }\n          return changed;\n        }\n\n        /**\n         * Returns true if the specified property has a pending change.\n         *\n         * @param {string} prop Property name\n         * @return {boolean} True if property has a pending change\n         * @protected\n         */\n\n      }, {\n        key: '_isPropertyPending',\n        value: function _isPropertyPending(prop) {\n          return Boolean(this.__dataPending && prop in this.__dataPending);\n        }\n\n        /**\n         * Marks the properties as invalid, and enqueues an async\n         * `_propertiesChanged` callback.\n         *\n         * @protected\n         */\n\n      }, {\n        key: '_invalidateProperties',\n        value: function _invalidateProperties() {\n          var _this2 = this;\n\n          if (!this.__dataInvalid && this.__dataReady) {\n            this.__dataInvalid = true;\n            microtask.run(function () {\n              if (_this2.__dataInvalid) {\n                _this2.__dataInvalid = false;\n                _this2._flushProperties();\n              }\n            });\n          }\n        }\n\n        /**\n         * Call to enable property accessor processing. Before this method is\n         * called accessor values will be set but side effects are\n         * queued. When called, any pending side effects occur immediately.\n         * For elements, generally `connectedCallback` is a normal spot to do so.\n         * It is safe to call this method multiple times as it only turns on\n         * property accessors once.\n         */\n\n      }, {\n        key: '_enableProperties',\n        value: function _enableProperties() {\n          if (!this.__dataEnabled) {\n            this.__dataEnabled = true;\n            if (this.__dataInstanceProps) {\n              this._initializeInstanceProperties(this.__dataInstanceProps);\n              this.__dataInstanceProps = null;\n            }\n            this.ready();\n          }\n        }\n\n        /**\n         * Calls the `_propertiesChanged` callback with the current set of\n         * pending changes (and old values recorded when pending changes were\n         * set), and resets the pending set of changes. Generally, this method\n         * should not be called in user code.\n         *\n         *\n         * @protected\n         */\n\n      }, {\n        key: '_flushProperties',\n        value: function _flushProperties() {\n          if (this.__dataPending && this.__dataOld) {\n            var changedProps = this.__dataPending;\n            this.__dataPending = null;\n            this.__dataCounter++;\n            this._propertiesChanged(this.__data, changedProps, this.__dataOld);\n            this.__dataCounter--;\n          }\n        }\n\n        /**\n         * Lifecycle callback called the first time properties are being flushed.\n         * Prior to `ready`, all property sets through accessors are queued and\n         * their effects are flushed after this method returns.\n         *\n         * Users may override this function to implement behavior that is\n         * dependent on the element having its properties initialized, e.g.\n         * from defaults (initialized from `constructor`, `_initializeProperties`),\n         * `attributeChangedCallback`, or values propagated from host e.g. via\n         * bindings.  `super.ready()` must be called to ensure the data system\n         * becomes enabled.\n         *\n         * @public\n         */\n\n      }, {\n        key: 'ready',\n        value: function ready() {\n          this.__dataReady = true;\n          // Run normal flush\n          this._flushProperties();\n        }\n\n        /**\n         * Callback called when any properties with accessors created via\n         * `_createPropertyAccessor` have been set.\n         *\n         * @param {!Object} currentProps Bag of all current accessor values\n         * @param {!Object} changedProps Bag of properties changed since the last\n         *   call to `_propertiesChanged`\n         * @param {!Object} oldProps Bag of previous values for each property\n         *   in `changedProps`\n         * @protected\n         */\n\n      }, {\n        key: '_propertiesChanged',\n        value: function _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars\n\n\n        /**\n         * Method called to determine whether a property value should be\n         * considered as a change and cause the `_propertiesChanged` callback\n         * to be enqueued.\n         *\n         * The default implementation returns `true` for primitive types if a\n         * strict equality check fails, and returns `true` for all Object/Arrays.\n         * The method always returns false for `NaN`.\n         *\n         * Override this method to e.g. provide stricter checking for\n         * Objects/Arrays when using immutable patterns.\n         *\n         * @param {string} property Property name\n         * @param {*} value New property value\n         * @param {*} old Previous property value\n         * @return {boolean} Whether the property should be considered a change\n         *   and enqueue a `_proeprtiesChanged` callback\n         * @protected\n         */\n\n      }, {\n        key: '_shouldPropertyChange',\n        value: function _shouldPropertyChange(property, value, old) {\n          return (\n            // Strict equality check\n            old !== value && (\n            // This ensures (old==NaN, value==NaN) always returns false\n            old === old || value === value)\n          );\n        }\n      }]);\n\n      return PropertyAccessors;\n    }(superClass);\n\n    return PropertyAccessors;\n  });\n})();\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n(function () {\n\n  'use strict';\n\n  // 1.x backwards-compatible auto-wrapper for template type extensions\n  // This is a clear layering violation and gives favored-nation status to\n  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n  // b.) to maintain if/repeat capability in parser-constrained elements\n  //     (e.g. table, select) in lieu of native CE type extensions without\n  //     massive new invention in this space (e.g. directive system)\n\n  var templateExtensions = {\n    'dom-if': true,\n    'dom-repeat': true\n  };\n  function wrapTemplateExtension(node) {\n    var is = node.getAttribute('is');\n    if (is && templateExtensions[is]) {\n      var t = node;\n      t.removeAttribute('is');\n      node = t.ownerDocument.createElement(is);\n      t.parentNode.replaceChild(node, t);\n      node.appendChild(t);\n      while (t.attributes.length) {\n        node.setAttribute(t.attributes[0].name, t.attributes[0].value);\n        t.removeAttribute(t.attributes[0].name);\n      }\n    }\n    return node;\n  }\n\n  function findTemplateNode(root, nodeInfo) {\n    // recursively ascend tree until we hit root\n    var parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n    // unwind the stack, returning the indexed node at each level\n    if (parent) {\n      // note: marginally faster than indexing via childNodes\n      // (http://jsperf.com/childnodes-lookup)\n      for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {\n        if (nodeInfo.parentIndex === i++) {\n          return n;\n        }\n      }\n    } else {\n      return root;\n    }\n  }\n\n  // construct `$` map (from id annotations)\n  function applyIdToMap(inst, map, node, nodeInfo) {\n    if (nodeInfo.id) {\n      map[nodeInfo.id] = node;\n    }\n  }\n\n  // install event listeners (from event annotations)\n  function applyEventListener(inst, node, nodeInfo) {\n    if (nodeInfo.events && nodeInfo.events.length) {\n      for (var j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {\n        inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n      }\n    }\n  }\n\n  // push configuration references at configure time\n  function applyTemplateContent(inst, node, nodeInfo) {\n    if (nodeInfo.templateInfo) {\n      node._templateInfo = nodeInfo.templateInfo;\n    }\n  }\n\n  function createNodeEventHandler(context, eventName, methodName) {\n    // Instances can optionally have a _methodHost which allows redirecting where\n    // to find methods. Currently used by `templatize`.\n    context = context._methodHost || context;\n    var handler = function handler(e) {\n      if (context[methodName]) {\n        context[methodName](e, e.detail);\n      } else {\n        console.warn('listener method `' + methodName + '` not defined');\n      }\n    };\n    return handler;\n  }\n\n  /**\n   * Element mixin that provides basic template parsing and stamping, including\n   * the following template-related features for stamped templates:\n   *\n   * - Declarative event listeners (`on-eventname=\"listener\"`)\n   * - Map of node id's to stamped node instances (`this.$.id`)\n   * - Nested template content caching/removal and re-installation (performance\n   *   optimization)\n   *\n   * @mixinFunction\n   * @polymer\n   * @memberof Polymer\n   * @summary Element class mixin that provides basic template parsing and stamping\n   */\n  Polymer.TemplateStamp = Polymer.dedupingMixin(function (superClass) {\n\n    /**\n     * @polymer\n     * @mixinClass\n     * @implements {Polymer_TemplateStamp}\n     */\n    var TemplateStamp = function (_superClass) {\n      _inherits(TemplateStamp, _superClass);\n\n      function TemplateStamp() {\n        _classCallCheck(this, TemplateStamp);\n\n        return _possibleConstructorReturn(this, (TemplateStamp.__proto__ || Object.getPrototypeOf(TemplateStamp)).apply(this, arguments));\n      }\n\n      _createClass(TemplateStamp, [{\n        key: '_stampTemplate',\n\n\n        /**\n         * Clones the provided template content and returns a document fragment\n         * containing the cloned dom.\n         *\n         * The template is parsed (once and memoized) using this library's\n         * template parsing features, and provides the following value-added\n         * features:\n         * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n         * * Generates an \"id map\" for all nodes with id's under `$` on returned\n         *   document fragment\n         * * Passes template info including `content` back to templates as\n         *   `_templateInfo` (a performance optimization to avoid deep template\n         *   cloning)\n         *\n         * Note that the memoized template parsing process is destructive to the\n         * template: attributes for bindings and declarative event listeners are\n         * removed after being noted in notes, and any nested `<template>.content`\n         * is removed and stored in notes as well.\n         *\n         * @param {!HTMLTemplateElement} template Template to stamp\n         * @return {!StampedTemplate} Cloned template content\n         */\n        value: function _stampTemplate(template) {\n          // Polyfill support: bootstrap the template if it has not already been\n          if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n            HTMLTemplateElement.decorate(template);\n          }\n          var templateInfo = this.constructor._parseTemplate(template);\n          var nodeInfo = templateInfo.nodeInfoList;\n          var content = templateInfo.content || template.content;\n          var dom = /** @type DocumentFragment */document.importNode(content, true);\n          // NOTE: ShadyDom optimization indicating there is an insertion point\n          dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n          var nodes = dom.nodeList = new Array(nodeInfo.length);\n          dom.$ = {};\n          for (var i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {\n            var node = nodes[i] = findTemplateNode(dom, info);\n            applyIdToMap(this, dom.$, node, info);\n            applyTemplateContent(this, node, info);\n            applyEventListener(this, node, info);\n          }\n          return (/** @type {!StampedTemplate} */dom\n          );\n        }\n\n        /**\n         * Adds an event listener by method name for the event provided.\n         *\n         * This method generates a handler function that looks up the method\n         * name at handling time.\n         *\n         * @param {Node} node Node to add listener on\n         * @param {string} eventName Name of event\n         * @param {string} methodName Name of method\n         * @param {*=} context Context the method will be called on (defaults\n         *   to `node`)\n         * @return {Function} Generated handler function\n         */\n\n      }, {\n        key: '_addMethodEventListenerToNode',\n        value: function _addMethodEventListenerToNode(node, eventName, methodName, context) {\n          context = context || node;\n          var handler = createNodeEventHandler(context, eventName, methodName);\n          this._addEventListenerToNode(node, eventName, handler);\n          return handler;\n        }\n\n        /**\n         * Override point for adding custom or simulated event handling.\n         *\n         * @param {Node} node Node to add event listener to\n         * @param {string} eventName Name of event\n         * @param {Function} handler Listener function to add\n         */\n\n      }, {\n        key: '_addEventListenerToNode',\n        value: function _addEventListenerToNode(node, eventName, handler) {\n          node.addEventListener(eventName, handler);\n        }\n\n        /**\n         * Override point for adding custom or simulated event handling.\n         *\n         * @param {Node} node Node to remove event listener from\n         * @param {string} eventName Name of event\n         * @param {Function} handler Listener function to remove\n         */\n\n      }, {\n        key: '_removeEventListenerFromNode',\n        value: function _removeEventListenerFromNode(node, eventName, handler) {\n          node.removeEventListener(eventName, handler);\n        }\n      }], [{\n        key: '_parseTemplate',\n\n\n        /**\n         * Scans a template to produce template metadata.\n         *\n         * Template-specific metadata are stored in the object returned, and node-\n         * specific metadata are stored in objects in its flattened `nodeInfoList`\n         * array.  Only nodes in the template that were parsed as nodes of\n         * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n         * contains an `index` (`childNodes` index in parent) and optionally\n         * `parent`, which points to node info of its parent (including its index).\n         *\n         * The template metadata object returned from this method has the following\n         * structure (many fields optional):\n         *\n         * ```js\n         *   {\n         *     // Flattened list of node metadata (for nodes that generated metadata)\n         *     nodeInfoList: [\n         *       {\n         *         // `id` attribute for any nodes with id's for generating `$` map\n         *         id: {string},\n         *         // `on-event=\"handler\"` metadata\n         *         events: [\n         *           {\n         *             name: {string},   // event name\n         *             value: {string},  // handler method name\n         *           }, ...\n         *         ],\n         *         // Notes when the template contained a `<slot>` for shady DOM\n         *         // optimization purposes\n         *         hasInsertionPoint: {boolean},\n         *         // For nested `<template>`` nodes, nested template metadata\n         *         templateInfo: {object}, // nested template metadata\n         *         // Metadata to allow efficient retrieval of instanced node\n         *         // corresponding to this metadata\n         *         parentInfo: {number},   // reference to parent nodeInfo>\n         *         parentIndex: {number},  // index in parent's `childNodes` collection\n         *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n         *       },\n         *       ...\n         *     ],\n         *     // When true, the template had the `strip-whitespace` attribute\n         *     // or was nested in a template with that setting\n         *     stripWhitespace: {boolean},\n         *     // For nested templates, nested template content is moved into\n         *     // a document fragment stored here; this is an optimization to\n         *     // avoid the cost of nested template cloning\n         *     content: {DocumentFragment}\n         *   }\n         * ```\n         *\n         * This method kicks off a recursive treewalk as follows:\n         *\n         * ```\n         *    _parseTemplate <---------------------+\n         *      _parseTemplateContent              |\n         *        _parseTemplateNode  <------------|--+\n         *          _parseTemplateNestedTemplate --+  |\n         *          _parseTemplateChildNodes ---------+\n         *          _parseTemplateNodeAttributes\n         *            _parseTemplateNodeAttribute\n         *\n         * ```\n         *\n         * These methods may be overridden to add custom metadata about templates\n         * to either `templateInfo` or `nodeInfo`.\n         *\n         * Note that this method may be destructive to the template, in that\n         * e.g. event annotations may be removed after being noted in the\n         * template metadata.\n         *\n         * @param {!HTMLTemplateElement} template Template to parse\n         * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n         *   template, for parsing nested templates\n         * @return {!TemplateInfo} Parsed template metadata\n         */\n        value: function _parseTemplate(template, outerTemplateInfo) {\n          // since a template may be re-used, memo-ize metadata\n          if (!template._templateInfo) {\n            var templateInfo = template._templateInfo = {};\n            templateInfo.nodeInfoList = [];\n            templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');\n            this._parseTemplateContent(template, templateInfo, { parent: null });\n          }\n          return template._templateInfo;\n        }\n      }, {\n        key: '_parseTemplateContent',\n        value: function _parseTemplateContent(template, templateInfo, nodeInfo) {\n          return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n        }\n\n        /**\n         * Parses template node and adds template and node metadata based on\n         * the current node, and its `childNodes` and `attributes`.\n         *\n         * This method may be overridden to add custom node or template specific\n         * metadata based on this node.\n         *\n         * @param {Node} node Node to parse\n         * @param {!TemplateInfo} templateInfo Template metadata for current template\n         * @param {!NodeInfo} nodeInfo Node metadata for current template.\n         * @return {boolean} `true` if the visited node added node-specific\n         *   metadata to `nodeInfo`\n         */\n\n      }, {\n        key: '_parseTemplateNode',\n        value: function _parseTemplateNode(node, templateInfo, nodeInfo) {\n          var noted = void 0;\n          var element = /** @type Element */node;\n          if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n            noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n          } else if (element.localName === 'slot') {\n            // For ShadyDom optimization, indicating there is an insertion point\n            templateInfo.hasInsertionPoint = true;\n          }\n          if (element.firstChild) {\n            noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;\n          }\n          if (element.hasAttributes && element.hasAttributes()) {\n            noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n          }\n          return noted;\n        }\n\n        /**\n         * Parses template child nodes for the given root node.\n         *\n         * This method also wraps whitelisted legacy template extensions\n         * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n         * wrappers, collapses text nodes, and strips whitespace from the template\n         * if the `templateInfo.stripWhitespace` setting was provided.\n         *\n         * @param {Node} root Root node whose `childNodes` will be parsed\n         * @param {!TemplateInfo} templateInfo Template metadata for current template\n         * @param {!NodeInfo} nodeInfo Node metadata for current template.\n         */\n\n      }, {\n        key: '_parseTemplateChildNodes',\n        value: function _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n          for (var node = root.firstChild, parentIndex = 0, next; node; node = next) {\n            // Wrap templates\n            if (node.localName == 'template') {\n              node = wrapTemplateExtension(node);\n            }\n            // collapse adjacent textNodes: fixes an IE issue that can cause\n            // text nodes to be inexplicably split =(\n            // note that root.normalize() should work but does not so we do this\n            // manually.\n            next = node.nextSibling;\n            if (node.nodeType === Node.TEXT_NODE) {\n              var /** Node */n = next;\n              while (n && n.nodeType === Node.TEXT_NODE) {\n                node.textContent += n.textContent;\n                next = n.nextSibling;\n                root.removeChild(n);\n                n = next;\n              }\n              // optionally strip whitespace\n              if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n                root.removeChild(node);\n                continue;\n              }\n            }\n            var childInfo = { parentIndex: parentIndex, parentInfo: nodeInfo };\n            if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n              childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;\n            }\n            // Increment if not removed\n            if (node.parentNode) {\n              parentIndex++;\n            }\n          }\n        }\n\n        /**\n         * Parses template content for the given nested `<template>`.\n         *\n         * Nested template info is stored as `templateInfo` in the current node's\n         * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n         * It will then be the responsibility of the host to set it back to the\n         * template and for users stamping nested templates to use the\n         * `_contentForTemplate` method to retrieve the content for this template\n         * (an optimization to avoid the cost of cloning nested template content).\n         *\n         * @param {HTMLTemplateElement} node Node to parse (a <template>)\n         * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n         *   that includes the template `node`\n         * @param {!NodeInfo} nodeInfo Node metadata for current template.\n         * @return {boolean} `true` if the visited node added node-specific\n         *   metadata to `nodeInfo`\n         */\n\n      }, {\n        key: '_parseTemplateNestedTemplate',\n        value: function _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n          var templateInfo = this._parseTemplate(node, outerTemplateInfo);\n          var content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();\n          content.appendChild(node.content);\n          nodeInfo.templateInfo = templateInfo;\n          return true;\n        }\n\n        /**\n         * Parses template node attributes and adds node metadata to `nodeInfo`\n         * for nodes of interest.\n         *\n         * @param {Element} node Node to parse\n         * @param {TemplateInfo} templateInfo Template metadata for current template\n         * @param {NodeInfo} nodeInfo Node metadata for current template.\n         * @return {boolean} `true` if the visited node added node-specific\n         *   metadata to `nodeInfo`\n         */\n\n      }, {\n        key: '_parseTemplateNodeAttributes',\n        value: function _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n          // Make copy of original attribute list, since the order may change\n          // as attributes are added and removed\n          var noted = false;\n          var attrs = Array.from(node.attributes);\n          for (var i = attrs.length - 1, a; a = attrs[i]; i--) {\n            noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n          }\n          return noted;\n        }\n\n        /**\n         * Parses a single template node attribute and adds node metadata to\n         * `nodeInfo` for attributes of interest.\n         *\n         * This implementation adds metadata for `on-event=\"handler\"` attributes\n         * and `id` attributes.\n         *\n         * @param {Element} node Node to parse\n         * @param {!TemplateInfo} templateInfo Template metadata for current template\n         * @param {!NodeInfo} nodeInfo Node metadata for current template.\n         * @param {string} name Attribute name\n         * @param {string} value Attribute value\n         * @return {boolean} `true` if the visited node added node-specific\n         *   metadata to `nodeInfo`\n         */\n\n      }, {\n        key: '_parseTemplateNodeAttribute',\n        value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n          // events (on-*)\n          if (name.slice(0, 3) === 'on-') {\n            node.removeAttribute(name);\n            nodeInfo.events = nodeInfo.events || [];\n            nodeInfo.events.push({\n              name: name.slice(3),\n              value: value\n            });\n            return true;\n          }\n          // static id\n          else if (name === 'id') {\n              nodeInfo.id = value;\n              return true;\n            }\n          return false;\n        }\n\n        /**\n         * Returns the `content` document fragment for a given template.\n         *\n         * For nested templates, Polymer performs an optimization to cache nested\n         * template content to avoid the cost of cloning deeply nested templates.\n         * This method retrieves the cached content for a given template.\n         *\n         * @param {HTMLTemplateElement} template Template to retrieve `content` for\n         * @return {DocumentFragment} Content fragment\n         */\n\n      }, {\n        key: '_contentForTemplate',\n        value: function _contentForTemplate(template) {\n          var templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;\n          return templateInfo && templateInfo.content || template.content;\n        }\n      }]);\n\n      return TemplateStamp;\n    }(superClass);\n\n    return TemplateStamp;\n  });\n})();\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _resolveUrl = __webpack_require__(18);\n\nvar _resolveUrl2 = _interopRequireDefault(_resolveUrl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nexports.default = function (superClass) {\n  return function (_superClass) {\n    _inherits(_class, _superClass);\n\n    // static get observedAttributes () {\n    //   const observedAttributes = super.observedAttributes || []\n    //   return observedAttributes.concat(['path', 'query', 'urlSpaceRegex', 'hash', 'dwellTime', 'urlSpaceRegex', '_urlSpaceRegExp', '_lastChangedAt', '_initialized'])\n    // }\n\n    // _propertiesChanged (currentProps, changedProps, oldProps) {\n    //   if (super._propertiesChanged) {\n    //     super._propertiesChanged(currentProps, changedProps, oldProps)\n    //   }\n    //   if ('path' in changedProps && 'query' in changedProps && 'hash' in changedProps) {\n    //     if (changedProps['path'] !== oldProps['path'] && changedProps['query'] !== oldProps['query'] && changedProps['hash'] !== oldProps['hash']) {\n    //       this._updateUrl(changedProps['path'], changedProps['query'], changedProps['hash'])\n    //     }\n    //   }\n    //   if ('urlSpaceRegex' in changedProps) {\n    //     if (changedProps['urlSpaceRegex'] !== oldProps['urlSpaceRegex']) {\n    //       this.__urlSpaceRegExp = this._makeRegExp(changedProps['urlSpaceRegex'])\n    //     }\n    //   }\n    // }\n\n    function _class() {\n      _classCallCheck(this, _class);\n\n      var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));\n\n      _this._boundHashChanged = _this._hashChanged.bind(_this);\n      _this._boundUrlChanged = _this._urlChanged.bind(_this);\n      _this._boundGlobalOnClick = _this._globalOnClick.bind(_this);\n      return _this;\n    }\n\n    _createClass(_class, [{\n      key: 'connectedCallback',\n      value: function connectedCallback() {\n        if (_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'disconnectedCallback', this)) {\n          _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'connectedCallback', this).call(this);\n        }\n        window.addEventListener('hashchange', this._boundHashChanged);\n        window.addEventListener('location-changed', this._boundUrlChanged);\n        window.addEventListener('popstate', this._boundUrlChanged);\n        document.body.addEventListener('click', this._boundGlobalOnClick, true);\n        this._lastChangedAt = window.performance.now() - (this.dwellTime - 200);\n        this._initialized = true;\n\n        // set initialize values\n        this.path = window.decodeURIComponent(window.location.pathname);\n        this.query = window.location.search.slice(1);\n        this.hash = window.decodeURIComponent(window.location.hash.slice(1));\n        this.dwellTime = 2000;\n        this._initialized = false;\n        this._urlChanged();\n      }\n    }, {\n      key: 'disconnectedCallback',\n      value: function disconnectedCallback() {\n        if (_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'disconnectedCallback', this)) {\n          _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'disconnectedCallback', this).call(this);\n        }\n        window.removeEventListener('hashchange', this._boundHashChanged);\n        window.removeEventListener('location-changed', this._boundUrlChanged);\n        window.removeEventListener('popstate', this._boundUrlChanged);\n        document.body.removeEventListener('click', this._boundGlobalOnClick);\n        this._initialized = false;\n      }\n    }, {\n      key: '_hashChanged',\n      value: function _hashChanged() {\n        this.hash = window.decodeURIComponent(window.location.hash.substring(1));\n      }\n    }, {\n      key: '_urlChanged',\n      value: function _urlChanged() {\n        // We want to extract all info out of the updated URL before we\n        // try to write anything back into it.\n        //\n        // i.e. without _dontUpdateUrl we'd overwrite the new path with the old\n        // one when we set this.hash. Likewise for query.\n        this._dontUpdateUrl = true;\n        this._hashChanged();\n        this.path = window.decodeURIComponent(window.location.pathname);\n        this.query = window.location.search.substring(1);\n        this._dontUpdateUrl = false;\n        this._updateUrl();\n      }\n    }, {\n      key: '_getUrl',\n      value: function _getUrl() {\n        var partiallyEncodedPath = window.encodeURI(this.path).replace(/\\#/g, '%23').replace(/\\?/g, '%3F');\n        var partiallyEncodedQuery = '';\n        if (this.query) {\n          partiallyEncodedQuery = '?' + this.query.replace(/\\#/g, '%23');\n        }\n        var partiallyEncodedHash = '';\n        if (this.hash) {\n          partiallyEncodedHash = '#' + window.encodeURI(this.hash);\n        }\n        return partiallyEncodedPath + partiallyEncodedQuery + partiallyEncodedHash;\n      }\n    }, {\n      key: '_updateUrl',\n      value: function _updateUrl() {\n        if (this._dontUpdateUrl || !this._initialized) {\n          return;\n        }\n\n        if (this.path === window.decodeURIComponent(window.location.pathname) && this.query === window.location.search.substring(1) && this.hash === window.decodeURIComponent(window.location.hash.substring(1))) {\n          // Nothing to do, the current URL is a representation of our properties.\n          return;\n        }\n        var newUrl = this._getUrl();\n        // Need to use a full URL in case the containing page has a base URI.\n        var fullNewUrl = (0, _resolveUrl2.default)(newUrl, window.location.protocol + '//' + window.location.host).href;\n        var now = window.performance.now();\n        var shouldReplace = this._lastChangedAt + this.dwellTime > now;\n        this._lastChangedAt = now;\n        if (shouldReplace) {\n          window.history.replaceState({}, '', fullNewUrl);\n        } else {\n          window.history.pushState({}, '', fullNewUrl);\n        }\n        window.dispatchEvent(new CustomEvent('location-changed'));\n      }\n\n      /**\n       * A necessary evil so that links work as expected. Does its best to\n       * bail out early if possible.\n       *\n       * @param {MouseEvent} event .\n       */\n\n    }, {\n      key: '_globalOnClick',\n      value: function _globalOnClick(event) {\n        // If another event handler has stopped this event then there's nothing\n        // for us to do. This can happen e.g. when there are multiple\n        // iron-location elements in a page.\n        if (event.defaultPrevented) {\n          return;\n        }\n        var href = this._getSameOriginLinkHref(event);\n        if (!href) {\n          return;\n        }\n        event.preventDefault();\n        // If the navigation is to the current page we shouldn't add a history\n        // entry or fire a change event.\n        if (href === window.location.href) {\n          return;\n        }\n        window.history.pushState({}, '', href);\n        window.dispatchEvent(new CustomEvent('location-changed'));\n      }\n\n      /**\n       * Returns the absolute URL of the link (if any) that this click event\n       * is clicking on, if we can and should override the resulting full\n       * page navigation. Returns null otherwise.\n       *\n       * @param {MouseEvent} event .\n       * @return {string?} .\n       */\n\n    }, {\n      key: '_getSameOriginLinkHref',\n      value: function _getSameOriginLinkHref(event) {\n        // We only care about left-clicks.\n        if (event.button !== 0) {\n          return null;\n        }\n        // We don't want modified clicks, where the intent is to open the page\n        // in a new tab.\n        if (event.metaKey || event.ctrlKey) {\n          return null;\n        }\n        var eventPath = event.composedPath();\n        var anchor = null;\n        for (var i = 0; i < eventPath.length; i++) {\n          var element = eventPath[i];\n          if (element.tagName === 'A' && element.href) {\n            anchor = element;\n            break;\n          }\n        }\n        // If there's no link there's nothing to do.\n        if (!anchor) {\n          return null;\n        }\n        // Target blank is a new tab, don't intercept.\n        if (anchor.target === '_blank') {\n          // capture link click\n          if (anchor.href && window.ga) {\n            ga('send', 'event', 'Link', 'Click', anchor.href, 1);\n          }\n          return null;\n        }\n        // If the link is for an existing parent frame, don't intercept.\n        if ((anchor.target === '_top' || anchor.target === '_parent') && window.top !== window) {\n          return null;\n        }\n        var href = anchor.href;\n        // It only makes sense for us to intercept same-origin navigations.\n        // pushState/replaceState don't work with cross-origin links.\n        var url;\n        if (document.baseURI != null) {\n          url = (0, _resolveUrl2.default)(href, /** @type {string} */document.baseURI);\n        } else {\n          url = (0, _resolveUrl2.default)(href);\n        }\n        var origin;\n        // IE Polyfill\n        if (window.location.origin) {\n          origin = window.location.origin;\n        } else {\n          origin = window.location.protocol + '//' + window.location.host;\n        }\n        var urlOrigin;\n        if (url.origin) {\n          urlOrigin = url.origin;\n        } else {\n          urlOrigin = url.protocol + '//' + url.host;\n        }\n        if (urlOrigin !== origin) {\n          return null;\n        }\n        var normalizedHref = url.pathname + url.search + url.hash;\n        // pathname should start with '/', but may not if `new URL` is not supported\n        if (normalizedHref[0] !== '/') {\n          normalizedHref = '/' + normalizedHref;\n        }\n        // If we've been configured not to handle this url... don't handle it!\n        if (this._urlSpaceRegExp && !this._urlSpaceRegExp.test(normalizedHref)) {\n          return null;\n        }\n        // Need to use a full URL in case the containing page has a base URI.\n        var fullNormalizedHref = (0, _resolveUrl2.default)(normalizedHref, window.location.href).href;\n        return fullNormalizedHref;\n      }\n    }, {\n      key: '_makeRegExp',\n      value: function _makeRegExp(urlSpaceRegex) {\n        return RegExp(urlSpaceRegex);\n      }\n    }]);\n\n    return _class;\n  }(superClass);\n};\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar workingURL;\nvar urlDoc, urlBase, anchor;\n/**\n * @param {string} path\n * @param {string=} base\n * @return {!URL|!HTMLAnchorElement}\n */\n\nexports.default = function (path, base) {\n  if (workingURL === undefined) {\n    workingURL = false;\n    try {\n      var u = new URL('b', 'http://a');\n      u.pathname = 'c%20d';\n      workingURL = u.href === 'http://a/c%20d';\n      workingURL = workingURL && new URL('http://www.google.com/?foo bar').href === 'http://www.google.com/?foo%20bar';\n    } catch (e) {}\n  }\n  if (workingURL) {\n    return new URL(path, base);\n  }\n  if (!urlDoc) {\n    urlDoc = document.implementation.createHTMLDocument('url');\n    urlBase = urlDoc.createElement('base');\n    urlDoc.head.appendChild(urlBase);\n    anchor = /** @type {HTMLAnchorElement} */urlDoc.createElement('a');\n  }\n  urlBase.href = base;\n  anchor.href = path.replace(/ /g, '%20');\n  return anchor;\n};\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// import 'polymer/lib/mixins/property-effects.html'\nexports.default = function (superClass) {\n  return function (_superClass) {\n    _inherits(_class, _superClass);\n\n    function _class() {\n      _classCallCheck(this, _class);\n\n      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n    }\n\n    _createClass(_class, [{\n      key: 'connectedCallback',\n      value: function connectedCallback() {\n        if (_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'connectedCallback', this)) {\n          _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'connectedCallback', this).call(this);\n        }\n\n        // initialize values\n        this.paramsObject = {};\n        this._dontReact = false;\n      }\n\n      // static get observedAttributes () {\n      //   const observedAttributes = super.observedAttributes || []\n      //   return observedAttributes.concat(['paramsString', 'paramsObject', '_dontReact'])\n      // }\n\n      // _propertiesChanged (currentProps, changedProps, oldProps) {\n      //   if (super._propertiesChanged) {\n      //     super._propertiesChanged(currentProps, changedProps, oldProps)\n      //   }\n      //   if ('paramsString' in changedProps) {\n      //     if (changedProps['paramsString'] !== oldProps['paramsString']) {\n      //       this._paramsStringChanged()\n      //     }\n      //   }\n      //   if ('query' in changedProps) {\n      //     if (changedProps['query'] !== oldProps['query']) {\n      //       this._queryChanged(changedProps['query'])\n      //     }\n      //   }\n      // }\n\n    }, {\n      key: '_queryChanged',\n      value: function _queryChanged(query) {\n        this.paramsString = query;\n      }\n    }, {\n      key: '_paramsStringChanged',\n      value: function _paramsStringChanged() {\n        this._dontReact = true;\n        this.paramsObject = this._decodeParams(this.paramsString);\n        this._dontReact = false;\n      }\n    }, {\n      key: 'paramsObjectChanged',\n      value: function paramsObjectChanged() {\n        console.log('paramsObject');\n        if (this._dontReact) {\n          return;\n        }\n        this.paramsString = this._encodeParams(this.paramsObject).replace(/%3F/g, '?').replace(/%2F/g, '/').replace(/'/g, '%27');\n      }\n    }, {\n      key: '_encodeParams',\n      value: function _encodeParams(params) {\n        var encodedParams = [];\n        for (var key in params) {\n          var value = params[key];\n          if (value === '') {\n            encodedParams.push(encodeURIComponent(key));\n          } else if (value) {\n            encodedParams.push(encodeURIComponent(key) + '=' + encodeURIComponent(value.toString()));\n          }\n        }\n        return encodedParams.join('&');\n      }\n    }, {\n      key: '_decodeParams',\n      value: function _decodeParams(paramString) {\n        var params = {};\n        // Work around a bug in decodeURIComponent where + is not\n        // converted to spaces:\n        paramString = (paramString || '').replace(/\\+/g, '%20');\n        var paramList = paramString.split('&');\n        for (var i = 0; i < paramList.length; i++) {\n          var param = paramList[i].split('=');\n          if (param[0]) {\n            params[decodeURIComponent(param[0])] = decodeURIComponent(param[1] || '');\n          }\n        }\n        return params;\n      }\n    }]);\n\n    return _class;\n  }(superClass);\n};\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar isarray = __webpack_require__(21);\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp;\nmodule.exports.parse = parse;\nmodule.exports.compile = compile;\nmodule.exports.tokensToFunction = tokensToFunction;\nmodule.exports.tokensToRegExp = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n// Match escaped characters that would otherwise appear in future matches.\n// This allows the user to escape special characters that won't transform.\n'(\\\\\\\\.)',\n// Match Express-style parameters and un-named parameters with a prefix\n// and optional suffixes. Matches appear as:\n//\n// \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n// \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n// \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n'([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse(str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue;\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens;\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options));\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty(str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk(str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (_typeof(tokens[i]) === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue;\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue;\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined');\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue;\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue;\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path;\n  };\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1');\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup(group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys(re, keys) {\n  re.keys = keys;\n  return re;\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags(options) {\n  return options.sensitive ? '' : 'i';\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp(path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys);\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp(path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys);\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options);\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp(tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys);\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp(path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */keys);\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);\n  }\n\n  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);\n}\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = {\n  '/': function _() {\n    return __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 27));\n  },\n  'style-guide': function styleGuide() {\n    return __webpack_require__.e/* import() */(2).then(__webpack_require__.bind(null, 28));\n  }\n};\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = {\n  'not-found': function notFound() {\n    return __webpack_require__.e/* import() */(3).then(__webpack_require__.bind(null, 29));\n  },\n  'not-authorized': function notAuthorized() {\n    return __webpack_require__.e/* import() */(4).then(__webpack_require__.bind(null, 30));\n  }\n};\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = {};\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = {\n  exampleAuthentication: function exampleAuthentication() {\n    // returns a 'falsy' value, which means the user is not authenticated\n    return false;\n  }\n};\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-env browser */\n\nvar RegisterHtmlTemplate = function () {\n  function RegisterHtmlTemplate() {\n    _classCallCheck(this, RegisterHtmlTemplate);\n  }\n\n  _createClass(RegisterHtmlTemplate, null, [{\n    key: 'register',\n\n    /**\n     * Create a `<template>` element to hold `<dom-module>` content.\n     * This bit of code will execute in the context of the main document,\n     * calling `importNode` on the `<template>`, which in turn triggers\n     * the lifecycle of the `<dom-module>` and allows it to insert its\n     * content into Polymer's global module map. When a Polymer element\n     * boots up it will fetch its template from this module map.\n     * https://github.com/Polymer/polymer/blob/master/lib/mixins/element-mixin.html#L501-L538\n     * @param {string} val A `<dom-module>` as an HTML string\n     */\n    value: function register(val) {\n      var content = void 0;\n      var template = document.createElement('template');\n      template.innerHTML = val;\n      if (template.content) {\n        content = template.content; // eslint-disable-line prefer-destructuring\n      } else {\n        content = document.createDocumentFragment();\n        while (template.firstChild) {\n          content.appendChild(template.firstChild);\n        }\n      }\n      document.importNode(content, true);\n    }\n    /**\n     * Content that will be injected into the main document. This is primarily\n     * for things like `<iron-iconset>` and `<custom-style>` which do not have\n     * templates but rely on HTML Imports ability to apply content to the main\n     * document.\n     * @param {string} val An HTML string\n     */\n\n  }, {\n    key: 'toBody',\n    value: function toBody(val) {\n      var trimmedVal = val.trim();\n      if (trimmedVal) {\n        var div = document.createElement('div');\n        div.innerHTML = trimmedVal;\n        if (div.firstChild) {\n          if (document.body) {\n            document.body.insertBefore(div.firstChild, document.body.firstChild);\n          } else {\n            document.addEventListener('DOMContentLoaded', function () {\n              document.body.insertBefore(div.firstChild, document.body.firstChild);\n            });\n          }\n        }\n      }\n    }\n  }]);\n\n  return RegisterHtmlTemplate;\n}();\n\nmodule.exports = RegisterHtmlTemplate;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// main.bundle.js"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [], result;\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// objects to store loaded and loading chunks\n \tvar installedChunks = {\n \t\t5: 0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData === 0) {\n \t\t\treturn new Promise(function(resolve) { resolve(); });\n \t\t}\n\n \t\t// a Promise means \"currently loading\".\n \t\tif(installedChunkData) {\n \t\t\treturn installedChunkData[2];\n \t\t}\n\n \t\t// setup Promise in chunk cache\n \t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t});\n \t\tinstalledChunkData[2] = promise;\n\n \t\t// start chunk loading\n \t\tvar head = document.getElementsByTagName('head')[0];\n \t\tvar script = document.createElement('script');\n \t\tscript.type = 'text/javascript';\n \t\tscript.charset = 'utf-8';\n \t\tscript.async = true;\n \t\tscript.timeout = 120000;\n\n \t\tif (__webpack_require__.nc) {\n \t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t}\n \t\tscript.src = __webpack_require__.p + \"\" + ({\"0\":\"uxia-home-page\",\"1\":\"app-toast\",\"2\":\"example-style-guide-page\",\"3\":\"example-not-found-page\",\"4\":\"example-not-authorized-page\"}[chunkId]||chunkId) + \".\" + chunkId + \".bundle.js\";\n \t\tvar timeout = setTimeout(onScriptComplete, 120000);\n \t\tscript.onerror = script.onload = onScriptComplete;\n \t\tfunction onScriptComplete() {\n \t\t\t// avoid mem leaks in IE.\n \t\t\tscript.onerror = script.onload = null;\n \t\t\tclearTimeout(timeout);\n \t\t\tvar chunk = installedChunks[chunkId];\n \t\t\tif(chunk !== 0) {\n \t\t\t\tif(chunk) {\n \t\t\t\t\tchunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));\n \t\t\t\t}\n \t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t}\n \t\t};\n \t\thead.appendChild(script);\n\n \t\treturn promise;\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 12);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8cdb686a67e5601fae6f","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n<script>\n(function() {\n  'use strict';\n\n  const userPolymer = window.Polymer;\n\n  /**\n   * @namespace Polymer\n   * @summary Polymer is a lightweight library built on top of the web\n   *   standards-based Web Components API's, and makes it easy to build your\n   *   own custom HTML elements.\n   * @param {!PolymerInit} info Prototype for the custom element. It must contain\n   *   an `is` property to specify the element name. Other properties populate\n   *   the element prototype. The `properties`, `observers`, `hostAttributes`,\n   *   and `listeners` properties are processed to create element features.\n   * @return {!Object} Returns a custom element class for the given provided\n   *   prototype `info` object. The name of the element if given by `info.is`.\n   */\n  window.Polymer = function(info) {\n    return window.Polymer._polymerFn(info);\n  }\n\n  // support user settings on the Polymer object\n  if (userPolymer) {\n    Object.assign(Polymer, userPolymer);\n  }\n\n  // To be plugged by legacy implementation if loaded\n  /* eslint-disable valid-jsdoc */\n  /**\n   * @param {!PolymerInit} info Prototype for the custom element. It must contain\n   *   an `is` property to specify the element name. Other properties populate\n   *   the element prototype. The `properties`, `observers`, `hostAttributes`,\n   *   and `listeners` properties are processed to create element features.\n   * @return {!Object} Returns a custom element class for the given provided\n   *   prototype `info` object. The name of the element if given by `info.is`.\n   */\n  window.Polymer._polymerFn = function(info) { // eslint-disable-line no-unused-vars\n    throw new Error('Load polymer.html to use the Polymer() function.');\n  }\n  /* eslint-enable */\n\n  window.Polymer.version = '2.0.1';\n\n  /* eslint-disable no-unused-vars */\n  /*\n  When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]\n  We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.\n  */\n  window.JSCompiler_renameProperty = function(prop, obj) {\n    return prop;\n  }\n  /* eslint-enable */\n\n})();\n</script>\n\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/utils/boot.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n\n<link rel=\"import\" href=\"boot.html\">\n\n<script>\n\n(function() {\n\n  'use strict';\n\n  // unique global id for deduping mixins.\n  let dedupeId = 0;\n\n  /**\n   * @constructor\n   * @extends {Function}\n   */\n  function MixinFunction(){}\n  /** @type {(WeakMap | undefined)} */\n  MixinFunction.prototype.__mixinApplications;\n  /** @type {(Object | undefined)} */\n  MixinFunction.prototype.__mixinSet;\n\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Wraps an ES6 class expression mixin such that the mixin is only applied\n   * if it has not already been applied its base argument.  Also memoizes mixin\n   * applications.\n   *\n   * @memberof Polymer\n   * @template T\n   * @param {T} mixin ES6 class expression mixin to wrap\n   * @suppress {invalidCasts}\n   */\n  Polymer.dedupingMixin = function(mixin) {\n    let mixinApplications = /** @type {!MixinFunction} */(mixin).__mixinApplications;\n    if (!mixinApplications) {\n      mixinApplications = new WeakMap();\n      /** @type {!MixinFunction} */(mixin).__mixinApplications = mixinApplications;\n    }\n    // maintain a unique id for each mixin\n    let mixinDedupeId = dedupeId++;\n    function dedupingMixin(base) {\n      let baseSet = /** @type {!MixinFunction} */(base).__mixinSet;\n      if (baseSet && baseSet[mixinDedupeId]) {\n        return base;\n      }\n      let map = mixinApplications;\n      let extended = map.get(base);\n      if (!extended) {\n        extended = /** @type {!Function} */(mixin)(base);\n        map.set(base, extended);\n      }\n      // copy inherited mixin set from the extended class, or the base class\n      // NOTE: we avoid use of Set here because some browser (IE11)\n      // cannot extend a base Set via the constructor.\n      let mixinSet = Object.create(/** @type {!MixinFunction} */(extended).__mixinSet || baseSet || null);\n      mixinSet[mixinDedupeId] = true;\n      /** @type {!MixinFunction} */(extended).__mixinSet = mixinSet;\n      return extended;\n    }\n\n    return dedupingMixin;\n  };\n  /* eslint-enable valid-jsdoc */\n\n})();\n\n</script>\n\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/utils/mixin.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n<link rel=\"import\" href=\"boot.html\">\n\n<script>\n\n  (function() {\n    'use strict';\n\n    let CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\n    let ABS_URL = /(^\\/)|(^#)|(^[\\w-\\d]*:)/;\n    let workingURL;\n    let resolveDoc;\n    /**\n     * Resolves the given URL against the provided `baseUri'.\n     *\n     * @memberof Polymer.ResolveUrl\n     * @param {string} url Input URL to resolve\n     * @param {?string=} baseURI Base URI to resolve the URL against\n     * @return {string} resolved URL\n     */\n    function resolveUrl(url, baseURI) {\n      if (url && ABS_URL.test(url)) {\n        return url;\n      }\n      // Lazy feature detection.\n      if (workingURL === undefined) {\n        workingURL = false;\n        try {\n          const u = new URL('b', 'http://a');\n          u.pathname = 'c%20d';\n          workingURL = (u.href === 'http://a/c%20d');\n        } catch (e) {\n          // silently fail\n        }\n      }\n      if (!baseURI) {\n        baseURI = document.baseURI || window.location.href;\n      }\n      if (workingURL) {\n        return (new URL(url, baseURI)).href;\n      }\n      // Fallback to creating an anchor into a disconnected document.\n      if (!resolveDoc) {\n        resolveDoc = document.implementation.createHTMLDocument('temp');\n        resolveDoc.base = resolveDoc.createElement('base');\n        resolveDoc.head.appendChild(resolveDoc.base);\n        resolveDoc.anchor = resolveDoc.createElement('a');\n        resolveDoc.body.appendChild(resolveDoc.anchor);\n      }\n      resolveDoc.base.href = baseURI;\n      resolveDoc.anchor.href = url;\n      return resolveDoc.anchor.href || url;\n\n    }\n\n    /**\n     * Resolves any relative URL's in the given CSS text against the provided\n     * `ownerDocument`'s `baseURI`.\n     *\n     * @memberof Polymer.ResolveUrl\n     * @param {string} cssText CSS text to process\n     * @param {string} baseURI Base URI to resolve the URL against\n     * @return {string} Processed CSS text with resolved URL's\n     */\n    function resolveCss(cssText, baseURI) {\n      return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {\n        return pre + '\\'' +\n          resolveUrl(url.replace(/[\"']/g, ''), baseURI) +\n          '\\'' + post;\n      });\n    }\n\n    /**\n     * Returns a path from a given `url`. The path includes the trailing\n     * `/` from the url.\n     *\n     * @memberof Polymer.ResolveUrl\n     * @param {string} url Input URL to transform\n     * @return {string} resolved path\n     */\n    function pathFromUrl(url) {\n      return url.substring(0, url.lastIndexOf('/') + 1);\n    }\n\n    /**\n     * Module with utilities for resolving relative URL's.\n     *\n     * @namespace\n     * @memberof Polymer\n     * @summary Module with utilities for resolving relative URL's.\n     */\n    Polymer.ResolveUrl = {\n      resolveCss: resolveCss,\n      resolveUrl: resolveUrl,\n      pathFromUrl: pathFromUrl\n    };\n\n  })();\n\n</script>\n\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/utils/resolve-url.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n<link rel=\"import\" href=\"boot.html\">\n<script>\n(function() {\n  'use strict';\n\n  const caseMap = {};\n  const DASH_TO_CAMEL = /-[a-z]/g;\n  const CAMEL_TO_DASH = /([A-Z])/g;\n\n  /**\n   * Module with utilities for converting between \"dash-case\" and \"camelCase\"\n   * identifiers.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module that provides utilities for converting between \"dash-case\"\n   *   and \"camelCase\".\n   */\n  const CaseMap = {\n\n    /**\n     * Converts \"dash-case\" identifier (e.g. `foo-bar-baz`) to \"camelCase\"\n     * (e.g. `fooBarBaz`).\n     *\n     * @memberof Polymer.CaseMap\n     * @param {string} dash Dash-case identifier\n     * @return {string} Camel-case representation of the identifier\n     */\n    dashToCamelCase(dash) {\n      return caseMap[dash] || (\n        caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL,\n          (m) => m[1].toUpperCase()\n        )\n      );\n    },\n\n    /**\n     * Converts \"camelCase\" identifier (e.g. `fooBarBaz`) to \"dash-case\"\n     * (e.g. `foo-bar-baz`).\n     *\n     * @memberof Polymer.CaseMap\n     * @param {string} camel Camel-case identifier\n     * @return {string} Dash-case representation of the identifier\n     */\n    camelToDashCase(camel) {\n      return caseMap[camel] || (\n        caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase()\n      );\n    }\n\n  };\n\n  Polymer.CaseMap = CaseMap;\n})();\n</script>\n\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/utils/case-map.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n<link rel=\"import\" href=\"boot.html\">\n\n<script>\n(function() {\n\n  'use strict';\n\n  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */\n  let AsyncInterface; // eslint-disable-line no-unused-vars\n\n  // Microtask implemented using Mutation Observer\n  let microtaskCurrHandle = 0;\n  let microtaskLastHandle = 0;\n  let microtaskCallbacks = [];\n  let microtaskNodeContent = 0;\n  let microtaskNode = document.createTextNode('');\n  new window.MutationObserver(microtaskFlush).observe(microtaskNode, {characterData: true});\n\n  function microtaskFlush() {\n    const len = microtaskCallbacks.length;\n    for (let i = 0; i < len; i++) {\n      let cb = microtaskCallbacks[i];\n      if (cb) {\n        try {\n          cb();\n        } catch (e) {\n          setTimeout(() => { throw e });\n        }\n      }\n    }\n    microtaskCallbacks.splice(0, len);\n    microtaskLastHandle += len;\n  }\n\n  /**\n   * Module that provides a number of strategies for enqueuing asynchronous\n   * tasks.  Each sub-module provides a standard `run(fn)` interface that returns a\n   * handle, and a `cancel(handle)` interface for canceling async tasks before\n   * they run.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module that provides a number of strategies for enqueuing asynchronous\n   * tasks.\n   */\n  Polymer.Async = {\n\n    /**\n     * Async interface wrapper around `setTimeout`.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface wrapper around `setTimeout`.\n     */\n    timeOut: {\n      /**\n       * Returns a sub-module with the async interface providing the provided\n       * delay.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {number} delay Time to wait before calling callbacks in ms\n       * @return {AsyncInterface} An async timeout interface\n       */\n      after(delay) {\n        return  {\n          run(fn) { return setTimeout(fn, delay) },\n          cancel: window.clearTimeout.bind(window)\n        }\n      },\n      /**\n       * Enqueues a function called in the next task.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {Function} fn Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run: window.setTimeout.bind(window),\n      /**\n       * Cancels a previously enqueued `timeOut` callback.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel: window.clearTimeout.bind(window)\n    },\n\n    /**\n     * Async interface wrapper around `requestAnimationFrame`.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface wrapper around `requestAnimationFrame`.\n     */\n    animationFrame: {\n      /**\n       * Enqueues a function called at `requestAnimationFrame` timing.\n       *\n       * @memberof Polymer.Async.animationFrame\n       * @param {Function} fn Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run: window.requestAnimationFrame.bind(window),\n      /**\n       * Cancels a previously enqueued `animationFrame` callback.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel: window.cancelAnimationFrame.bind(window)\n    },\n\n    /**\n     * Async interface wrapper around `requestIdleCallback`.  Falls back to\n     * `setTimeout` on browsers that do not support `requestIdleCallback`.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface wrapper around `requestIdleCallback`.\n     */\n    idlePeriod: {\n      /**\n       * Enqueues a function called at `requestIdleCallback` timing.\n       *\n       * @memberof Polymer.Async.idlePeriod\n       * @param {function(IdleDeadline)} fn Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run(fn) {\n        return window.requestIdleCallback ?\n          window.requestIdleCallback(fn) :\n          window.setTimeout(fn, 16);\n      },\n      /**\n       * Cancels a previously enqueued `idlePeriod` callback.\n       *\n       * @memberof Polymer.Async.idlePeriod\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel(handle) {\n        window.cancelIdleCallback ?\n          window.cancelIdleCallback(handle) :\n          window.clearTimeout(handle);\n      }\n    },\n\n    /**\n     * Async interface for enqueueing callbacks that run at microtask timing.\n     *\n     * Note that microtask timing is achieved via a single `MutationObserver`,\n     * and thus callbacks enqueued with this API will all run in a single\n     * batch, and not interleaved with other microtasks such as promises.\n     * Promises are avoided as an implementation choice for the time being\n     * due to Safari bugs that cause Promises to lack microtask guarantees.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface for enqueueing callbacks that run at microtask\n     *   timing.\n     */\n    microTask: {\n\n      /**\n       * Enqueues a function called at microtask timing.\n       *\n       * @memberof Polymer.Async.microTask\n       * @param {Function} callback Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run(callback) {\n        microtaskNode.textContent = microtaskNodeContent++;\n        microtaskCallbacks.push(callback);\n        return microtaskCurrHandle++;\n      },\n\n      /**\n       * Cancels a previously enqueued `microTask` callback.\n       *\n       * @memberof Polymer.Async.microTask\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel(handle) {\n        const idx = handle - microtaskLastHandle;\n        if (idx >= 0) {\n          if (!microtaskCallbacks[idx]) {\n            throw new Error('invalid async handle: ' + handle);\n          }\n          microtaskCallbacks[idx] = null;\n        }\n      }\n\n    }\n  };\n\n})();\n</script>\n\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/utils/async.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n<link rel=\"import\" href=\"lib/mixins/element-mixin.html\">\n<script>\n(function() {\n  'use strict';\n\n  /**\n   * Base class that provides the core API for Polymer's meta-programming\n   * features including template stamping, data-binding, attribute deserialization,\n   * and property change observation.\n   *\n   * @customElement\n   * @polymer\n   * @memberof Polymer\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @extends HTMLElement\n   * @appliesMixin Polymer.ElementMixin\n   * @summary Custom element base class that provides the core API for Polymer's\n   *   key meta-programming features including template stamping, data-binding,\n   *   attribute deserialization, and property change observation\n   */\n  const Element = Polymer.ElementMixin(HTMLElement);\n  /**\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @extends {HTMLElement}\n   */\n  Polymer.Element = Element;\n})();\n</script>\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/polymer-element.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n\n\n<link rel=\"import\" href=\"../utils/boot.html\">\n<link rel=\"import\" href=\"../utils/mixin.html\">\n<link rel=\"import\" href=\"../utils/path.html\">\n<!-- for notify, reflect -->\n<link rel=\"import\" href=\"../utils/case-map.html\">\n<link rel=\"import\" href=\"property-accessors.html\">\n<!-- for annotated effects -->\n<link rel=\"import\" href=\"template-stamp.html\">\n\n\n<script>\n(function() {\n\n  'use strict';\n\n  /** @const {Object} */\n  const CaseMap = Polymer.CaseMap;\n\n  // Monotonically increasing unique ID used for de-duping effects triggered\n  // from multiple properties in the same turn\n  let dedupeId = 0;\n\n  /**\n   * Property effect types; effects are stored on the prototype using these keys\n   * @enum {string}\n   */\n  const TYPES = {\n    COMPUTE: '__computeEffects',\n    REFLECT: '__reflectEffects',\n    NOTIFY: '__notifyEffects',\n    PROPAGATE: '__propagateEffects',\n    OBSERVE: '__observeEffects',\n    READ_ONLY: '__readOnly'\n  }\n\n  /**\n   * @typedef {{\n   * name: (string | undefined),\n   * structured: (boolean | undefined),\n   * wildcard: (boolean | undefined)\n   * }}\n   */\n  let DataTrigger; //eslint-disable-line no-unused-vars\n\n  /**\n   * @typedef {{\n   * info: ?,\n   * trigger: (!DataTrigger | undefined),\n   * fn: (!Function | undefined)\n   * }}\n   */\n  let DataEffect; //eslint-disable-line no-unused-vars\n\n  let PropertyEffectsType; //eslint-disable-line no-unused-vars\n\n  /**\n   * Ensures that the model has an own-property map of effects for the given type.\n   * The model may be a prototype or an instance.\n   *\n   * Property effects are stored as arrays of effects by property in a map,\n   * by named type on the model. e.g.\n   *\n   *   __computeEffects: {\n   *     foo: [ ... ],\n   *     bar: [ ... ]\n   *   }\n   *\n   * If the model does not yet have an effect map for the type, one is created\n   * and returned.  If it does, but it is not an own property (i.e. the\n   * prototype had effects), the the map is deeply cloned and the copy is\n   * set on the model and returned, ready for new effects to be added.\n   *\n   * @param {Object} model Prototype or instance\n   * @param {string} type Property effect type\n   * @return {Object} The own-property map of effects for the given type\n   * @private\n   */\n  function ensureOwnEffectMap(model, type) {\n    let effects = model[type];\n    if (!effects) {\n      effects = model[type] = {};\n    } else if (!model.hasOwnProperty(type)) {\n      effects = model[type] = Object.create(model[type]);\n      for (let p in effects) {\n        let protoFx = effects[p];\n        let instFx = effects[p] = Array(protoFx.length);\n        for (let i=0; i<protoFx.length; i++) {\n          instFx[i] = protoFx[i];\n        }\n      }\n    }\n    return effects;\n  }\n\n  // -- effects ----------------------------------------------\n\n  /**\n   * Runs all effects of a given type for the given set of property changes\n   * on an instance.\n   *\n   * @param {!PropertyEffectsType} inst The instance with effects to run\n   * @param {Object} effects Object map of property-to-Array of effects\n   * @param {Object} props Bag of current property changes\n   * @param {Object=} oldProps Bag of previous values for changed properties\n   * @param {boolean=} hasPaths True with `props` contains one or more paths\n   * @param {*=} extraArgs Additional metadata to pass to effect function\n   * @return {boolean} True if an effect ran for this property\n   * @private\n   */\n  function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n    if (effects) {\n      let ran = false;\n      let id = dedupeId++;\n      for (let prop in props) {\n        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {\n          ran = true;\n        }\n      }\n      return ran;\n    }\n    return false;\n  }\n\n  /**\n   * Runs a list of effects for a given property.\n   *\n   * @param {!PropertyEffectsType} inst The instance with effects to run\n   * @param {Object} effects Object map of property-to-Array of effects\n   * @param {number} dedupeId Counter used for de-duping effects\n   * @param {string} prop Name of changed property\n   * @param {*} props Changed properties\n   * @param {*} oldProps Old properties\n   * @param {boolean=} hasPaths True with `props` contains one or more paths\n   * @param {*=} extraArgs Additional metadata to pass to effect function\n   * @return {boolean} True if an effect ran for this property\n   * @private\n   */\n  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n    let ran = false;\n    let rootProperty = hasPaths ? Polymer.Path.root(prop) : prop;\n    let fxs = effects[rootProperty];\n    if (fxs) {\n      for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {\n        if ((!fx.info || fx.info.lastRun !== dedupeId) &&\n            (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n          if (fx.info) {\n            fx.info.lastRun = dedupeId;\n          }\n          fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n          ran = true;\n        }\n      }\n    }\n    return ran;\n  }\n\n  /**\n   * Determines whether a property/path that has changed matches the trigger\n   * criteria for an effect.  A trigger is a descriptor with the following\n   * structure, which matches the descriptors returned from `parseArg`.\n   * e.g. for `foo.bar.*`:\n   * ```\n   * trigger: {\n   *   name: 'a.b',\n   *   structured: true,\n   *   wildcard: true\n   * }\n   * ```\n   * If no trigger is given, the path is deemed to match.\n   *\n   * @param {string} path Path or property that changed\n   * @param {DataTrigger} trigger Descriptor\n   * @return {boolean} Whether the path matched the trigger\n   */\n  function pathMatchesTrigger(path, trigger) {\n    if (trigger) {\n      let triggerPath = trigger.name;\n      return (triggerPath == path) ||\n        (trigger.structured && Polymer.Path.isAncestor(triggerPath, path)) ||\n        (trigger.wildcard && Polymer.Path.isDescendant(triggerPath, path));\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * Implements the \"observer\" effect.\n   *\n   * Calls the method with `info.methodName` on the instance, passing the\n   * new and old values.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @private\n   */\n  function runObserverEffect(inst, property, props, oldProps, info) {\n    let fn = inst[info.methodName];\n    let changedProp = info.property;\n    if (fn) {\n      fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n    } else if (!info.dynamicFn) {\n      console.warn('observer method `' + info.methodName + '` not defined');\n    }\n  }\n\n  /**\n   * Runs \"notify\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * will dispatch path notification events in the case that the property\n   * changed was a path and the root property for that path didn't have a\n   * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n   * `notify: true` to ensure object sub-property notifications were\n   * sent.\n   *\n   * @param {!PropertyEffectsType} inst The instance with effects to run\n   * @param {Object} notifyProps Bag of properties to notify\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @private\n   */\n  function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n    // Notify\n    let fxs = inst[TYPES.NOTIFY];\n    let notified;\n    let id = dedupeId++;\n    // Try normal notify effects; if none, fall back to try path notification\n    for (let prop in notifyProps) {\n      if (notifyProps[prop]) {\n        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n          notified = true;\n        } else if (hasPaths && notifyPath(inst, prop, props)) {\n          notified = true;\n        }\n      }\n    }\n    // Flush host if we actually notified and host was batching\n    // And the host has already initialized clients; this prevents\n    // an issue with a host observing data changes before clients are ready.\n    let host;\n    if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n      host._invalidateProperties();\n    }\n  }\n\n  /**\n   * Dispatches {property}-changed events with path information in the detail\n   * object to indicate a sub-path of the property was changed.\n   *\n   * @param {!PropertyEffectsType} inst The element from which to fire the event\n   * @param {string} path The path that was changed\n   * @param {Object} props Bag of current property changes\n   * @return {boolean} Returns true if the path was notified\n   * @private\n   */\n  function notifyPath(inst, path, props) {\n    let rootProperty = Polymer.Path.root(path);\n    if (rootProperty !== path) {\n      let eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';\n      dispatchNotifyEvent(inst, eventName, props[path], path);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Dispatches {property}-changed events to indicate a property (or path)\n   * changed.\n   *\n   * @param {!PropertyEffectsType} inst The element from which to fire the event\n   * @param {string} eventName The name of the event to send ('{property}-changed')\n   * @param {*} value The value of the changed property\n   * @param {string | null | undefined} path If a sub-path of this property changed, the path\n   *   that changed (optional).\n   * @private\n   * @suppress {invalidCasts}\n   */\n  function dispatchNotifyEvent(inst, eventName, value, path) {\n    let detail = {\n      value: value,\n      queueProperty: true\n    };\n    if (path) {\n      detail.path = path;\n    }\n    /** @type {!HTMLElement} */(inst).dispatchEvent(new CustomEvent(eventName, { detail }));\n  }\n\n  /**\n   * Implements the \"notify\" effect.\n   *\n   * Dispatches a non-bubbling event named `info.eventName` on the instance\n   * with a detail object containing the new `value`.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @private\n   */\n  function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n    let rootProperty = hasPaths ? Polymer.Path.root(property) : property;\n    let path = rootProperty != property ? property : null;\n    let value = path ? Polymer.Path.get(inst, path) : inst.__data[property];\n    if (path && value === undefined) {\n      value = props[property];  // specifically for .splices\n    }\n    dispatchNotifyEvent(inst, info.eventName, value, path);\n  }\n\n  /**\n   * Handler function for 2-way notification events. Receives context\n   * information captured in the `addNotifyListener` closure from the\n   * `__notifyListeners` metadata.\n   *\n   * Sets the value of the notified property to the host property or path.  If\n   * the event contained path information, translate that path to the host\n   * scope's name for that path first.\n   *\n   * @param {CustomEvent} event Notification event (e.g. '<property>-changed')\n   * @param {!PropertyEffectsType} inst Host element instance handling the notification event\n   * @param {string} fromProp Child element property that was bound\n   * @param {string} toPath Host property/path that was bound\n   * @param {boolean} negate Whether the binding was negated\n   * @private\n   */\n  function handleNotification(event, inst, fromProp, toPath, negate) {\n    let value;\n    let detail = /** @type {Object} */(event.detail);\n    let fromPath = detail && detail.path;\n    if (fromPath) {\n      toPath = Polymer.Path.translate(fromProp, toPath, fromPath);\n      value = detail && detail.value;\n    } else {\n      value = event.target[fromProp];\n    }\n    value = negate ? !value : value;\n    if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {\n      if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath))\n        && (!detail || !detail.queueProperty)) {\n        inst._invalidateProperties();\n      }\n    }\n  }\n\n  /**\n   * Implements the \"reflect\" effect.\n   *\n   * Sets the attribute named `info.attrName` to the given property value.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @private\n   */\n  function runReflectEffect(inst, property, props, oldProps, info) {\n    let value = inst.__data[property];\n    if (Polymer.sanitizeDOMValue) {\n      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */(inst));\n    }\n    inst._propertyToAttribute(property, info.attrName, value);\n  }\n\n  /**\n   * Runs \"computed\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * continues to run computed effects based on the output of each pass until\n   * there are no more newly computed properties.  This ensures that all\n   * properties that will be computed by the initial set of changes are\n   * computed before other effects (binding propagation, observers, and notify)\n   * run.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {!Object} changedProps Bag of changed properties\n   * @param {!Object} oldProps Bag of previous values for changed properties\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @private\n   */\n  function runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n    let computeEffects = inst[TYPES.COMPUTE];\n    if (computeEffects) {\n      let inputProps = changedProps;\n      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n        Object.assign(oldProps, inst.__dataOld);\n        Object.assign(changedProps, inst.__dataPending);\n        inputProps = inst.__dataPending;\n        inst.__dataPending = null;\n      }\n    }\n  }\n\n  /**\n   * Implements the \"computed property\" effect by running the method with the\n   * values of the arguments specified in the `info` object and setting the\n   * return value to the computed property specified.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @private\n   */\n  function runComputedEffect(inst, property, props, oldProps, info) {\n    let result = runMethodEffect(inst, property, props, oldProps, info);\n    let computedProp = info.methodInfo;\n    if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n      inst._setPendingProperty(computedProp, result, true);\n    } else {\n      inst[computedProp] = result;\n    }\n  }\n\n  /**\n   * Computes path changes based on path links set up using the `linkPaths`\n   * API.\n   *\n   * @param {!PropertyEffectsType} inst The instance whose props are changing\n   * @param {string | !Array<(string|number)>} path Path that has changed\n   * @param {*} value Value of changed path\n   * @private\n   */\n  function computeLinkedPaths(inst, path, value) {\n    let links = inst.__dataLinkedPaths;\n    if (links) {\n      let link;\n      for (let a in links) {\n        let b = links[a];\n        if (Polymer.Path.isDescendant(a, path)) {\n          link = Polymer.Path.translate(a, b, path);\n          inst._setPendingPropertyOrPath(link, value, true, true);\n        } else if (Polymer.Path.isDescendant(b, path)) {\n          link = Polymer.Path.translate(b, a, path);\n          inst._setPendingPropertyOrPath(link, value, true, true);\n        }\n      }\n    }\n  }\n\n  // -- bindings ----------------------------------------------\n\n  /**\n   * Adds binding metadata to the current `nodeInfo`, and binding effects\n   * for all part dependencies to `templateInfo`.\n   *\n   * @param {Function} constructor Class that `_parseTemplate` is currently\n   *   running on\n   * @param {TemplateInfo} templateInfo Template metadata for current template\n   * @param {NodeInfo} nodeInfo Node metadata for current template node\n   * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n   * @param {string} target Target property name\n   * @param {!Array<!BindingPart>} parts Array of binding part metadata\n   * @param {string=} literal Literal text surrounding binding parts (specified\n   *   only for 'property' bindings, since these must be initialized as part\n   *   of boot-up)\n   * @private\n   */\n  function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n    // Create binding metadata and add to nodeInfo\n    nodeInfo.bindings = nodeInfo.bindings || [];\n    let /** Binding */ binding = { kind, target, parts, literal, isCompound: (parts.length !== 1) };\n    nodeInfo.bindings.push(binding);\n    // Add listener info to binding metadata\n    if (shouldAddListener(binding)) {\n      let {event, negate} = binding.parts[0];\n      binding.listenerEvent = event || (CaseMap.camelToDashCase(target) + '-changed');\n      binding.listenerNegate = negate;\n    }\n    // Add \"propagate\" property effects to templateInfo\n    let index = templateInfo.nodeInfoList.length;\n    for (let i=0; i<binding.parts.length; i++) {\n      let part = binding.parts[i];\n      part.compoundIndex = i;\n      addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n    }\n  }\n\n  /**\n   * Adds property effects to the given `templateInfo` for the given binding\n   * part.\n   *\n   * @param {Function} constructor Class that `_parseTemplate` is currently\n   *   running on\n   * @param {TemplateInfo} templateInfo Template metadata for current template\n   * @param {!Binding} binding Binding metadata\n   * @param {!BindingPart} part Binding part metadata\n   * @param {number} index Index into `nodeInfoList` for this node\n   */\n  function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n    if (!part.literal) {\n      if (binding.kind === 'attribute' && binding.target[0] === '-') {\n        console.warn('Cannot set attribute ' + binding.target +\n          ' because \"-\" is not a valid attribute starting character');\n      } else {\n        let dependencies = part.dependencies;\n        let info = { index, binding, part, evaluator: constructor };\n        for (let j=0; j<dependencies.length; j++) {\n          let trigger = dependencies[j];\n          if (typeof trigger == 'string') {\n            trigger = parseArg(trigger);\n            trigger.wildcard = true;\n          }\n          constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n            fn: runBindingEffect,\n            info, trigger\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Implements the \"binding\" (property/path binding) effect.\n   *\n   * Note that binding syntax is overridable via `_parseBindings` and\n   * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n   * non-literal parts returned from `_parseBindings`.  However,\n   * there is no support for _path_ bindings via custom binding parts,\n   * as this is specific to Polymer's path binding syntax.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} path Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n   *   metadata\n   * @private\n   */\n  function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n    let node = nodeList[info.index];\n    let binding = info.binding;\n    let part = info.part;\n    // Subpath notification: transform path and set to client\n    // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n    if (hasPaths && part.source && (path.length > part.source.length) &&\n        (binding.kind == 'property') && !binding.isCompound &&\n        node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n      let value = props[path];\n      path = Polymer.Path.translate(part.source, binding.target, path);\n      if (node._setPendingPropertyOrPath(path, value, false, true)) {\n        inst._enqueueClient(node);\n      }\n    } else {\n      let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);\n      // Propagate value to child\n      applyBindingValue(inst, node, binding, part, value);\n    }\n  }\n\n  /**\n   * Sets the value for an \"binding\" (binding) effect to a node,\n   * either as a property or attribute.\n   *\n   * @param {!PropertyEffectsType} inst The instance owning the binding effect\n   * @param {Node} node Target node for binding\n   * @param {!Binding} binding Binding metadata\n   * @param {!BindingPart} part Binding part metadata\n   * @param {*} value Value to set\n   * @private\n   */\n  function applyBindingValue(inst, node, binding, part, value) {\n    value = computeBindingValue(node, value, binding, part);\n    if (Polymer.sanitizeDOMValue) {\n      value = Polymer.sanitizeDOMValue(value, binding.target, binding.kind, node);\n    }\n    if (binding.kind == 'attribute') {\n      // Attribute binding\n      inst._valueToNodeAttribute(/** @type {Element} */(node), value, binding.target);\n    } else {\n      // Property binding\n      let prop = binding.target;\n      if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n        if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {\n          if (node._setPendingProperty(prop, value)) {\n            inst._enqueueClient(node);\n          }\n        }\n      } else  {\n        inst._setUnmanagedPropertyToNode(node, prop, value);\n      }\n    }\n  }\n\n  /**\n   * Transforms an \"binding\" effect value based on compound & negation\n   * effect metadata, as well as handling for special-case properties\n   *\n   * @param {Node} node Node the value will be set to\n   * @param {*} value Value to set\n   * @param {!Binding} binding Binding metadata\n   * @param {!BindingPart} part Binding part metadata\n   * @return {*} Transformed value to set\n   * @private\n   */\n  function computeBindingValue(node, value, binding, part) {\n    if (binding.isCompound) {\n      let storage = node.__dataCompoundStorage[binding.target];\n      storage[part.compoundIndex] = value;\n      value = storage.join('');\n    }\n    if (binding.kind !== 'attribute') {\n      // Some browsers serialize `undefined` to `\"undefined\"`\n      if (binding.target === 'textContent' ||\n          (node.localName == 'input' && binding.target == 'value')) {\n        value = value == undefined ? '' : value;\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Returns true if a binding's metadata meets all the requirements to allow\n   * 2-way binding, and therefore a `<property>-changed` event listener should be\n   * added:\n   * - used curly braces\n   * - is a property (not attribute) binding\n   * - is not a textContent binding\n   * - is not compound\n   *\n   * @param {!Binding} binding Binding metadata\n   * @return {boolean} True if 2-way listener should be added\n   * @private\n   */\n  function shouldAddListener(binding) {\n    return Boolean(binding.target) &&\n           binding.kind != 'attribute' &&\n           binding.kind != 'text' &&\n           !binding.isCompound &&\n           binding.parts[0].mode === '{';\n  }\n\n  /**\n   * Setup compound binding storage structures, notify listeners, and dataHost\n   * references onto the bound nodeList.\n   *\n   * @param {!PropertyEffectsType} inst Instance that bas been previously bound\n   * @param {TemplateInfo} templateInfo Template metadata\n   * @private\n   */\n  function setupBindings(inst, templateInfo) {\n    // Setup compound storage, dataHost, and notify listeners\n    let {nodeList, nodeInfoList} = templateInfo;\n    if (nodeInfoList.length) {\n      for (let i=0; i < nodeInfoList.length; i++) {\n        let info = nodeInfoList[i];\n        let node = nodeList[i];\n        let bindings = info.bindings;\n        if (bindings) {\n          for (let i=0; i<bindings.length; i++) {\n            let binding = bindings[i];\n            setupCompoundStorage(node, binding);\n            addNotifyListener(node, inst, binding);\n          }\n        }\n        node.__dataHost = inst;\n      }\n    }\n  }\n\n  /**\n   * Initializes `__dataCompoundStorage` local storage on a bound node with\n   * initial literal data for compound bindings, and sets the joined\n   * literal parts to the bound property.\n   *\n   * When changes to compound parts occur, they are first set into the compound\n   * storage array for that property, and then the array is joined to result in\n   * the final value set to the property/attribute.\n   *\n   * @param {Node} node Bound node to initialize\n   * @param {Binding} binding Binding metadata\n   * @private\n   */\n  function setupCompoundStorage(node, binding) {\n    if (binding.isCompound) {\n      // Create compound storage map\n      let storage = node.__dataCompoundStorage ||\n        (node.__dataCompoundStorage = {});\n      let parts = binding.parts;\n      // Copy literals from parts into storage for this binding\n      let literals = new Array(parts.length);\n      for (let j=0; j<parts.length; j++) {\n        literals[j] = parts[j].literal;\n      }\n      let target = binding.target;\n      storage[target] = literals;\n      // Configure properties with their literal parts\n      if (binding.literal && binding.kind == 'property') {\n        node[target] = binding.literal;\n      }\n    }\n  }\n\n  /**\n   * Adds a 2-way binding notification event listener to the node specified\n   *\n   * @param {Object} node Child element to add listener to\n   * @param {!PropertyEffectsType} inst Host element instance to handle notification event\n   * @param {Binding} binding Binding metadata\n   * @private\n   */\n  function addNotifyListener(node, inst, binding) {\n    if (binding.listenerEvent) {\n      let part = binding.parts[0];\n      node.addEventListener(binding.listenerEvent, function(e) {\n        handleNotification(e, inst, binding.target, part.source, part.negate);\n      });\n    }\n  }\n\n  // -- for method-based effects (complexObserver & computed) --------------\n\n  /**\n   * Adds property effects for each argument in the method signature (and\n   * optionally, for the method name if `dynamic` is true) that calls the\n   * provided effect function.\n   *\n   * @param {Element | Object} model Prototype or instance\n   * @param {!MethodSignature} sig Method signature metadata\n   * @param {string} type Type of property effect to add\n   * @param {Function} effectFn Function to run when arguments change\n   * @param {*=} methodInfo Effect-specific information to be included in\n   *   method effect metadata\n   * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n   *   method names should be included as a dependency to the effect. Note,\n   *   defaults to true if the signature is static (sig.static is true).\n   * @private\n   */\n  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n    dynamicFn = sig.static || (dynamicFn &&\n      (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]));\n    let info = {\n      methodName: sig.methodName,\n      args: sig.args,\n      methodInfo,\n      dynamicFn\n    };\n    for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {\n      if (!arg.literal) {\n        model._addPropertyEffect(arg.rootProperty, type, {\n          fn: effectFn, info: info, trigger: arg\n        });\n      }\n    }\n    if (dynamicFn) {\n      model._addPropertyEffect(sig.methodName, type, {\n        fn: effectFn, info: info\n      });\n    }\n  }\n\n  /**\n   * Calls a method with arguments marshaled from properties on the instance\n   * based on the method signature contained in the effect metadata.\n   *\n   * Multi-property observers, computed properties, and inline computing\n   * functions call this function to invoke the method, then use the return\n   * value accordingly.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @return {*} Returns the return value from the method invocation\n   * @private\n   */\n  function runMethodEffect(inst, property, props, oldProps, info) {\n    // Instances can optionally have a _methodHost which allows redirecting where\n    // to find methods. Currently used by `templatize`.\n    let context = inst._methodHost || inst;\n    let fn = context[info.methodName];\n    if (fn) {\n      let args = marshalArgs(inst.__data, info.args, property, props);\n      return fn.apply(context, args);\n    } else if (!info.dynamicFn) {\n      console.warn('method `' + info.methodName + '` not defined');\n    }\n  }\n\n  const emptyArray = [];\n\n  // Regular expressions used for binding\n  const IDENT  = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\n  const NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\n  const SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\n  const DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\n  const STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\n  const ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' +  STRING + ')\\\\s*' + ')';\n  const ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\n  const ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' +\n                                '(?:' + ARGUMENTS + '?' + ')' +\n                              '\\\\)\\\\s*' + ')';\n  const BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\n  const OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\n  const CLOSE_BRACKET = '(?:]]|}})';\n  const NEGATE = '(?:(!)\\\\s*)?'; // Group 2\n  const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\n  const bindingRegex = new RegExp(EXPRESSION, \"g\");\n\n  /**\n   * Create a string from binding parts of all the literal parts\n   *\n   * @param {!Array<BindingPart>} parts All parts to stringify\n   * @return {string} String made from the literal parts\n   */\n  function literalFromParts(parts) {\n    let s = '';\n    for (let i=0; i<parts.length; i++) {\n      let literal = parts[i].literal;\n      s += literal || '';\n    }\n    return s;\n  }\n\n  /**\n   * Parses an expression string for a method signature, and returns a metadata\n   * describing the method in terms of `methodName`, `static` (whether all the\n   * arguments are literals), and an array of `args`\n   *\n   * @param {string} expression The expression to parse\n   * @return {?MethodSignature} The method metadata object if a method expression was\n   *   found, otherwise `undefined`\n   * @private\n   */\n  function parseMethod(expression) {\n    // tries to match valid javascript property names\n    let m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n    if (m) {\n      let methodName = m[1];\n      let sig = { methodName, static: true, args: emptyArray };\n      if (m[2].trim()) {\n        // replace escaped commas with comma entity, split on un-escaped commas\n        let args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n        return parseArgs(args, sig);\n      } else {\n        return sig;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Parses an array of arguments and sets the `args` property of the supplied\n   * signature metadata object. Sets the `static` property to false if any\n   * argument is a non-literal.\n   *\n   * @param {!Array<string>} argList Array of argument names\n   * @param {!MethodSignature} sig Method signature metadata object\n   * @return {!MethodSignature} The updated signature metadata object\n   * @private\n   */\n  function parseArgs(argList, sig) {\n    sig.args = argList.map(function(rawArg) {\n      let arg = parseArg(rawArg);\n      if (!arg.literal) {\n        sig.static = false;\n      }\n      return arg;\n    }, this);\n    return sig;\n  }\n\n  /**\n   * Parses an individual argument, and returns an argument metadata object\n   * with the following fields:\n   *\n   *   {\n   *     value: 'prop',        // property/path or literal value\n   *     literal: false,       // whether argument is a literal\n   *     structured: false,    // whether the property is a path\n   *     rootProperty: 'prop', // the root property of the path\n   *     wildcard: false       // whether the argument was a wildcard '.*' path\n   *   }\n   *\n   * @param {string} rawArg The string value of the argument\n   * @return {!MethodArg} Argument metadata object\n   * @private\n   */\n  function parseArg(rawArg) {\n    // clean up whitespace\n    let arg = rawArg.trim()\n      // replace comma entity with comma\n      .replace(/&comma;/g, ',')\n      // repair extra escape sequences; note only commas strictly need\n      // escaping, but we allow any other char to be escaped since its\n      // likely users will do this\n      .replace(/\\\\(.)/g, '\\$1')\n      ;\n    // basic argument descriptor\n    let a = {\n      name: arg,\n      value: '',\n      literal: false\n    };\n    // detect literal value (must be String or Number)\n    let fc = arg[0];\n    if (fc === '-') {\n      fc = arg[1];\n    }\n    if (fc >= '0' && fc <= '9') {\n      fc = '#';\n    }\n    switch(fc) {\n      case \"'\":\n      case '\"':\n        a.value = arg.slice(1, -1);\n        a.literal = true;\n        break;\n      case '#':\n        a.value = Number(arg);\n        a.literal = true;\n        break;\n    }\n    // if not literal, look for structured path\n    if (!a.literal) {\n      a.rootProperty = Polymer.Path.root(arg);\n      // detect structured path (has dots)\n      a.structured = Polymer.Path.isPath(arg);\n      if (a.structured) {\n        a.wildcard = (arg.slice(-2) == '.*');\n        if (a.wildcard) {\n          a.name = arg.slice(0, -2);\n        }\n      }\n    }\n    return a;\n  }\n\n  /**\n   * Gather the argument values for a method specified in the provided array\n   * of argument metadata.\n   *\n   * The `path` and `value` arguments are used to fill in wildcard descriptor\n   * when the method is being called as a result of a path notification.\n   *\n   * @param {Object} data Instance data storage object to read properties from\n   * @param {!Array<!MethodArg>} args Array of argument metadata\n   * @param {string} path Property/path name that triggered the method effect\n   * @param {Object} props Bag of current property changes\n   * @return {Array<*>} Array of argument values\n   * @private\n   */\n  function marshalArgs(data, args, path, props) {\n    let values = [];\n    for (let i=0, l=args.length; i<l; i++) {\n      let arg = args[i];\n      let name = arg.name;\n      let v;\n      if (arg.literal) {\n        v = arg.value;\n      } else {\n        if (arg.structured) {\n          v = Polymer.Path.get(data, name);\n          // when data is not stored e.g. `splices`\n          if (v === undefined) {\n            v = props[name];\n          }\n        } else {\n          v = data[name];\n        }\n      }\n      if (arg.wildcard) {\n        // Only send the actual path changed info if the change that\n        // caused the observer to run matched the wildcard\n        let baseChanged = (name.indexOf(path + '.') === 0);\n        let matches = (path.indexOf(name) === 0 && !baseChanged);\n        values[i] = {\n          path: matches ? path : name,\n          value: matches ? props[path] : v,\n          base: v\n        };\n      } else {\n        values[i] = v;\n      }\n    }\n    return values;\n  }\n\n  // data api\n\n  /**\n   * Sends array splice notifications (`.splices` and `.length`)\n   *\n   * Note: this implementation only accepts normalized paths\n   *\n   * @param {!PropertyEffectsType} inst Instance to send notifications to\n   * @param {Array} array The array the mutations occurred on\n   * @param {string} path The path to the array that was mutated\n   * @param {Array} splices Array of splice records\n   * @private\n   */\n  function notifySplices(inst, array, path, splices) {\n    let splicesPath = path + '.splices';\n    inst.notifyPath(splicesPath, { indexSplices: splices });\n    inst.notifyPath(path + '.length', array.length);\n    // Null here to allow potentially large splice records to be GC'ed.\n    inst.__data[splicesPath] = {indexSplices: null};\n  }\n\n  /**\n   * Creates a splice record and sends an array splice notification for\n   * the described mutation\n   *\n   * Note: this implementation only accepts normalized paths\n   *\n   * @param {!PropertyEffectsType} inst Instance to send notifications to\n   * @param {Array} array The array the mutations occurred on\n   * @param {string} path The path to the array that was mutated\n   * @param {number} index Index at which the array mutation occurred\n   * @param {number} addedCount Number of added items\n   * @param {Array} removed Array of removed items\n   * @private\n   */\n  function notifySplice(inst, array, path, index, addedCount, removed) {\n    notifySplices(inst, array, path, [{\n      index: index,\n      addedCount: addedCount,\n      removed: removed,\n      object: array,\n      type: 'splice'\n    }]);\n  }\n\n  /**\n   * Returns an upper-cased version of the string.\n   *\n   * @param {string} name String to uppercase\n   * @return {string} Uppercased string\n   * @private\n   */\n  function upper(name) {\n    return name[0].toUpperCase() + name.substring(1);\n  }\n\n  /**\n   * Element class mixin that provides meta-programming for Polymer's template\n   * binding and data observation (collectively, \"property effects\") system.\n   *\n   * This mixin uses provides the following key static methods for adding\n   * property effects to an element class:\n   * - `addPropertyEffect`\n   * - `createPropertyObserver`\n   * - `createMethodObserver`\n   * - `createNotifyingProperty`\n   * - `createReadOnlyProperty`\n   * - `createReflectedProperty`\n   * - `createComputedProperty`\n   * - `bindTemplate`\n   *\n   * Each method creates one or more property accessors, along with metadata\n   * used by this mixin's implementation of `_propertiesChanged` to perform\n   * the property effects.\n   *\n   * Underscored versions of the above methods also exist on the element\n   * prototype for adding property effects on instances at runtime.\n   *\n   * Note that this mixin overrides several `PropertyAccessors` methods, in\n   * many cases to maintain guarantees provided by the Polymer 1.x features;\n   * notably it changes property accessors to be synchronous by default\n   * whereas the default when using `PropertyAccessors` standalone is to be\n   * async by default.\n   *\n   * @mixinFunction\n   * @polymer\n   * @appliesMixin Polymer.TemplateStamp\n   * @appliesMixin Polymer.PropertyAccessors\n   * @memberof Polymer\n   * @summary Element class mixin that provides meta-programming for Polymer's\n   * template binding and data observation system.\n   */\n  Polymer.PropertyEffects = Polymer.dedupingMixin(superClass => {\n\n    /**\n     * @constructor\n     * @extends {superClass}\n     * @implements {Polymer_PropertyAccessors}\n     * @implements {Polymer_TemplateStamp}\n     * @unrestricted\n     */\n    const propertyEffectsBase = Polymer.TemplateStamp(Polymer.PropertyAccessors(superClass));\n\n    /**\n     * @polymer\n     * @mixinClass\n     * @implements {Polymer_PropertyEffects}\n     * @extends {propertyEffectsBase}\n     * @unrestricted\n     */\n    class PropertyEffects extends propertyEffectsBase {\n\n      constructor() {\n        super();\n        /** @type {boolean} */\n        this.__dataClientsReady;\n        /** @type {Array} */\n        this.__dataPendingClients;\n        /** @type {Object} */\n        this.__dataToNotify;\n        /** @type {Object} */\n        this.__dataLinkedPaths;\n        /** @type {boolean} */\n        this.__dataHasPaths;\n        /** @type {Object} */\n        this.__dataCompoundStorage;\n        /** @type {Polymer_PropertyEffects} */\n        this.__dataHost;\n        /** @type {!Object} */\n        this.__dataTemp;\n        /** @type {boolean} */\n        this.__dataClientsInitialized;\n        /** @type {!Object} */\n        this.__data;\n        /** @type {!Object} */\n        this.__dataPending;\n        /** @type {!Object} */\n        this.__dataOld;\n        /** @type {Object} */\n        this.__computeEffects;\n        /** @type {Object} */\n        this.__reflectEffects;\n        /** @type {Object} */\n        this.__notifyEffects;\n        /** @type {Object} */\n        this.__propagateEffects;\n        /** @type {Object} */\n        this.__observeEffects;\n        /** @type {Object} */\n        this.__readOnly;\n        /** @type {number} */\n        this.__dataCounter;\n        /** @type {!TemplateInfo} */\n        this.__templateInfo;\n      }\n\n      get PROPERTY_EFFECT_TYPES() {\n        return TYPES;\n      }\n\n      _initializeProperties() {\n        super._initializeProperties();\n        hostStack.registerHost(this);\n        this.__dataClientsReady = false;\n        this.__dataPendingClients = null;\n        this.__dataToNotify = null;\n        this.__dataLinkedPaths = null;\n        this.__dataHasPaths = false;\n        // May be set on instance prior to upgrade\n        this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n        this.__dataHost = this.__dataHost || null;\n        this.__dataTemp = {};\n        this.__dataClientsInitialized = false;\n      }\n\n      /**\n       * Overrides `Polymer.PropertyAccessors` implementation to provide a\n       * more efficient implementation of initializing properties from\n       * the prototype on the instance.\n       *\n       * @override\n       * @param {Object} props Properties to initialize on the prototype\n       */\n      _initializeProtoProperties(props) {\n        this.__data = Object.create(props);\n        this.__dataPending = Object.create(props);\n        this.__dataOld = {};\n      }\n\n      /**\n       * Overrides `Polymer.PropertyAccessors` implementation to avoid setting\n       * `_setProperty`'s `shouldNotify: true`.\n       *\n       * @override\n       * @param {Object} props Properties to initialize on the instance\n       */\n      _initializeInstanceProperties(props) {\n        let readOnly = this[TYPES.READ_ONLY];\n        for (let prop in props) {\n          if (!readOnly || !readOnly[prop]) {\n            this.__dataPending = this.__dataPending || {};\n            this.__dataOld = this.__dataOld || {};\n            this.__data[prop] = this.__dataPending[prop] = props[prop];\n          }\n        }\n      }\n\n      // Prototype setup ----------------------------------------\n\n      /**\n       * Equivalent to static `addPropertyEffect` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @protected\n       */\n      _addPropertyEffect(property, type, effect) {\n        this._createPropertyAccessor(property, type == TYPES.READ_ONLY);\n        // effects are accumulated into arrays per property based on type\n        let effects = ensureOwnEffectMap(this, type)[property];\n        if (!effects) {\n          effects = this[type][property] = [];\n        }\n        effects.push(effect);\n      }\n\n      /**\n       * Removes the given property effect.\n       *\n       * @param {string} property Property the effect was associated with\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object to remove\n       */\n      _removePropertyEffect(property, type, effect) {\n        let effects = ensureOwnEffectMap(this, type)[property];\n        let idx = effects.indexOf(effect);\n        if (idx >= 0) {\n          effects.splice(idx, 1);\n        }\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a property effect\n       * of a certain type.\n       *\n       * @param {string} property Property name\n       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasPropertyEffect(property, type) {\n        let effects = this[type];\n        return Boolean(effects && effects[property]);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"read only\"\n       * accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasReadOnlyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"notify\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasNotifyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.NOTIFY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"reflect to attribute\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasReflectEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.REFLECT);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"computed\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasComputedEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.COMPUTE);\n      }\n\n      // Runtime ----------------------------------------\n\n      /**\n       * Sets a pending property or path.  If the root property of the path in\n       * question had no accessor, the path is set, otherwise it is enqueued\n       * via `_setPendingProperty`.\n       *\n       * This function isolates relatively expensive functionality necessary\n       * for the public API (`set`, `setProperties`, `notifyPath`, and property\n       * change listeners via {{...}} bindings), such that it is only done\n       * when paths enter the system, and not at every propagation step.  It\n       * also sets a `__dataHasPaths` flag on the instance which is used to\n       * fast-path slower path-matching code in the property effects host paths.\n       *\n       * `path` can be a path string or array of path parts as accepted by the\n       * public API.\n       *\n       * @param {string | !Array<number|string>} path Path to set\n       * @param {*} value Value to set\n       * @param {boolean=} shouldNotify Set to true if this change should\n       *  cause a property notification event dispatch\n       * @param {boolean=} isPathNotification If the path being set is a path\n       *   notification of an already changed value, as opposed to a request\n       *   to set and notify the change.  In the latter `false` case, a dirty\n       *   check is performed and then the value is set to the path before\n       *   enqueuing the pending property change.\n       * @return {boolean} Returns true if the property/path was enqueued in\n       *   the pending changes bag.\n       * @protected\n       */\n      _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n        if (isPathNotification ||\n            Polymer.Path.root(Array.isArray(path) ? path[0] : path) !== path) {\n          // Dirty check changes being set to a path against the actual object,\n          // since this is the entry point for paths into the system; from here\n          // the only dirty checks are against the `__dataTemp` cache to prevent\n          // duplicate work in the same turn only. Note, if this was a notification\n          // of a change already set to a path (isPathNotification: true),\n          // we always let the change through and skip the `set` since it was\n          // already dirty checked at the point of entry and the underlying\n          // object has already been updated\n          if (!isPathNotification) {\n            let old = Polymer.Path.get(this, path);\n            path = /** @type {string} */ (Polymer.Path.set(this, path, value));\n            // Use property-accessor's simpler dirty check\n            if (!path || !super._shouldPropertyChange(path, value, old)) {\n              return false;\n            }\n          }\n          this.__dataHasPaths = true;\n          if (this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify)) {\n            computeLinkedPaths(this, path, value);\n            return true;\n          }\n        } else {\n          if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n            return this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify);\n          } else {\n            this[path] = value;\n          }\n        }\n        return false;\n      }\n\n      /**\n       * Applies a value to a non-Polymer element/node's property.\n       *\n       * The implementation makes a best-effort at binding interop:\n       * Some native element properties have side-effects when\n       * re-setting the same value (e.g. setting `<input>.value` resets the\n       * cursor position), so we do a dirty-check before setting the value.\n       * However, for better interop with non-Polymer custom elements that\n       * accept objects, we explicitly re-set object changes coming from the\n       * Polymer world (which may include deep object changes without the\n       * top reference changing), erring on the side of providing more\n       * information.\n       *\n       * Users may override this method to provide alternate approaches.\n       *\n       * @param {Node} node The node to set a property on\n       * @param {string} prop The property to set\n       * @param {*} value The value to set\n       * @protected\n       */\n      _setUnmanagedPropertyToNode(node, prop, value) {\n        // It is a judgment call that resetting primitives is\n        // \"bad\" and resettings objects is also \"good\"; alternatively we could\n        // implement a whitelist of tag & property values that should never\n        // be reset (e.g. <input>.value && <select>.value)\n        if (value !== node[prop] || typeof value == 'object') {\n          node[prop] = value;\n        }\n      }\n\n      /**\n       * Overrides the `PropertyAccessors` implementation to introduce special\n       * dirty check logic depending on the property & value being set:\n       *\n       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n       * 2. Object set to simple property (e.g. 'prop': {...})\n       *    Stored in `__dataTemp` and `__data`, dirty checked against\n       *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n       * 3. Primitive value set to simple property (e.g. 'prop': 42)\n       *    Stored in `__data`, dirty checked against `__data`\n       *\n       * The dirty-check is important to prevent cycles due to two-way\n       * notification, but paths and objects are only dirty checked against any\n       * previous value set during this turn via a \"temporary cache\" that is\n       * cleared when the last `_propertiesChaged` exits. This is so:\n       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n       *    due to array mutations like shift/unshift/splice; this is fine\n       *    since path changes are dirty-checked at user entry points like `set`\n       * b. dirty-checking for objects only lasts one turn to allow the user\n       *    to mutate the object in-place and re-set it with the same identity\n       *    and have all sub-properties re-propagated in a subsequent turn.\n       *\n       * The temp cache is not necessarily sufficient to prevent invalid array\n       * paths, since a splice can happen during the same turn (with pathological\n       * user code); we could introduce a \"fixup\" for temporarily cached array\n       * paths if needed: https://github.com/Polymer/polymer/issues/4227\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @param {boolean=} shouldNotify True if property should fire notification\n       *   event (applies only for `notify: true` properties)\n       * @return {boolean} Returns true if the property changed\n       * @override\n       */\n      _setPendingProperty(property, value, shouldNotify) {\n        let isPath = this.__dataHasPaths && Polymer.Path.isPath(property);\n        let prevProps = isPath ? this.__dataTemp : this.__data;\n        if (this._shouldPropertyChange(property, value, prevProps[property])) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (!(property in this.__dataOld)) {\n            this.__dataOld[property] = this.__data[property];\n          }\n          // Paths are stored in temporary cache (cleared at end of turn),\n          // which is used for dirty-checking, all others stored in __data\n          if (isPath) {\n            this.__dataTemp[property] = value;\n          } else {\n            this.__data[property] = value;\n          }\n          // All changes go into pending property bag, passed to _propertiesChanged\n          this.__dataPending[property] = value;\n          // Track properties that should notify separately\n          if (isPath || (this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property])) {\n            this.__dataToNotify = this.__dataToNotify || {};\n            this.__dataToNotify[property] = shouldNotify;\n          }\n          return true;\n        }\n        return false;\n      }\n\n      /**\n       * Overrides base implementation to ensure all accessors set `shouldNotify`\n       * to true, for per-property notification tracking.\n       *\n       * @override\n       */\n      _setProperty(property, value) {\n        if (this._setPendingProperty(property, value, true)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Overrides `PropertyAccessor`'s default async queuing of\n       * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n       * manually flushed), the function no-ops; otherwise flushes\n       * `_propertiesChanged` synchronously.\n       *\n       * @override\n       */\n      _invalidateProperties() {\n        if (this.__dataReady) {\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Enqueues the given client on a list of pending clients, whose\n       * pending property changes can later be flushed via a call to\n       * `_flushClients`.\n       *\n       * @param {Object} client PropertyEffects client to enqueue\n       * @protected\n       */\n      _enqueueClient(client) {\n        this.__dataPendingClients = this.__dataPendingClients || [];\n        if (client !== this) {\n          this.__dataPendingClients.push(client);\n        }\n      }\n\n      /**\n       * Flushes any clients previously enqueued via `_enqueueClient`, causing\n       * their `_flushProperties` method to run.\n       *\n       * @protected\n       */\n      _flushClients() {\n        if (!this.__dataClientsReady) {\n          this.__dataClientsReady = true;\n          this._readyClients();\n          // Override point where accessors are turned on; importantly,\n          // this is after clients have fully readied, providing a guarantee\n          // that any property effects occur only after all clients are ready.\n          this.__dataReady = true;\n        } else {\n          this.__enableOrFlushClients();\n        }\n      }\n\n      // NOTE: We ensure clients either enable or flush as appropriate. This\n      // handles two corner cases:\n      // (1) clients flush properly when connected/enabled before the host\n      // enables; e.g.\n      //   (a) Templatize stamps with no properties and does not flush and\n      //   (b) the instance is inserted into dom and\n      //   (c) then the instance flushes.\n      // (2) clients enable properly when not connected/enabled when the host\n      // flushes; e.g.\n      //   (a) a template is runtime stamped and not yet connected/enabled\n      //   (b) a host sets a property, causing stamped dom to flush\n      //   (c) the stamped dom enables.\n      __enableOrFlushClients() {\n        let clients = this.__dataPendingClients;\n        if (clients) {\n          this.__dataPendingClients = null;\n          for (let i=0; i < clients.length; i++) {\n            let client = clients[i];\n            if (!client.__dataEnabled) {\n              client._enableProperties();\n            } else if (client.__dataPending) {\n              client._flushProperties();\n            }\n          }\n        }\n      }\n\n      /**\n       * Perform any initial setup on client dom. Called before the first\n       * `_flushProperties` call on client dom and before any element\n       * observers are called.\n       *\n       * @protected\n       */\n      _readyClients() {\n        this.__enableOrFlushClients();\n      }\n\n      /**\n       * Sets a bag of property changes to this instance, and\n       * synchronously processes all effects of the properties as a batch.\n       *\n       * Property names must be simple properties, not paths.  Batched\n       * path propagation is not supported.\n       *\n       * @param {Object} props Bag of one or more key-value pairs whose key is\n       *   a property and value is the new value to set for that property.\n       * @param {boolean=} setReadOnly When true, any private values set in\n       *   `props` will be set. By default, `setProperties` will not set\n       *   `readOnly: true` root properties.\n       * @public\n       */\n      setProperties(props, setReadOnly) {\n        for (let path in props) {\n          if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {\n            //TODO(kschaaf): explicitly disallow paths in setProperty?\n            // wildcard observers currently only pass the first changed path\n            // in the `info` object, and you could do some odd things batching\n            // paths, e.g. {'foo.bar': {...}, 'foo': null}\n            this._setPendingPropertyOrPath(path, props[path], true);\n          }\n        }\n        this._invalidateProperties();\n      }\n\n      /**\n       * Overrides `PropertyAccessors` so that property accessor\n       * side effects are not enabled until after client dom is fully ready.\n       * Also calls `_flushClients` callback to ensure client dom is enabled\n       * that was not enabled as a result of flushing properties.\n       *\n       * @override\n       */\n      ready() {\n        // It is important that `super.ready()` is not called here as it\n        // immediately turns on accessors. Instead, we wait until `readyClients`\n        // to enable accessors to provide a guarantee that clients are ready\n        // before processing any accessors side effects.\n        this._flushProperties();\n        // If no data was pending, `_flushProperties` will not `flushClients`\n        // so ensure this is done.\n        if (!this.__dataClientsReady) {\n          this._flushClients();\n        }\n        // Before ready, client notifications do not trigger _flushProperties.\n        // Therefore a flush is necessary here if data has been set.\n        if (this.__dataPending) {\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Implements `PropertyAccessors`'s properties changed callback.\n       *\n       * Runs each class of effects for the batch of changed properties in\n       * a specific order (compute, propagate, reflect, observe, notify).\n       *\n       * @override\n       */\n      _propertiesChanged(currentProps, changedProps, oldProps) {\n        // ----------------------------\n        // let c = Object.getOwnPropertyNames(changedProps || {});\n        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n        // if (window.debug) { debugger; }\n        // ----------------------------\n        let hasPaths = this.__dataHasPaths;\n        this.__dataHasPaths = false;\n        // Compute properties\n        runComputedEffects(this, changedProps, oldProps, hasPaths);\n        // Clear notify properties prior to possible reentry (propagate, observe),\n        // but after computing effects have a chance to add to them\n        let notifyProps = this.__dataToNotify;\n        this.__dataToNotify = null;\n        // Propagate properties to clients\n        this._propagatePropertyChanges(changedProps, oldProps, hasPaths);\n        // Flush clients\n        this._flushClients();\n        // Reflect properties\n        runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);\n        // Observe properties\n        runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);\n        // Notify properties to host\n        if (notifyProps) {\n          runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n        }\n        // Clear temporary cache at end of turn\n        if (this.__dataCounter == 1) {\n          this.__dataTemp = {};\n        }\n        // ----------------------------\n        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n        // ----------------------------\n      }\n\n      /**\n       * Called to propagate any property changes to stamped template nodes\n       * managed by this element.\n       *\n       * @param {Object} changedProps Bag of changed properties\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @protected\n       */\n      _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n        if (this[TYPES.PROPAGATE]) {\n          runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);\n        }\n        let templateInfo = this.__templateInfo;\n        while (templateInfo) {\n          runEffects(this, templateInfo.propertyEffects, changedProps, oldProps,\n            hasPaths, templateInfo.nodeList);\n          templateInfo = templateInfo.nextTemplateInfo;\n        }\n      }\n\n      /**\n       * Aliases one data path as another, such that path notifications from one\n       * are routed to the other.\n       *\n       * @param {string | !Array<string|number>} to Target path to link.\n       * @param {string | !Array<string|number>} from Source path to link.\n       * @public\n       */\n      linkPaths(to, from) {\n        to = Polymer.Path.normalize(to);\n        from = Polymer.Path.normalize(from);\n        this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n        this.__dataLinkedPaths[to] = from;\n      }\n\n      /**\n       * Removes a data path alias previously established with `_linkPaths`.\n       *\n       * Note, the path to unlink should be the target (`to`) used when\n       * linking the paths.\n       *\n       * @param {string | !Array<string|number>} path Target path to unlink.\n       * @public\n       */\n      unlinkPaths(path) {\n        path = Polymer.Path.normalize(path);\n        if (this.__dataLinkedPaths) {\n          delete this.__dataLinkedPaths[path];\n        }\n      }\n\n      /**\n       * Notify that an array has changed.\n       *\n       * Example:\n       *\n       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n       *     ...\n       *     this.items.splice(1, 1, {name: 'Sam'});\n       *     this.items.push({name: 'Bob'});\n       *     this.notifySplices('items', [\n       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },\n       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}\n       *     ]);\n       *\n       * @param {string} path Path that should be notified.\n       * @param {Array} splices Array of splice records indicating ordered\n       *   changes that occurred to the array. Each record should have the\n       *   following fields:\n       *    * index: index at which the change occurred\n       *    * removed: array of items that were removed from this index\n       *    * addedCount: number of new items added at this index\n       *    * object: a reference to the array in question\n       *    * type: the string literal 'splice'\n       *\n       *   Note that splice records _must_ be normalized such that they are\n       *   reported in index order (raw results from `Object.observe` are not\n       *   ordered and must be normalized/merged before notifying).\n       * @public\n      */\n      notifySplices(path, splices) {\n        let info = {path: ''};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        notifySplices(this, array, info.path, splices);\n      }\n\n      /**\n       * Convenience method for reading a value from a path.\n       *\n       * Note, if any part in the path is undefined, this method returns\n       * `undefined` (this method does not throw when dereferencing undefined\n       * paths).\n       *\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n       * @param {Object=} root Root object from which the path is evaluated.\n       * @return {*} Value at the path, or `undefined` if any part of the path\n       *   is undefined.\n       * @public\n       */\n      get(path, root) {\n        return Polymer.Path.get(root || this, path);\n      }\n\n      /**\n       * Convenience method for setting a value to a path and notifying any\n       * elements bound to the same path.\n       *\n       * Note, if any part in the path except for the last is undefined,\n       * this method does nothing (this method does not throw when\n       * dereferencing undefined paths).\n       *\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n       * @param {*} value Value to set at the specified path.\n       * @param {Object=} root Root object from which the path is evaluated.\n       *   When specified, no notification will occur.\n       * @public\n      */\n      set(path, value, root) {\n        if (root) {\n          Polymer.Path.set(root, path, value);\n        } else {\n          if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */(path)]) {\n            if (this._setPendingPropertyOrPath(path, value, true)) {\n              this._invalidateProperties();\n            }\n          }\n        }\n      }\n\n      /**\n       * Adds items onto the end of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @param {...*} items Items to push onto array\n       * @return {number} New length of the array.\n       * @public\n       */\n      push(path, ...items) {\n        let info = {path: ''};\n        let array = /** @type {Array}*/(Polymer.Path.get(this, path, info));\n        let len = array.length;\n        let ret = array.push(...items);\n        if (items.length) {\n          notifySplice(this, array, info.path, len, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the end of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n      pop(path) {\n        let info = {path: ''};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        let hadLength = Boolean(array.length);\n        let ret = array.pop();\n        if (hadLength) {\n          notifySplice(this, array, info.path, array.length, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Starting from the start index specified, removes 0 or more items\n       * from the array and inserts 0 or more new items in their place.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.splice`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @param {number} start Index from which to start removing/inserting.\n       * @param {number} deleteCount Number of items to remove.\n       * @param {...*} items Items to insert into array.\n       * @return {Array} Array of removed items.\n       * @public\n       */\n      splice(path, start, deleteCount, ...items) {\n        let info = {path : ''};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        // Normalize fancy native splice handling of crazy start values\n        if (start < 0) {\n          start = array.length - Math.floor(-start);\n        } else {\n          start = Math.floor(start);\n        }\n        if (!start) {\n          start = 0;\n        }\n        let ret = array.splice(start, deleteCount, ...items);\n        if (items.length || ret.length) {\n          notifySplice(this, array, info.path, start, items.length, ret);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the beginning of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n      shift(path) {\n        let info = {path: ''};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        let hadLength = Boolean(array.length);\n        let ret = array.shift();\n        if (hadLength) {\n          notifySplice(this, array, info.path, 0, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Adds items onto the beginning of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @param {...*} items Items to insert info array\n       * @return {number} New length of the array.\n       * @public\n       */\n      unshift(path, ...items) {\n        let info = {path: ''};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        let ret = array.unshift(...items);\n        if (items.length) {\n          notifySplice(this, array, info.path, 0, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Notify that a path has changed.\n       *\n       * Example:\n       *\n       *     this.item.user.name = 'Bob';\n       *     this.notifyPath('item.user.name');\n       *\n       * @param {string} path Path that should be notified.\n       * @param {*=} value Value at the path (optional).\n       * @public\n      */\n      notifyPath(path, value) {\n        /** @type {string} */\n        let propPath;\n        if (arguments.length == 1) {\n          // Get value if not supplied\n          let info = {path: ''};\n          value = Polymer.Path.get(this, path, info);\n          propPath = info.path;\n        } else if (Array.isArray(path)) {\n          // Normalize path if needed\n          propPath = Polymer.Path.normalize(path);\n        } else {\n          propPath = /** @type{string} */(path);\n        }\n        if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Equivalent to static `createReadOnlyProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @protected\n       */\n      _createReadOnlyProperty(property, protectedSetter) {\n        this._addPropertyEffect(property, TYPES.READ_ONLY);\n        if (protectedSetter) {\n          this['_set' + upper(property)] = /** @this {PropertyEffects} */function(value) {\n            this._setProperty(property, value);\n          }\n        }\n      }\n\n      /**\n       * Equivalent to static `createPropertyObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @param {string} methodName Name of observer method to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @protected\n       */\n      _createPropertyObserver(property, methodName, dynamicFn) {\n        let info = { property, methodName, dynamicFn: Boolean(dynamicFn) };\n        this._addPropertyEffect(property, TYPES.OBSERVE, {\n          fn: runObserverEffect, info, trigger: {name: property}\n        });\n        if (dynamicFn) {\n          this._addPropertyEffect(methodName, TYPES.OBSERVE, {\n            fn: runObserverEffect, info, trigger: {name: methodName}\n          });\n        }\n      }\n\n      /**\n       * Equivalent to static `createMethodObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @protected\n       */\n      _createMethodObserver(expression, dynamicFn) {\n        let sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n        }\n        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n      }\n\n      /**\n       * Equivalent to static `createNotifyingProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      _createNotifyingProperty(property) {\n        this._addPropertyEffect(property, TYPES.NOTIFY, {\n          fn: runNotifyEffect,\n          info: {\n            eventName: CaseMap.camelToDashCase(property) + '-changed',\n            property: property\n          }\n        });\n      }\n\n      /**\n       * Equivalent to static `createReflectedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      _createReflectedProperty(property) {\n        let attr = CaseMap.camelToDashCase(property);\n        if (attr[0] === '-') {\n          console.warn('Property ' + property + ' cannot be reflected to attribute ' +\n            attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');\n        } else {\n          this._addPropertyEffect(property, TYPES.REFLECT, {\n            fn: runReflectEffect,\n            info: {\n              attrName: attr\n            }\n          });\n        }\n      }\n\n      /**\n       * Equivalent to static `createComputedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @protected\n       */\n      _createComputedProperty(property, expression, dynamicFn) {\n        let sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n        }\n        createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\n      }\n\n      // -- static class methods ------------\n\n      /**\n       * Ensures an accessor exists for the specified property, and adds\n       * to a list of \"property effects\" that will run when the accessor for\n       * the specified property is set.  Effects are grouped by \"type\", which\n       * roughly corresponds to a phase in effect processing.  The effect\n       * metadata should be in the following form:\n       *\n       *   {\n       *     fn: effectFunction, // Reference to function to call to perform effect\n       *     info: { ... }       // Effect metadata passed to function\n       *     trigger: {          // Optional triggering metadata; if not provided\n       *       name: string      // the property is treated as a wildcard\n       *       structured: boolean\n       *       wildcard: boolean\n       *     }\n       *   }\n       *\n       * Effects are called from `_propertiesChanged` in the following order by\n       * type:\n       *\n       * 1. COMPUTE\n       * 2. PROPAGATE\n       * 3. REFLECT\n       * 4. OBSERVE\n       * 5. NOTIFY\n       *\n       * Effect functions are called with the following signature:\n       *\n       *   effectFunction(inst, path, props, oldProps, info, hasPaths)\n       *\n       * @param {string} property Property that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @protected\n       */\n      static addPropertyEffect(property, type, effect) {\n        this.prototype._addPropertyEffect(property, type, effect);\n      }\n\n      /**\n       * Creates a single-property observer for the given property.\n       *\n       * @param {string} property Property name\n       * @param {string} methodName Name of observer method to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @protected\n       */\n      static createPropertyObserver(property, methodName, dynamicFn) {\n        this.prototype._createPropertyObserver(property, methodName, dynamicFn);\n      }\n\n      /**\n       * Creates a multi-property \"method observer\" based on the provided\n       * expression, which should be a string in the form of a normal Javascript\n       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n       * should correspond to a property or path in the context of this\n       * prototype (or instance), or may be a literal string or number.\n       *\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @protected\n       */\n      static createMethodObserver(expression, dynamicFn) {\n        this.prototype._createMethodObserver(expression, dynamicFn);\n      }\n\n      /**\n       * Causes the setter for the given property to dispatch `<property>-changed`\n       * events to notify of changes to the property.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      static createNotifyingProperty(property) {\n        this.prototype._createNotifyingProperty(property);\n      }\n\n      /**\n       * Creates a read-only accessor for the given property.\n       *\n       * To set the property, use the protected `_setProperty` API.\n       * To create a custom protected setter (e.g. `_setMyProp()` for\n       * property `myProp`), pass `true` for `protectedSetter`.\n       *\n       * Note, if the property will have other property effects, this method\n       * should be called first, before adding other effects.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @protected\n       */\n      static createReadOnlyProperty(property, protectedSetter) {\n        this.prototype._createReadOnlyProperty(property, protectedSetter);\n      }\n\n      /**\n       * Causes the setter for the given property to reflect the property value\n       * to a (dash-cased) attribute of the same name.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      static createReflectedProperty(property) {\n        this.prototype._createReflectedProperty(property);\n      }\n\n      /**\n       * Creates a computed property whose value is set to the result of the\n       * method described by the given `expression` each time one or more\n       * arguments to the method changes.  The expression should be a string\n       * in the form of a normal Javascript function signature:\n       * `'methodName(arg1, [..., argn])'`\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n       *   method names should be included as a dependency to the effect.\n       * @protected\n       */\n      static createComputedProperty(property, expression, dynamicFn) {\n        this.prototype._createComputedProperty(property, expression, dynamicFn);\n      }\n\n      /**\n       * Parses the provided template to ensure binding effects are created\n       * for them, and then ensures property accessors are created for any\n       * dependent properties in the template.  Binding effects for bound\n       * templates are stored in a linked list on the instance so that\n       * templates can be efficiently stamped and unstamped.\n       *\n       * @param {HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @return {Object} Template metadata object\n       * @protected\n       */\n      static bindTemplate(template) {\n        return this.prototype._bindTemplate(template);\n      }\n\n      // -- binding ----------------------------------------------\n\n      /**\n       * Equivalent to static `bindTemplate` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * This method may be called on the prototype (for prototypical template\n       * binding, to avoid creating accessors every instance) once per prototype,\n       * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n       * create and link an instance of the template metadata associated with a\n       * particular stamping.\n       *\n       * @param {HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @param {boolean=} instanceBinding When false (default), performs\n       *   \"prototypical\" binding of the template and overwrites any previously\n       *   bound template for the class. When true (as passed from\n       *   `_stampTemplate`), the template info is instanced and linked into\n       *   the list of bound templates.\n       * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,\n       *   this is an instance of the prototypical template info\n       * @protected\n       */\n      _bindTemplate(template, instanceBinding) {\n        let templateInfo = this.constructor._parseTemplate(template);\n        let wasPreBound = this.__templateInfo == templateInfo;\n        // Optimization: since this is called twice for proto-bound templates,\n        // don't attempt to recreate accessors if this template was pre-bound\n        if (!wasPreBound) {\n          for (let prop in templateInfo.propertyEffects) {\n            this._createPropertyAccessor(prop);\n          }\n        }\n        if (instanceBinding) {\n          // For instance-time binding, create instance of template metadata\n          // and link into list of templates if necessary\n          templateInfo = /** @type {!TemplateInfo} */(Object.create(templateInfo));\n          templateInfo.wasPreBound = wasPreBound;\n          if (!wasPreBound && this.__templateInfo) {\n            let last = this.__templateInfoLast || this.__templateInfo;\n            this.__templateInfoLast = last.nextTemplateInfo = templateInfo;\n            templateInfo.previousTemplateInfo = last;\n            return templateInfo;\n          }\n        }\n        return this.__templateInfo = templateInfo;\n      }\n\n      /**\n       * Adds a property effect to the given template metadata, which is run\n       * at the \"propagate\" stage of `_propertiesChanged` when the template\n       * has been bound to the element via `_bindTemplate`.\n       *\n       * The `effect` object should match the format in `_addPropertyEffect`.\n       *\n       * @param {Object} templateInfo Template metadata to add effect to\n       * @param {string} prop Property that should trigger the effect\n       * @param {Object=} effect Effect metadata object\n       * @protected\n       */\n      static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n        let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n        hostProps[prop] = true;\n        let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n        let propEffects = effects[prop] = effects[prop] || [];\n        propEffects.push(effect);\n      }\n\n      /**\n       * Stamps the provided template and performs instance-time setup for\n       * Polymer template features, including data bindings, declarative event\n       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n       * is returned containing the stamped DOM, ready for insertion into the\n       * DOM.\n       *\n       * This method may be called more than once; however note that due to\n       * `shadycss` polyfill limitations, only styles from templates prepared\n       * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n       * to the shadow root and support CSS custom properties), and note that\n       * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n       * any styles required by in runtime-stamped templates must be included\n       * in the main element template.\n       *\n       * @param {!HTMLTemplateElement} template Template to stamp\n       * @return {!StampedTemplate} Cloned template content\n       * @override\n       * @protected\n       */\n      _stampTemplate(template) {\n        // Ensures that created dom is `_enqueueClient`'d to this element so\n        // that it can be flushed on next call to `_flushProperties`\n        hostStack.beginHosting(this);\n        let dom = super._stampTemplate(template);\n        hostStack.endHosting(this);\n        let templateInfo = /** @type {!TemplateInfo} */(this._bindTemplate(template, true));\n        // Add template-instance-specific data to instanced templateInfo\n        templateInfo.nodeList = dom.nodeList;\n        // Capture child nodes to allow unstamping of non-prototypical templates\n        if (!templateInfo.wasPreBound) {\n          let nodes = templateInfo.childNodes = [];\n          for (let n=dom.firstChild; n; n=n.nextSibling) {\n            nodes.push(n);\n          }\n        }\n        dom.templateInfo = templateInfo;\n        // Setup compound storage, 2-way listeners, and dataHost for bindings\n        setupBindings(this, templateInfo);\n        // Flush properties into template nodes if already booted\n        if (this.__dataReady) {\n          runEffects(this, templateInfo.propertyEffects, this.__data, null,\n            false, templateInfo.nodeList);\n        }\n        return dom;\n      }\n\n      /**\n       * Removes and unbinds the nodes previously contained in the provided\n       * DocumentFragment returned from `_stampTemplate`.\n       *\n       * @param {!StampedTemplate} dom DocumentFragment previously returned\n       *   from `_stampTemplate` associated with the nodes to be removed\n       * @protected\n       */\n      _removeBoundDom(dom) {\n        // Unlink template info\n        let templateInfo = dom.templateInfo;\n        if (templateInfo.previousTemplateInfo) {\n          templateInfo.previousTemplateInfo.nextTemplateInfo =\n            templateInfo.nextTemplateInfo;\n        }\n        if (templateInfo.nextTemplateInfo) {\n          templateInfo.nextTemplateInfo.previousTemplateInfo =\n            templateInfo.previousTemplateInfo;\n        }\n        if (this.__templateInfoLast == templateInfo) {\n          this.__templateInfoLast = templateInfo.previousTemplateInfo;\n        }\n        templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;\n        // Remove stamped nodes\n        let nodes = templateInfo.childNodes;\n        for (let i=0; i<nodes.length; i++) {\n          let node = nodes[i];\n          node.parentNode.removeChild(node);\n        }\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n      static _parseTemplateNode(node, templateInfo, nodeInfo) {\n        let noted = super._parseTemplateNode(node, templateInfo, nodeInfo);\n        if (node.nodeType === Node.TEXT_NODE) {\n          let parts = this._parseBindings(node.textContent, templateInfo);\n          if (parts) {\n            // Initialize the textContent with any literal parts\n            // NOTE: default to a space here so the textNode remains; some browsers\n            // (IE) evacipate an empty textNode following cloneNode/importNode.\n            node.textContent = literalFromParts(parts) || ' ';\n            addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n            noted = true;\n          }\n        }\n        return noted;\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from attributes.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @override\n       * @param {Element} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n      static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n        let parts = this._parseBindings(value, templateInfo);\n        if (parts) {\n          // Attribute or property\n          let origName = name;\n          let kind = 'property';\n          if (name[name.length-1] == '$') {\n            name = name.slice(0, -1);\n            kind = 'attribute';\n          }\n          // Initialize attribute bindings with any literal parts\n          let literal = literalFromParts(parts);\n          if (literal && kind == 'attribute') {\n            node.setAttribute(name, literal);\n          }\n          // Clear attribute before removing, since IE won't allow removing\n          // `value` attribute if it previously had a value (can't\n          // unconditionally set '' before removing since attributes with `$`\n          // can't be set using setAttribute)\n          if (node.localName === 'input' && origName === 'value') {\n            node.setAttribute(origName, '');\n          }\n          // Remove annotation\n          node.removeAttribute(origName);\n          // Case hackery: attributes are lower-case, but bind targets\n          // (properties) are case sensitive. Gambit is to map dash-case to\n          // camel-case: `foo-bar` becomes `fooBar`.\n          // Attribute bindings are excepted.\n          if (kind === 'property') {\n            name = Polymer.CaseMap.dashToCamelCase(name);\n          }\n          addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n          return true;\n        } else {\n          return super._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value);\n        }\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * binding the properties that a nested template depends on to the template\n       * as `_host_<property>`.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n      static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n        let noted = super._parseTemplateNestedTemplate(node, templateInfo, nodeInfo);\n        // Merge host props into outer template and add bindings\n        let hostProps = nodeInfo.templateInfo.hostProps;\n        let mode = '{';\n        for (let source in hostProps) {\n          let parts = [{ mode, source, dependencies: [source] }];\n          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n        }\n        return noted;\n      }\n\n      /**\n       * Called to parse text in a template (either attribute values or\n       * textContent) into binding metadata.\n       *\n       * Any overrides of this method should return an array of binding part\n       * metadata  representing one or more bindings found in the provided text\n       * and any \"literal\" text in between.  Any non-literal parts will be passed\n       * to `_evaluateBinding` when any dependencies change.  The only required\n       * fields of each \"part\" in the returned array are as follows:\n       *\n       * - `dependencies` - Array containing trigger metadata for each property\n       *   that should trigger the binding to update\n       * - `literal` - String containing text if the part represents a literal;\n       *   in this case no `dependencies` are needed\n       *\n       * Additional metadata for use by `_evaluateBinding` may be provided in\n       * each part object as needed.\n       *\n       * The default implementation handles the following types of bindings\n       * (one or more may be intermixed with literal strings):\n       * - Property binding: `[[prop]]`\n       * - Path binding: `[[object.prop]]`\n       * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n       * - Two-way property or path bindings (supports negation):\n       *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n       * - Inline computed method (supports negation):\n       *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n       *\n       * @param {string} text Text to parse from attribute or textContent\n       * @param {Object} templateInfo Current template metadata\n       * @return {Array<!BindingPart>} Array of binding part metadata\n       * @protected\n       */\n      static _parseBindings(text, templateInfo) {\n        let parts = [];\n        let lastIndex = 0;\n        let m;\n        // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n        // Regex matches:\n        //        Iteration 1:  Iteration 2:\n        // m[1]: '{{'          '[['\n        // m[2]: ''            '!'\n        // m[3]: 'prop'        'compute(foo,bar)'\n        while ((m = bindingRegex.exec(text)) !== null) {\n          // Add literal part\n          if (m.index > lastIndex) {\n            parts.push({literal: text.slice(lastIndex, m.index)});\n          }\n          // Add binding part\n          let mode = m[1][0];\n          let negate = Boolean(m[2]);\n          let source = m[3].trim();\n          let customEvent = false, notifyEvent = '', colon = -1;\n          if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n            notifyEvent = source.substring(colon + 2);\n            source = source.substring(0, colon);\n            customEvent = true;\n          }\n          let signature = parseMethod(source);\n          let dependencies = [];\n          if (signature) {\n            // Inline computed function\n            let {args, methodName} = signature;\n            for (let i=0; i<args.length; i++) {\n              let arg = args[i];\n              if (!arg.literal) {\n                dependencies.push(arg);\n              }\n            }\n            let dynamicFns = templateInfo.dynamicFns;\n            if (dynamicFns && dynamicFns[methodName] || signature.static) {\n              dependencies.push(methodName);\n              signature.dynamicFn = true;\n            }\n          } else {\n            // Property or path\n            dependencies.push(source);\n          }\n          parts.push({\n            source, mode, negate, customEvent, signature, dependencies,\n            event: notifyEvent\n          });\n          lastIndex = bindingRegex.lastIndex;\n        }\n        // Add a final literal part\n        if (lastIndex && lastIndex < text.length) {\n          let literal = text.substring(lastIndex);\n          if (literal) {\n            parts.push({\n              literal: literal\n            });\n          }\n        }\n        if (parts.length) {\n          return parts;\n        } else {\n          return null;\n        }\n      }\n\n      /**\n       * Called to evaluate a previously parsed binding part based on a set of\n       * one or more changed dependencies.\n       *\n       * @param {this} inst Element that should be used as scope for\n       *   binding dependencies\n       * @param {BindingPart} part Binding part metadata\n       * @param {string} path Property/path that triggered this effect\n       * @param {Object} props Bag of current property changes\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @return {*} Value the binding part evaluated to\n       * @protected\n       */\n      static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n        let value;\n        if (part.signature) {\n          value = runMethodEffect(inst, path, props, oldProps, part.signature);\n        } else if (path != part.source) {\n          value = Polymer.Path.get(inst, part.source);\n        } else {\n          if (hasPaths && Polymer.Path.isPath(path)) {\n            value = Polymer.Path.get(inst, path);\n          } else {\n            value = inst.__data[path];\n          }\n        }\n        if (part.negate) {\n          value = !value;\n        }\n        return value;\n      }\n\n    }\n\n    // make a typing for closure :P\n    PropertyEffectsType = PropertyEffects;\n\n    return PropertyEffects;\n  });\n\n  /**\n   * Helper api for enqueing client dom created by a host element.\n   *\n   * By default elements are flushed via `_flushProperties` when\n   * `connectedCallback` is called. Elements attach their client dom to\n   * themselves at `ready` time which results from this first flush.\n   * This provides an ordering guarantee that the client dom an element\n   * creates is flushed before the element itself (i.e. client `ready`\n   * fires before host `ready`).\n   *\n   * However, if `_flushProperties` is called *before* an element is connected,\n   * as for example `Templatize` does, this ordering guarantee cannot be\n   * satisfied because no elements are connected. (Note: Bound elements that\n   * receive data do become enqueued clients and are properly ordered but\n   * unbound elements are not.)\n   *\n   * To maintain the desired \"client before host\" ordering guarantee for this\n   * case we rely on the \"host stack. Client nodes registers themselves with\n   * the creating host element when created. This ensures that all client dom\n   * is readied in the proper order, maintaining the desired guarantee.\n   *\n   * @private\n   */\n  let hostStack = {\n\n    stack: [],\n\n    /**\n     * @param {*} inst Instance to add to hostStack\n     * @this {hostStack}\n     */\n    registerHost(inst) {\n      if (this.stack.length) {\n        let host = this.stack[this.stack.length-1];\n        host._enqueueClient(inst);\n      }\n    },\n\n    /**\n     * @param {*} inst Instance to begin hosting\n     * @this {hostStack}\n     */\n    beginHosting(inst) {\n      this.stack.push(inst);\n    },\n\n    /**\n     * @param {*} inst Instance to end hosting\n     * @this {hostStack}\n     */\n    endHosting(inst) {\n      let stackLen = this.stack.length;\n      if (stackLen && this.stack[stackLen-1] == inst) {\n        this.stack.pop();\n      }\n    }\n\n  }\n\n})();\n</script>\n\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/mixins/property-effects.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n\n<link rel=\"import\" href=\"../utils/boot.html\">\n<link rel=\"import\" href=\"../utils/settings.html\">\n<link rel=\"import\" href=\"../utils/mixin.html\">\n<link rel=\"import\" href=\"../utils/case-map.html\">\n<link rel=\"import\" href=\"../utils/style-gather.html\">\n<link rel=\"import\" href=\"../utils/resolve-url.html\">\n<link rel=\"import\" href=\"../elements/dom-module.html\">\n<link rel=\"import\" href=\"property-effects.html\">\n\n<script>\n(function() {\n  'use strict';\n\n  /**\n   * Element class mixin that provides the core API for Polymer's meta-programming\n   * features including template stamping, data-binding, attribute deserialization,\n   * and property change observation.\n   *\n   * Subclassers may provide the following static getters to return metadata\n   * used to configure Polymer's features for the class:\n   *\n   * - `static get is()`: When the template is provided via a `dom-module`,\n   *   users should return the `dom-module` id from a static `is` getter.  If\n   *   no template is needed or the template is provided directly via the\n   *   `template` getter, there is no need to define `is` for the element.\n   *\n   * - `static get template()`: Users may provide the template directly (as\n   *   opposed to via `dom-module`) by implementing a static `template` getter.\n   *   The getter may return an `HTMLTemplateElement` or a string, which will\n   *   automatically be parsed into a template.\n   *\n   * - `static get properties()`: Should return an object describing\n   *   property-related metadata used by Polymer features (key: property name\n   *   value: object containing property metadata). Valid keys in per-property\n   *   metadata include:\n   *   - `type` (String|Number|Object|Array|...): Used by\n   *     `attributeChangedCallback` to determine how string-based attributes\n   *     are deserialized to JavaScript property values.\n   *   - `notify` (boolean): Causes a change in the property to fire a\n   *     non-bubbling event called `<property>-changed`. Elements that have\n   *     enabled two-way binding to the property use this event to observe changes.\n   *   - `readOnly` (boolean): Creates a getter for the property, but no setter.\n   *     To set a read-only property, use the private setter method\n   *     `_setProperty(property, value)`.\n   *   - `observer` (string): Observer method name that will be called when\n   *     the property changes. The arguments of the method are\n   *     `(value, previousValue)`.\n   *   - `computed` (string): String describing method and dependent properties\n   *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n   *     Computed properties are read-only by default and can only be changed\n   *     via the return value of the computing method.\n   *\n   * - `static get observers()`: Array of strings describing multi-property\n   *   observer methods and their dependent properties (e.g.\n   *   `'observeABC(a, b, c)'`).\n   *\n   * The base class provides default implementations for the following standard\n   * custom element lifecycle callbacks; users may override these, but should\n   * call the super method to ensure\n   * - `constructor`: Run when the element is created or upgraded\n   * - `connectedCallback`: Run each time the element is connected to the\n   *   document\n   * - `disconnectedCallback`: Run each time the element is disconnected from\n   *   the document\n   * - `attributeChangedCallback`: Run each time an attribute in\n   *   `observedAttributes` is set or removed (note: this element's default\n   *   `observedAttributes` implementation will automatically return an array\n   *   of dash-cased attributes based on `properties`)\n   *\n   * @mixinFunction\n   * @polymer\n   * @appliesMixin Polymer.PropertyEffects\n   * @memberof Polymer\n   * @property rootPath {string} Set to the value of `Polymer.rootPath`,\n   *   which defaults to the main document path\n   * @property importPath {string} Set to the value of the class's static\n   *   `importPath` property, which defaults to the path of this element's\n   *   `dom-module` (when `is` is used), but can be overridden for other\n   *   import strategies.\n   * @summary Element class mixin that provides the core API for Polymer's\n   * meta-programming features.\n   */\n  Polymer.ElementMixin = Polymer.dedupingMixin(base => {\n\n    /**\n     * @constructor\n     * @extends {base}\n     * @implements {Polymer_PropertyEffects}\n     */\n    const polymerElementBase = Polymer.PropertyEffects(base);\n\n    let caseMap = Polymer.CaseMap;\n\n    /**\n     * Returns the `properties` object specifically on `klass`. Use for:\n     * (1) super chain mixes togther to make `propertiesForClass` which is\n     * then used to make `observedAttributes`.\n     * (2) properties effects and observers are created from it at `finalize` time.\n     *\n     * @param {HTMLElement} klass Element class\n     * @return {Object} Object containing own properties for this class\n     * @private\n     */\n    function ownPropertiesForClass(klass) {\n      if (!klass.hasOwnProperty(\n        JSCompiler_renameProperty('__ownProperties', klass))) {\n        klass.__ownProperties =\n          klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?\n          /** @type PolymerElementConstructor */ (klass).properties : {};\n      }\n      return klass.__ownProperties;\n    }\n\n    /**\n     * Returns the `observers` array specifically on `klass`. Use for\n     * setting up observers.\n     *\n     * @param {HTMLElement} klass Element class\n     * @return {Array} Array containing own observers for this class\n     * @private\n     */\n    function ownObserversForClass(klass) {\n      if (!klass.hasOwnProperty(\n        JSCompiler_renameProperty('__ownObservers', klass))) {\n        klass.__ownObservers =\n          klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?\n          /** @type PolymerElementConstructor */ (klass).observers : [];\n      }\n      return klass.__ownObservers;\n    }\n\n    /**\n     * Mixes `props` into `flattenedProps` but upgrades shorthand type\n     * syntax to { type: Type}.\n     *\n     * @param {Object} flattenedProps Bag to collect flattened properties into\n     * @param {Object} props Bag of properties to add to `flattenedProps`\n     * @return {Object} The input `flattenedProps` bag\n     * @private\n     */\n    function flattenProperties(flattenedProps, props) {\n      for (let p in props) {\n        let o = props[p];\n        if (typeof o == 'function') {\n          o = { type: o };\n        }\n        flattenedProps[p] = o;\n      }\n      return flattenedProps;\n    }\n\n    /**\n     * Returns a flattened list of properties mixed together from the chain of all\n     * constructor's `config.properties`. This list is used to create\n     * (1) observedAttributes,\n     * (2) class property default values\n     *\n     * @param {PolymerElementConstructor} klass Element class\n     * @return {PolymerElementProperties} Flattened properties for this class\n     * @suppress {missingProperties} class.prototype is not a property for some reason?\n     * @private\n     */\n    function propertiesForClass(klass) {\n      if (!klass.hasOwnProperty(\n        JSCompiler_renameProperty('__classProperties', klass))) {\n        klass.__classProperties =\n        flattenProperties({}, ownPropertiesForClass(klass));\n        let superCtor = Object.getPrototypeOf(klass.prototype).constructor;\n        if (superCtor.prototype instanceof PolymerElement) {\n          klass.__classProperties = Object.assign(\n            Object.create(propertiesForClass(/** @type PolymerElementConstructor */(superCtor))),\n            klass.__classProperties);\n        }\n      }\n      return klass.__classProperties;\n    }\n\n    /**\n     * Returns a list of properties with default values.\n     * This list is created as an optimization since it is a subset of\n     * the list returned from `propertiesForClass`.\n     * This list is used in `_initializeProperties` to set property defaults.\n     *\n     * @param {PolymerElementConstructor} klass Element class\n     * @return {PolymerElementProperties} Flattened properties for this class\n     *   that have default values\n     * @private\n     */\n    function propertyDefaultsForClass(klass) {\n      if (!klass.hasOwnProperty(\n        JSCompiler_renameProperty('__classPropertyDefaults', klass))) {\n        klass.__classPropertyDefaults = null;\n        let props = propertiesForClass(klass);\n        for (let p in props) {\n          let info = props[p];\n          if ('value' in info) {\n            klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};\n            klass.__classPropertyDefaults[p] = info;\n          }\n        }\n      }\n      return klass.__classPropertyDefaults;\n    }\n\n    /**\n     * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`\n     * @param {PolymerElementConstructor} klass Element class\n     * @return {boolean} True if all metaprogramming for this class has been\n     *   completed\n     * @private\n     */\n    function hasClassFinalized(klass) {\n      return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));\n    }\n\n    /**\n     * Called by `ElementClass.finalize()`. Ensures this `klass` and\n     * *all superclasses* are finalized by traversing the prototype chain\n     * and calling `klass.finalize()`.\n     *\n     * @param {PolymerElementConstructor} klass Element class\n     * @private\n     */\n    function finalizeClassAndSuper(klass) {\n      let proto = /** @type PolymerElementConstructor */ (klass).prototype;\n      let superCtor = Object.getPrototypeOf(proto).constructor;\n      if (superCtor.prototype instanceof PolymerElement) {\n        superCtor.finalize();\n      }\n      finalizeClass(klass);\n    }\n\n    /**\n     * Configures a `klass` based on a staic `klass.config` object and\n     * a `template`. This includes creating accessors and effects\n     * for properties in `config` and the `template` as well as preparing the\n     * `template` for stamping.\n     *\n     * @param {PolymerElementConstructor} klass Element class\n     * @private\n     */\n    function finalizeClass(klass) {\n      klass.__finalized = true;\n      let proto = /** @type PolymerElementConstructor */ (klass).prototype;\n      if (klass.hasOwnProperty(\n        JSCompiler_renameProperty('is', klass)) && klass.is) {\n        Polymer.telemetry.register(proto);\n      }\n      let props = ownPropertiesForClass(klass);\n      if (props) {\n        finalizeProperties(proto, props);\n      }\n      let observers = ownObserversForClass(klass);\n      if (observers) {\n        finalizeObservers(proto, observers, props);\n      }\n      // note: create \"working\" template that is finalized at instance time\n      let template = /** @type PolymerElementConstructor */ (klass).template;\n      if (template) {\n        if (typeof template === 'string') {\n          let t = document.createElement('template');\n          t.innerHTML = template;\n          template = t;\n        } else {\n          template = template.cloneNode(true);\n        }\n        proto._template = template;\n      }\n    }\n\n    /**\n     * Configures a `proto` based on a `properties` object.\n     * Leverages `PropertyEffects` to create property accessors and effects\n     * supporting, observers, reflecting to attributes, change notification,\n     * computed properties, and read only properties.\n     * @param {PolymerElement} proto Element class prototype to add accessors\n     *    and effects to\n     * @param {Object} properties Flattened bag of property descriptors for\n     *    this class\n     * @private\n     */\n    function finalizeProperties(proto, properties) {\n      for (let p in properties) {\n        createPropertyFromConfig(proto, p, properties[p], properties);\n      }\n    }\n\n    /**\n     * Configures a `proto` based on a `observers` array.\n     * Leverages `PropertyEffects` to create observers.\n     * @param {PolymerElement} proto Element class prototype to add accessors\n     *   and effects to\n     * @param {Object} observers Flattened array of observer descriptors for\n     *   this class\n     * @param {Object} dynamicFns Object containing keys for any properties\n     *   that are functions and should trigger the effect when the function\n     *   reference is changed\n     * @private\n     */\n    function finalizeObservers(proto, observers, dynamicFns) {\n      for (let i=0; i < observers.length; i++) {\n        proto._createMethodObserver(observers[i], dynamicFns);\n      }\n    }\n\n    /**\n     * Creates effects for a property.\n     *\n     * Note, once a property has been set to\n     * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n     * these values may not be changed. For example, a subclass cannot\n     * alter these settings. However, additional `observers` may be added\n     * by subclasses.\n     *\n     * The info object should may contain property metadata as follows:\n     *\n     * * `type`: {function} type to which an attribute matching the property\n     * is deserialized. Note the property is camel-cased from a dash-cased\n     * attribute. For example, 'foo-bar' attribute is dersialized to a\n     * property named 'fooBar'.\n     *\n     * * `readOnly`: {boolean} creates a readOnly property and\n     * makes a private setter for the private of the form '_setFoo' for a\n     * property 'foo',\n     *\n     * * `computed`: {string} creates a computed property. A computed property\n     * also automatically is set to `readOnly: true`. The value is calculated\n     * by running a method and arguments parsed from the given string. For\n     * example 'compute(foo)' will compute a given property when the\n     * 'foo' property changes by executing the 'compute' method. This method\n     * must return the computed value.\n     *\n     * * `reflectToAttriute`: {boolean} If true, the property value is reflected\n     * to an attribute of the same name. Note, the attribute is dash-cased\n     * so a property named 'fooBar' is reflected as 'foo-bar'.\n     *\n     * * `notify`: {boolean} sends a non-bubbling notification event when\n     * the property changes. For example, a property named 'foo' sends an\n     * event named 'foo-changed' with `event.detail` set to the value of\n     * the property.\n     *\n     * * observer: {string} name of a method that runs when the property\n     * changes. The arguments of the method are (value, previousValue).\n     *\n     * Note: Users may want control over modifying property\n     * effects via subclassing. For example, a user might want to make a\n     * reflectToAttribute property not do so in a subclass. We've chosen to\n     * disable this because it leads to additional complication.\n     * For example, a readOnly effect generates a special setter. If a subclass\n     * disables the effect, the setter would fail unexpectedly.\n     * Based on feedback, we may want to try to make effects more malleable\n     * and/or provide an advanced api for manipulating them.\n     * Also consider adding warnings when an effect cannot be changed.\n     *\n     * @param {PolymerElement} proto Element class prototype to add accessors\n     *   and effects to\n     * @param {string} name Name of the property.\n     * @param {Object} info Info object from which to create property effects.\n     * Supported keys:\n     * @param {Object} allProps Flattened map of all properties defined in this\n     *   element (including inherited properties)\n     * @private\n     */\n    function createPropertyFromConfig(proto, name, info, allProps) {\n      // computed forces readOnly...\n      if (info.computed) {\n        info.readOnly = true;\n      }\n      // Note, since all computed properties are readOnly, this prevents\n      // adding additional computed property effects (which leads to a confusing\n      // setup where multiple triggers for setting a property)\n      // While we do have `hasComputedEffect` this is set on the property's\n      // dependencies rather than itself.\n      if (info.computed  && !proto._hasReadOnlyEffect(name)) {\n        proto._createComputedProperty(name, info.computed, allProps);\n      }\n      if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n        proto._createReadOnlyProperty(name, !info.computed);\n      }\n      if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n        proto._createReflectedProperty(name);\n      }\n      if (info.notify && !proto._hasNotifyEffect(name)) {\n        proto._createNotifyingProperty(name);\n      }\n      // always add observer\n      if (info.observer) {\n        proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n      }\n    }\n\n    /**\n     * Configures an element `proto` to function with a given `template`.\n     * The element name `is` and extends `ext` must be specified for ShadyCSS\n     * style scoping.\n     *\n     * @param {PolymerElement} proto Element class prototype to add accessors\n     *   and effects to\n     * @param {!HTMLTemplateElement} template Template to process and bind\n     * @param {string} baseURI URL against which to resolve urls in\n     *   style element cssText\n     * @param {string} is Tag name (or type extension name) for this element\n     * @param {string=} ext For type extensions, the tag name that was extended\n     * @private\n     */\n    function finalizeTemplate(proto, template, baseURI, is, ext) {\n      // support `include=\"module-name\"`\n      let cssText =\n        Polymer.StyleGather.cssFromTemplate(template, baseURI) +\n        Polymer.StyleGather.cssFromModuleImports(is);\n      if (cssText) {\n        let style = document.createElement('style');\n        style.textContent = cssText;\n        template.content.insertBefore(style, template.content.firstChild);\n      }\n      if (window.ShadyCSS) {\n        window.ShadyCSS.prepareTemplate(template, is, ext);\n      }\n      proto._bindTemplate(template);\n    }\n\n    /**\n     * @polymer\n     * @mixinClass\n     * @unrestricted\n     * @implements {Polymer_ElementMixin}\n     */\n    class PolymerElement extends polymerElementBase {\n\n      /**\n       * Standard Custom Elements V1 API.  The default implementation returns\n       * a list of dash-cased attributes based on a flattening of all properties\n       * declared in `static get properties()` for this element and any\n       * superclasses.\n       *\n       * @return {Array} Observed attribute list\n       */\n      static get observedAttributes() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {\n          let list = [];\n          let properties = propertiesForClass(this);\n          for (let prop in properties) {\n            list.push(Polymer.CaseMap.camelToDashCase(prop));\n          }\n          this.__observedAttributes = list;\n        }\n        return this.__observedAttributes;\n      }\n\n      /**\n       * Called automatically when the first element instance is created to\n       * ensure that class finalization work has been completed.\n       * May be called by users to eagerly perform class finalization work\n       * prior to the creation of the first element instance.\n       *\n       * Class finalization work generally includes meta-programming such as\n       * creating property accessors and any property effect metadata needed for\n       * the features used.\n       *\n       * @public\n       */\n      static finalize() {\n        if (!hasClassFinalized(this)) {\n          finalizeClassAndSuper(this);\n        }\n      }\n\n      /**\n       * Returns the template that will be stamped into this element's shadow root.\n       *\n       * If a `static get is()` getter is defined, the default implementation\n       * will return the first `<template>` in a `dom-module` whose `id`\n       * matches this element's `is`.\n       *\n       * Users may override this getter to return an arbitrary template\n       * (in which case the `is` getter is unnecessary). The template returned\n       * may be either an `HTMLTemplateElement` or a string that will be\n       * automatically parsed into a template.\n       *\n       * Note that when subclassing, if the super class overrode the default\n       * implementation and the subclass would like to provide an alternate\n       * template via a `dom-module`, it should override this getter and\n       * return `Polymer.DomModule.import(this.is, 'template')`.\n       *\n       * If a subclass would like to modify the super class template, it should\n       * clone it rather than modify it in place.  If the getter does expensive\n       * work such as cloning/modifying a template, it should memoize the\n       * template for maximum performance:\n       *\n       *   let memoizedTemplate;\n       *   class MySubClass extends MySuperClass {\n       *     static get template() {\n       *       if (!memoizedTemplate) {\n       *         memoizedTemplate = super.template.cloneNode(true);\n       *         let subContent = document.createElement('div');\n       *         subContent.textContent = 'This came from MySubClass';\n       *         memoizedTemplate.content.appendChild(subContent);\n       *       }\n       *       return memoizedTemplate;\n       *     }\n       *   }\n       *\n       * @return {HTMLTemplateElement|string} Template to be stamped\n       */\n      static get template() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n          this._template = Polymer.DomModule && Polymer.DomModule.import(\n            /** @type PolymerElementConstructor*/ (this).is, 'template') ||\n            // note: implemented so a subclass can retrieve the super\n            // template; call the super impl this way so that `this` points\n            // to the superclass.\n            Object.getPrototypeOf(/** @type PolymerElementConstructor*/ (this).prototype).constructor.template;\n        }\n        return this._template;\n      }\n\n      /**\n       * Path matching the url from which the element was imported.\n       * This path is used to resolve url's in template style cssText.\n       * The `importPath` property is also set on element instances and can be\n       * used to create bindings relative to the import path.\n       * Defaults to the path matching the url containing a `dom-module` element\n       * matching this element's static `is` property.\n       * Note, this path should contain a trailing `/`.\n       *\n       * @return {string} The import path for this element class\n       */\n      static get importPath() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n            const module = Polymer.DomModule && Polymer.DomModule.import(/** @type PolymerElementConstructor */ (this).is);\n            this._importPath = module ? module.assetpath : '' ||\n            Object.getPrototypeOf(/** @type PolymerElementConstructor*/ (this).prototype).constructor.importPath;\n        }\n        return this._importPath;\n      }\n\n      /**\n       * Overrides the default `Polymer.PropertyAccessors` to ensure class\n       * metaprogramming related to property accessors and effects has\n       * completed (calls `finalize`).\n       *\n       * It also initializes any property defaults provided via `value` in\n       * `properties` metadata.\n       *\n       * @override\n       * @suppress {invalidCasts}\n       */\n      _initializeProperties() {\n        Polymer.telemetry.instanceCount++;\n        this.constructor.finalize();\n        const importPath = this.constructor.importPath;\n        // note: finalize template when we have access to `localName` to\n        // avoid dependence on `is` for polyfilling styling.\n        if (this._template && !this._template.__polymerFinalized) {\n          this._template.__polymerFinalized = true;\n          const baseURI =\n            importPath ? Polymer.ResolveUrl.resolveUrl(importPath) : '';\n          finalizeTemplate(/** @type {!PolymerElement} */(this.__proto__), this._template, baseURI,\n            /**@type {!HTMLElement}*/(this).localName);\n        }\n        super._initializeProperties();\n        // set path defaults\n        this.rootPath = Polymer.rootPath;\n        this.importPath = importPath;\n        // apply property defaults...\n        let p$ = propertyDefaultsForClass(this.constructor);\n        if (!p$) {\n          return;\n        }\n        for (let p in p$) {\n          let info = p$[p];\n          // Don't set default value if there is already an own property, which\n          // happens when a `properties` property with default but no effects had\n          // a property set (e.g. bound) by its host before upgrade\n          if (!this.hasOwnProperty(p)) {\n            let value = typeof info.value == 'function' ?\n              info.value.call(this) :\n              info.value;\n            // Set via `_setProperty` if there is an accessor, to enable\n            // initializing readOnly property defaults\n            if (this._hasAccessor(p)) {\n              this._setPendingProperty(p, value, true);\n            } else {\n              this[p] = value;\n            }\n          }\n        }\n      }\n\n      /**\n       * Provides a default implementation of the standard Custom Elements\n       * `connectedCallback`.\n       *\n       * The default implementation enables the property effects system and\n       * flushes any pending properties, and updates shimmed CSS properties\n       * when using the ShadyCSS scoping/custom properties polyfill.\n       *\n       * @suppress {invalidCasts}\n       */\n      connectedCallback() {\n        if (window.ShadyCSS && this._template) {\n          window.ShadyCSS.styleElement(/** @type {!HTMLElement} */(this));\n        }\n        this._enableProperties();\n      }\n\n      /**\n       * Provides a default implementation of the standard Custom Elements\n       * `disconnectedCallback`.\n       */\n      disconnectedCallback() {}\n\n      /**\n       * Stamps the element template.\n       *\n       * @override\n       */\n      ready() {\n        if (this._template) {\n          this.root = this._stampTemplate(this._template);\n          this.$ = this.root.$;\n        }\n        super.ready();\n      }\n\n      /**\n       * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n       * element dom by calling `_attachDom` with the dom stamped from the\n       * element's template via `_stampTemplate`. Note that this allows\n       * client dom to be attached to the element prior to any observers\n       * running.\n       *\n       * @override\n       */\n      _readyClients() {\n        if (this._template) {\n          this.root = this._attachDom(this.root);\n        }\n        // The super._readyClients here sets the clients initialized flag.\n        // We must wait to do this until after client dom is created/attached\n        // so that this flag can be checked to prevent notifications fired\n        // during this process from being handled before clients are ready.\n        super._readyClients();\n      }\n\n\n      /**\n       * Attaches an element's stamped dom to itself. By default,\n       * this method creates a `shadowRoot` and adds the dom to it.\n       * However, this method may be overridden to allow an element\n       * to put its dom in another location.\n       *\n       * @throws {Error}\n       * @suppress {missingReturn}\n       * @param {NodeList} dom to attach to the element.\n       * @return {Node} node to which the dom has been attached.\n       */\n      _attachDom(dom) {\n        if (this.attachShadow) {\n          if (dom) {\n            if (!this.shadowRoot) {\n              this.attachShadow({mode: 'open'});\n            }\n            this.shadowRoot.appendChild(dom);\n            return this.shadowRoot;\n          }\n          return null;\n        } else {\n          throw new Error('ShadowDOM not available. ' +\n            // TODO(sorvell): move to compile-time conditional when supported\n          'Polymer.Element can create dom as children instead of in ' +\n          'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n        }\n      }\n\n      /**\n       * Provides a default implementation of the standard Custom Elements\n       * `attributeChangedCallback`.\n       *\n       * By default, attributes declared in `properties` metadata are\n       * deserialized using their `type` information to properties of the\n       * same name.  \"Dash-cased\" attributes are deserialzed to \"camelCase\"\n       * properties.\n       *\n       * @param {string} name Name of attribute.\n       * @param {?string} old Old value of attribute.\n       * @param {?string} value Current value of attribute.\n       * @override\n       */\n      attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n          let property = caseMap.dashToCamelCase(name);\n          let type = propertiesForClass(this.constructor)[property].type;\n          if (!this._hasReadOnlyEffect(property)) {\n            this._attributeToProperty(name, value, type);\n          }\n        }\n      }\n\n      /**\n       * When using the ShadyCSS scoping and custom property shim, causes all\n       * shimmed styles in this element (and its subtree) to be updated\n       * based on current custom property values.\n       *\n       * The optional parameter overrides inline custom property styles with an\n       * object of properties where the keys are CSS properties, and the values\n       * are strings.\n       *\n       * Example: `this.updateStyles({'--color': 'blue'})`\n       *\n       * These properties are retained unless a value of `null` is set.\n       *\n       * @param {Object=} properties Bag of custom property key/values to\n       *   apply to this element.\n       * @suppress {invalidCasts}\n       */\n      updateStyles(properties) {\n        if (window.ShadyCSS) {\n          window.ShadyCSS.styleSubtree(/** @type {!HTMLElement} */(this), properties);\n        }\n      }\n\n      /**\n       * Rewrites a given URL relative to a base URL. The base URL defaults to\n       * the original location of the document containing the `dom-module` for\n       * this element. This method will return the same URL before and after\n       * bundling.\n       *\n       * @param {string} url URL to resolve.\n       * @param {string=} base Optional base URL to resolve against, defaults\n       * to the element's `importPath`\n       * @return {string} Rewritten URL relative to base\n       */\n      resolveUrl(url, base) {\n        if (!base && this.importPath) {\n          base = Polymer.ResolveUrl.resolveUrl(this.importPath);\n        }\n        return Polymer.ResolveUrl.resolveUrl(url, base);\n      }\n\n      /**\n       * Overrides `PropertyAccessors` to add map of dynamic functions on\n       * template info, for consumption by `PropertyEffects` template binding\n       * code. This map determines which method templates should have accessors\n       * created for them.\n       *\n       * @override\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n      static _parseTemplateContent(template, templateInfo, nodeInfo) {\n        templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);\n        return super._parseTemplateContent(template, templateInfo, nodeInfo);\n      }\n\n    }\n\n    return PolymerElement;\n  });\n\n  /**\n   * Provides basic tracking of element definitions (registrations) and\n   * instance counts.\n   *\n   * @namespace\n   * @summary Provides basic tracking of element definitions (registrations) and\n   * instance counts.\n   */\n  Polymer.telemetry = {\n    /**\n     * Total number of Polymer element instances created.\n     * @type {number}\n     */\n    instanceCount: 0,\n    /**\n     * Array of Polymer element classes that have been finalized.\n     * @type {Array<Polymer.Element>}\n     */\n    registrations: [],\n    /**\n     * @param {!PolymerElementConstructor} prototype Element prototype to log\n     * @this {this}\n     * @private\n     */\n    _regLog: function(prototype) {\n      console.log('[' + prototype.is + ']: registered')\n    },\n    /**\n     * Registers a class prototype for telemetry purposes.\n     * @param {HTMLElement} prototype Element prototype to register\n     * @this {this}\n     * @protected\n     */\n    register: function(prototype) {\n      this.registrations.push(prototype);\n      Polymer.log && this._regLog(prototype);\n    },\n    /**\n     * Logs all elements registered with an `is` to the console.\n     * @public\n     * @this {this}\n     */\n    dumpRegistrations: function() {\n      this.registrations.forEach(this._regLog);\n    }\n  };\n\n  /**\n   * When using the ShadyCSS scoping and custom property shim, causes all\n   * shimmed `styles` (via `custom-style`) in the document (and its subtree)\n   * to be updated based on current custom property values.\n   *\n   * The optional parameter overrides inline custom property styles with an\n   * object of properties where the keys are CSS properties, and the values\n   * are strings.\n   *\n   * Example: `Polymer.updateStyles({'--color': 'blue'})`\n   *\n   * These properties are retained unless a value of `null` is set.\n   *\n   * @param {Object=} props Bag of custom property key/values to\n   *   apply to the document.\n   */\n  Polymer.updateStyles = function(props) {\n    if (window.ShadyCSS) {\n      window.ShadyCSS.styleDocument(props);\n    }\n  };\n\n})();\n</script>\n\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/mixins/element-mixin.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n\n<link rel=\"import\" href=\"../utils/boot.html\">\n<link rel=\"import\" href=\"../utils/resolve-url.html\">\n\n<script>\n/** @suppress {deprecated} */\n(function() {\n  'use strict';\n\n  /**\n   * Legacy settings.\n   * @namespace\n   * @memberof Polymer\n   */\n  const settings = Polymer.Settings || {};\n  settings.useShadow = !(window.ShadyDOM);\n  settings.useNativeCSSProperties =\n    Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);\n  settings.useNativeCustomElements =\n    !(window.customElements.polyfillWrapFlushCallback);\n\n  /**\n   * Sets the global, legacy settings.\n   *\n   * @deprecated\n   * @memberof Polymer\n   */\n  Polymer.Settings = settings;\n\n  /**\n   * Globally settable property that is automatically assigned to\n   * `Polymer.ElementMixin` instances, useful for binding in templates to\n   * make URL's relative to an application's root.  Defaults to the main\n   * document URL, but can be overridden by users.  It may be useful to set\n   * `Polymer.rootPath` to provide a stable application mount path when\n   * using client side routing.\n   *\n   * @memberof Polymer\n   */\n  let rootPath = Polymer.rootPath ||\n    Polymer.ResolveUrl.pathFromUrl(document.baseURI || window.location.href);\n\n  Polymer.rootPath = rootPath;\n\n  /**\n   * Sets the global rootPath property used by `Polymer.ElementMixin` and\n   * available via `Polymer.rootPath`.\n   *\n   * @memberof Polymer\n   * @param {string} path The new root path\n   */\n  Polymer.setRootPath = function(path) {\n    Polymer.rootPath = path;\n  }\n})();\n</script>\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/utils/settings.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n<link rel=\"import\" href=\"resolve-url.html\">\n<script>\n(function() {\n  'use strict';\n\n  const MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';\n  const INCLUDE_ATTR = 'include';\n\n  function importModule(moduleId) {\n    if (!Polymer.DomModule) {\n      return null;\n    }\n    return Polymer.DomModule.import(moduleId);\n  }\n\n  /** @typedef {{assetpath: string}} */\n  let templateWithAssetPath; // eslint-disable-line no-unused-vars\n\n  /**\n   * Module with utilities for collection CSS text from `<templates>`, external\n   * stylesheets, and `dom-module`s.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module with utilities for collection CSS text from various sources.\n   */\n  const StyleGather = {\n\n    /**\n     * Returns CSS text of styles in a space-separated list of `dom-module`s.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {string} moduleIds List of dom-module id's within which to\n     * search for css.\n     * @return {string} Concatenated CSS content from specified `dom-module`s\n     * @this {StyleGather}\n     */\n    cssFromModules(moduleIds) {\n      let modules = moduleIds.trim().split(' ');\n      let cssText = '';\n      for (let i=0; i < modules.length; i++) {\n        cssText += this.cssFromModule(modules[i]);\n      }\n      return cssText;\n    },\n\n    /**\n     * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`\n     * can come either from `<style>`s within the first `<template>`, or else\n     * from one or more `<link rel=\"import\" type=\"css\">` links outside the\n     * template.\n     *\n     * Any `<styles>` processed are removed from their original location.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {string} moduleId dom-module id to gather styles from\n     * @return {string} Concatenated CSS content from specified `dom-module`\n     * @this {StyleGather}\n     */\n    cssFromModule(moduleId) {\n      let m = importModule(moduleId);\n      if (m && m._cssText === undefined) {\n        let cssText = '';\n        // include css from the first template in the module\n        let t = m.querySelector('template');\n        if (t) {\n          cssText += this.cssFromTemplate(t, /** @type {templateWithAssetPath }*/(m).assetpath);\n        }\n        // module imports: <link rel=\"import\" type=\"css\">\n        cssText += this.cssFromModuleImports(moduleId);\n        m._cssText = cssText || null;\n      }\n      if (!m) {\n        console.warn('Could not find style data in module named', moduleId);\n      }\n      return m && m._cssText || '';\n    },\n\n    /**\n     * Returns CSS text of `<styles>` within a given template.\n     *\n     * Any `<styles>` processed are removed from their original location.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {HTMLTemplateElement} template Template to gather styles from\n     * @param {string} baseURI Base URI to resolve the URL against\n     * @return {string} Concatenated CSS content from specified template\n     * @this {StyleGather}\n     */\n    cssFromTemplate(template, baseURI) {\n      let cssText = '';\n      // if element is a template, get content from its .content\n      let e$ = template.content.querySelectorAll('style');\n      for (let i=0; i < e$.length; i++) {\n        let e = e$[i];\n        // support style sharing by allowing styles to \"include\"\n        // other dom-modules that contain styling\n        let include = e.getAttribute(INCLUDE_ATTR);\n        if (include) {\n          cssText += this.cssFromModules(include);\n        }\n        e.parentNode.removeChild(e);\n        cssText += baseURI ?\n          Polymer.ResolveUrl.resolveCss(e.textContent, baseURI) : e.textContent;\n      }\n      return cssText;\n    },\n\n    /**\n     * Returns CSS text from stylsheets loaded via `<link rel=\"import\" type=\"css\">`\n     * links within the specified `dom-module`.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {string} moduleId Id of `dom-module` to gather CSS from\n     * @return {string} Concatenated CSS content from links in specified `dom-module`\n     * @this {StyleGather}\n     */\n    cssFromModuleImports(moduleId) {\n      let cssText = '';\n      let m = importModule(moduleId);\n      if (!m) {\n        return cssText;\n      }\n      let p$ = m.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);\n      for (let i=0; i < p$.length; i++) {\n        let p = p$[i];\n        if (p.import) {\n          let importDoc = p.import;\n          // NOTE: polyfill affordance.\n          // under the HTMLImports polyfill, there will be no 'body',\n          // but the import pseudo-doc can be used directly.\n          let container = importDoc.body ? importDoc.body : importDoc;\n          cssText +=\n            Polymer.ResolveUrl.resolveCss(container.textContent,\n              importDoc.baseURI);\n        }\n      }\n      return cssText;\n    }\n  };\n\n  Polymer.StyleGather = StyleGather;\n})();\n</script>\n\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/utils/style-gather.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n<link rel=\"import\" href=\"../utils/boot.html\">\n<link rel=\"import\" href=\"../utils/array-splice.html\">\n<link rel=\"import\" href=\"../utils/async.html\">\n<script>\n(function() {\n  'use strict';\n\n  /**\n   * Returns true if `node` is a slot element\n   * @param {HTMLElement} node Node to test.\n   * @return {boolean} Returns true if the given `node` is a slot\n   * @private\n   */\n  function isSlot(node) {\n    return (node.localName === 'slot');\n  }\n\n  /**\n   * Class that listens for changes (additions or removals) to\n   * \"flattened nodes\" on a given `node`. The list of flattened nodes consists\n   * of a node's children and, for any children that are `<slot>` elements,\n   * the expanded flattened list of `assignedNodes`.\n   * For example, if the observed node has children `<a></a><slot></slot><b></b>`\n   * and the `<slot>` has one `<div>` assigned to it, then the flattened\n   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other\n   * `<slot>` elements assigned to it, these are flattened as well.\n   *\n   * The provided `callback` is called whenever any change to this list\n   * of flattened nodes occurs, where an addition or removal of a node is\n   * considered a change. The `callback` is called with one argument, an object\n   * containing an array of any `addedNodes` and `removedNodes`.\n   *\n   * Note: the callback is called asynchronous to any changes\n   * at a microtask checkpoint. This is because observation is performed using\n   * `MutationObserver` and the `<slot>` element's `slotchange` event which\n   * are asynchronous.\n   *\n   * @memberof Polymer\n   * @summary Class that listens for changes (additions or removals) to\n   * \"flattened nodes\" on a given `node`.\n   */\n  class FlattenedNodesObserver {\n\n    /**\n     * Returns the list of flattened nodes for the given `node`.\n     * This list consists of a node's children and, for any children\n     * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.\n     * For example, if the observed node has children `<a></a><slot></slot><b></b>`\n     * and the `<slot>` has one `<div>` assigned to it, then the flattened\n     * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other\n     * `<slot>` elements assigned to it, these are flattened as well.\n     *\n     * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.\n     * @return {Array} The list of flattened nodes for the given `node`.\n    */\n    static getFlattenedNodes(node) {\n      if (isSlot(node)) {\n        return /** @type {HTMLSlotElement} */ (node).assignedNodes({flatten: true});\n      } else {\n        return Array.from(node.childNodes).map(node => {\n          if (isSlot(node)) {\n            return /** @type {HTMLSlotElement} */ (node).assignedNodes({flatten: true});\n          } else {\n            return [node];\n          }\n        }).reduce((a, b) => a.concat(b), []);\n      }\n    }\n\n    /**\n     * @param {Node} target Node on which to listen for changes.\n     * @param {Function} callback Function called when there are additions\n     * or removals from the target's list of flattened nodes.\n    */\n    constructor(target, callback) {\n      /** @type {MutationObserver} */\n      this._shadyChildrenObserver = null;\n      /** @type {MutationObserver} */\n      this._nativeChildrenObserver = null;\n      this._connected = false;\n      this._target = target;\n      this.callback = callback;\n      this._effectiveNodes = [];\n      this._observer = null;\n      this._scheduled = false;\n      /** @type {function()} */\n      this._boundSchedule = () => {\n        this._schedule();\n      }\n      this.connect();\n      this._schedule();\n    }\n\n    /**\n     * Activates an observer. This method is automatically called when\n     * a `FlattenedNodesObserver` is created. It should only be called to\n     * re-activate an observer that has been deactivated via the `disconnect` method.\n     */\n    connect() {\n      if (isSlot(this._target)) {\n        this._listenSlots([this._target]);\n      } else {\n        this._listenSlots(this._target.children);\n        if (window.ShadyDOM) {\n          this._shadyChildrenObserver =\n            ShadyDOM.observeChildren(this._target, (mutations) => {\n              this._processMutations(mutations);\n            });\n        } else {\n          this._nativeChildrenObserver =\n            new MutationObserver((mutations) => {\n              this._processMutations(mutations);\n            });\n          this._nativeChildrenObserver.observe(this._target, {childList: true});\n        }\n      }\n      this._connected = true;\n    }\n\n    /**\n     * Deactivates the flattened nodes observer. After calling this method\n     * the observer callback will not be called when changes to flattened nodes\n     * occur. The `connect` method may be subsequently called to reactivate\n     * the observer.\n     */\n    disconnect() {\n      if (isSlot(this._target)) {\n        this._unlistenSlots([this._target]);\n      } else {\n        this._unlistenSlots(this._target.children);\n        if (window.ShadyDOM && this._shadyChildrenObserver) {\n          ShadyDOM.unobserveChildren(this._shadyChildrenObserver);\n          this._shadyChildrenObserver = null;\n        } else if (this._nativeChildrenObserver) {\n          this._nativeChildrenObserver.disconnect();\n          this._nativeChildrenObserver = null;\n        }\n      }\n      this._connected = false;\n    }\n\n    _schedule() {\n      if (!this._scheduled) {\n        this._scheduled = true;\n        Polymer.Async.microTask.run(() => this.flush());\n      }\n    }\n\n    _processMutations(mutations) {\n      this._processSlotMutations(mutations);\n      this.flush();\n    }\n\n    _processSlotMutations(mutations) {\n      if (mutations) {\n        for (let i=0; i < mutations.length; i++) {\n          let mutation = mutations[i];\n          if (mutation.addedNodes) {\n            this._listenSlots(mutation.addedNodes);\n          }\n          if (mutation.removedNodes) {\n            this._unlistenSlots(mutation.removedNodes);\n          }\n        }\n      }\n    }\n\n    /**\n     * Flushes the observer causing any pending changes to be immediately\n     * delivered the observer callback. By default these changes are delivered\n     * asynchronously at the next microtask checkpoint.\n     *\n     * @return {boolean} Returns true if any pending changes caused the observer\n     * callback to run.\n     */\n    flush() {\n      if (!this._connected) {\n        return false;\n      }\n      if (window.ShadyDOM) {\n        ShadyDOM.flush();\n      }\n      if (this._nativeChildrenObserver) {\n        this._processSlotMutations(this._nativeChildrenObserver.takeRecords());\n      } else if (this._shadyChildrenObserver) {\n        this._processSlotMutations(this._shadyChildrenObserver.takeRecords());\n      }\n      this._scheduled = false;\n      let info = {\n        target: this._target,\n        addedNodes: [],\n        removedNodes: []\n      };\n      let newNodes = this.constructor.getFlattenedNodes(this._target);\n      let splices = Polymer.ArraySplice.calculateSplices(newNodes,\n        this._effectiveNodes);\n      // process removals\n      for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {\n        for (let j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\n          info.removedNodes.push(n);\n        }\n      }\n      // process adds\n      for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {\n        for (let j=s.index; j < s.index + s.addedCount; j++) {\n          info.addedNodes.push(newNodes[j]);\n        }\n      }\n      // update cache\n      this._effectiveNodes = newNodes;\n      let didFlush = false;\n      if (info.addedNodes.length || info.removedNodes.length) {\n        didFlush = true;\n        this.callback.call(this._target, info);\n      }\n      return didFlush;\n    }\n\n    _listenSlots(nodeList) {\n      for (let i=0; i < nodeList.length; i++) {\n        let n = nodeList[i];\n        if (isSlot(n)) {\n          n.addEventListener('slotchange', this._boundSchedule);\n        }\n      }\n    }\n\n    _unlistenSlots(nodeList) {\n      for (let i=0; i < nodeList.length; i++) {\n        let n = nodeList[i];\n        if (isSlot(n)) {\n          n.removeEventListener('slotchange', this._boundSchedule);\n        }\n      }\n    }\n\n  }\n\n  Polymer.FlattenedNodesObserver = FlattenedNodesObserver;\n\n})();\n</script>\n\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/utils/flattened-nodes-observer.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n<link rel=\"import\" href=\"boot.html\">\n<script>\n(function() {\n\n  'use strict';\n\n  function newSplice(index, removed, addedCount) {\n    return {\n      index: index,\n      removed: removed,\n      addedCount: addedCount\n    };\n  }\n\n  const EDIT_LEAVE = 0;\n  const EDIT_UPDATE = 1;\n  const EDIT_ADD = 2;\n  const EDIT_DELETE = 3;\n\n  // Note: This function is *based* on the computation of the Levenshtein\n  // \"edit\" distance. The one change is that \"updates\" are treated as two\n  // edits - not one. With Array splices, an update is really a delete\n  // followed by an add. By retaining this, we optimize for \"keeping\" the\n  // maximum array items in the original array. For example:\n  //\n  //   'xxxx123' -> '123yyyy'\n  //\n  // With 1-edit updates, the shortest path would be just to update all seven\n  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n  // leaves the substring '123' intact.\n  function calcEditDistances(current, currentStart, currentEnd,\n                              old, oldStart, oldEnd) {\n    // \"Deletion\" columns\n    let rowCount = oldEnd - oldStart + 1;\n    let columnCount = currentEnd - currentStart + 1;\n    let distances = new Array(rowCount);\n\n    // \"Addition\" rows. Initialize null column.\n    for (let i = 0; i < rowCount; i++) {\n      distances[i] = new Array(columnCount);\n      distances[i][0] = i;\n    }\n\n    // Initialize null row\n    for (let j = 0; j < columnCount; j++)\n      distances[0][j] = j;\n\n    for (let i = 1; i < rowCount; i++) {\n      for (let j = 1; j < columnCount; j++) {\n        if (equals(current[currentStart + j - 1], old[oldStart + i - 1]))\n          distances[i][j] = distances[i - 1][j - 1];\n        else {\n          let north = distances[i - 1][j] + 1;\n          let west = distances[i][j - 1] + 1;\n          distances[i][j] = north < west ? north : west;\n        }\n      }\n    }\n\n    return distances;\n  }\n\n  // This starts at the final weight, and walks \"backward\" by finding\n  // the minimum previous weight recursively until the origin of the weight\n  // matrix.\n  function spliceOperationsFromEditDistances(distances) {\n    let i = distances.length - 1;\n    let j = distances[0].length - 1;\n    let current = distances[i][j];\n    let edits = [];\n    while (i > 0 || j > 0) {\n      if (i == 0) {\n        edits.push(EDIT_ADD);\n        j--;\n        continue;\n      }\n      if (j == 0) {\n        edits.push(EDIT_DELETE);\n        i--;\n        continue;\n      }\n      let northWest = distances[i - 1][j - 1];\n      let west = distances[i - 1][j];\n      let north = distances[i][j - 1];\n\n      let min;\n      if (west < north)\n        min = west < northWest ? west : northWest;\n      else\n        min = north < northWest ? north : northWest;\n\n      if (min == northWest) {\n        if (northWest == current) {\n          edits.push(EDIT_LEAVE);\n        } else {\n          edits.push(EDIT_UPDATE);\n          current = northWest;\n        }\n        i--;\n        j--;\n      } else if (min == west) {\n        edits.push(EDIT_DELETE);\n        i--;\n        current = west;\n      } else {\n        edits.push(EDIT_ADD);\n        j--;\n        current = north;\n      }\n    }\n\n    edits.reverse();\n    return edits;\n  }\n\n  /**\n   * Splice Projection functions:\n   *\n   * A splice map is a representation of how a previous array of items\n   * was transformed into a new array of items. Conceptually it is a list of\n   * tuples of\n   *\n   *   <index, removed, addedCount>\n   *\n   * which are kept in ascending index order of. The tuple represents that at\n   * the |index|, |removed| sequence of items were removed, and counting forward\n   * from |index|, |addedCount| items were added.\n   */\n\n  /**\n   * Lacking individual splice mutation information, the minimal set of\n   * splices can be synthesized given the previous state and final state of an\n   * array. The basic approach is to calculate the edit distance matrix and\n   * choose the shortest path through it.\n   *\n   * Complexity: O(l * p)\n   *   l: The length of the current array\n   *   p: The length of the old array\n   *\n   * @param {Array} current The current \"changed\" array for which to\n   * calculate splices.\n   * @param {number} currentStart Starting index in the `current` array for\n   * which splices are calculated.\n   * @param {number} currentEnd Ending index in the `current` array for\n   * which splices are calculated.\n   * @param {Array} old The original \"unchanged\" array to compare `current`\n   * against to determine splices.\n   * @param {number} oldStart Starting index in the `old` array for\n   * which splices are calculated.\n   * @param {number} oldEnd Ending index in the `old` array for\n   * which splices are calculated.\n   * @return {Array} Returns an array of splice record objects. Each of these\n   * contains: `index` the location where the splice occurred; `removed`\n   * the array of removed items from this location; `addedCount` the number\n   * of items added at this location.\n   */\n  function calcSplices(current, currentStart, currentEnd,\n                        old, oldStart, oldEnd) {\n    let prefixCount = 0;\n    let suffixCount = 0;\n    let splice;\n\n    let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n    if (currentStart == 0 && oldStart == 0)\n      prefixCount = sharedPrefix(current, old, minLength);\n\n    if (currentEnd == current.length && oldEnd == old.length)\n      suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n\n    currentStart += prefixCount;\n    oldStart += prefixCount;\n    currentEnd -= suffixCount;\n    oldEnd -= suffixCount;\n\n    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n      return [];\n\n    if (currentStart == currentEnd) {\n      splice = newSplice(currentStart, [], 0);\n      while (oldStart < oldEnd)\n        splice.removed.push(old[oldStart++]);\n\n      return [ splice ];\n    } else if (oldStart == oldEnd)\n      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\n    let ops = spliceOperationsFromEditDistances(\n        calcEditDistances(current, currentStart, currentEnd,\n                               old, oldStart, oldEnd));\n\n    splice = undefined;\n    let splices = [];\n    let index = currentStart;\n    let oldIndex = oldStart;\n    for (let i = 0; i < ops.length; i++) {\n      switch(ops[i]) {\n        case EDIT_LEAVE:\n          if (splice) {\n            splices.push(splice);\n            splice = undefined;\n          }\n\n          index++;\n          oldIndex++;\n          break;\n        case EDIT_UPDATE:\n          if (!splice)\n            splice = newSplice(index, [], 0);\n\n          splice.addedCount++;\n          index++;\n\n          splice.removed.push(old[oldIndex]);\n          oldIndex++;\n          break;\n        case EDIT_ADD:\n          if (!splice)\n            splice = newSplice(index, [], 0);\n\n          splice.addedCount++;\n          index++;\n          break;\n        case EDIT_DELETE:\n          if (!splice)\n            splice = newSplice(index, [], 0);\n\n          splice.removed.push(old[oldIndex]);\n          oldIndex++;\n          break;\n      }\n    }\n\n    if (splice) {\n      splices.push(splice);\n    }\n    return splices;\n  }\n\n  function sharedPrefix(current, old, searchLength) {\n    for (let i = 0; i < searchLength; i++)\n      if (!equals(current[i], old[i]))\n        return i;\n    return searchLength;\n  }\n\n  function sharedSuffix(current, old, searchLength) {\n    let index1 = current.length;\n    let index2 = old.length;\n    let count = 0;\n    while (count < searchLength && equals(current[--index1], old[--index2]))\n      count++;\n\n    return count;\n  }\n\n  function calculateSplices(current, previous) {\n    return calcSplices(current, 0, current.length, previous, 0,\n                            previous.length);\n  }\n\n  function equals(currentValue, previousValue) {\n    return currentValue === previousValue;\n  }\n\n  /**\n   * @namespace\n   * @memberof Polymer\n   * @summary Module that provides utilities for diffing arrays.\n   */\n  Polymer.ArraySplice = {\n    /**\n     * Returns an array of splice records indicating the minimum edits required\n     * to transform the `previous` array into the `current` array.\n     *\n     * Splice records are ordered by index and contain the following fields:\n     * - `index`: index where edit started\n     * - `removed`: array of removed items from this index\n     * - `addedCount`: number of items added at this index\n     *\n     * This function is based on the Levenshtein \"minimum edit distance\"\n     * algorithm. Note that updates are treated as removal followed by addition.\n     *\n     * The worst-case time complexity of this algorithm is `O(l * p)`\n     *   l: The length of the current array\n     *   p: The length of the previous array\n     *\n     * However, the worst-case complexity is reduced by an `O(n)` optimization\n     * to detect any shared prefix & suffix between the two arrays and only\n     * perform the more expensive minimum edit distance calculation over the\n     * non-shared portions of the arrays.\n     *\n     * @memberof Polymer.ArraySplice\n     * @param {Array} current The \"changed\" array for which splices will be\n     * calculated.\n     * @param {Array} previous The \"unchanged\" original array to compare\n     * `current` against to determine the splices.\n     * @return {Array} Returns an array of splice record objects. Each of these\n     * contains: `index` the location where the splice occurred; `removed`\n     * the array of removed items from this location; `addedCount` the number\n     * of items added at this location.\n     */\n    calculateSplices\n  }\n\n})();\n</script>\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/utils/array-splice.html","import 'polymer/polymer-element.html'\nimport 'polymer/lib/utils/flattened-nodes-observer.html'\nimport LocationMixin from '../mixins/location-mixin.js'\nimport QueryParamsMixin from '../mixins/query-params-mixin.js'\nimport pathToRegexp from 'path-to-regexp'\nimport routing from '../../src/routing.js'\nimport httpCodes from '../../src/http-codes.js'\nimport partials from '../../src/partials.js'\nimport auth from '../../src/authentication/index.js'\n\nconst messages = []\nclass AppShell extends QueryParamsMixin(LocationMixin(Polymer.Element)) {\n  static get is () { return 'app-shell' }\n\n  static get properties () {\n    return {\n      params: {\n        type: Object\n      },\n\n      queryParams: {\n        type: Object\n      },\n\n      currentRoute: {\n        type: String\n      },\n\n      // location-mixin\n      path: {\n        type: String\n      },\n\n      query: {\n        type: String,\n        observer: '_queryChanged'\n      },\n\n      urlSpaceRegex: {\n        type: String\n      },\n\n      hash: {\n        type: String\n      },\n\n      dwellTime: {\n        type: Number\n      },\n\n      _urlSpaceRegExp: {\n        type: String,\n        computed: '_makeRegExp(urlSpaceRegex)'\n      },\n\n      _lastChangedAt: {\n        type: String\n      },\n\n      _initialized: {\n        type: Boolean\n      },\n\n      // query params 'paramsString', 'paramsObject', '_dontReact'\n\n      paramsString: {\n        type: String,\n        observer: '_paramsStringChanged'\n      },\n\n      paramsObject: {\n        type: Object\n      },\n\n      _dontReact: {\n        type: Boolean\n      }\n    }\n  }\n\n  static get observers () {\n    return [\n      '_pathChanged(path)',\n      '_updateUrl(path, query, hash)'\n    ]\n  }\n\n  static get template () {\n    return `\n      <style is=\"custom-style\">\n        div[role='main'] {\n          position: relative;\n        }\n\n        ::slotted(.page) {\n          position: absolute;\n          background-color: white;\n          width: 100%;\n          top: 0;\n          opacity: 0;\n          z-index: -1;\n          transition: opacity 0.3s;\n          display: none;\n        }\n\n        ::slotted(*) > .page {\n          position: absolute;\n          background-color: white;\n          width: 100%;\n          top: 0;\n          opacity: 0;\n          z-index: -1;\n          transition: opacity 0.3s;\n          display: none;\n        }\n\n        ::slotted(.page--on-view) {\n          position: relative !important;\n          opacity: 1;\n          z-index: 0;\n          display: block;\n        }\n\n        ::slotted(*) > .page--on-view {\n          position: relative !important;\n          opacity: 1;\n          z-index: 0;\n          display: block;\n        }\n      </style>\n\n      <div class=\"main\">\n        <slot></slot>\n      </div>\n\n      <app-toast></app-toast>\n    `\n  }\n\n  constructor () {\n    super()\n    this._routes = {}\n  }\n\n  connectedCallback () {\n    super.connectedCallback()\n    this._observer = new Polymer.FlattenedNodesObserver(this, (info) => {\n      this._contentAdded(info.addedNodes.filter((node) => (node.nodeType === window.Node.ELEMENT_NODE)))\n    })\n    import(/* webpackChunkName: \"app-toast\" */ '../modules/app-toast/components/app-toast.html').then(() => {\n      var messageInterval = setInterval(() => {\n        if (messages.length > 0) {\n          var {message, optTapHandler, optAction, optActionHandler, optDuration} = messages.pop()\n          this.showMessage(message, optTapHandler, optAction, optActionHandler, optDuration)\n        } else {\n          clearInterval(messageInterval)\n          messageInterval = null\n        }\n      }, 5000)\n    })\n  }\n\n  disconnectedCallback () {\n    if (super.disconnectedCallback) {\n      super.disconnectedCallback()\n    }\n    if (this._observer) this._observer.disconnect()\n  }\n\n  showMessage (message, optTapHandler, optAction, optActionHandler, optDuration) {\n    if (this.shadowRoot.querySelector('app-toast').showMessage) {\n      this.shadowRoot.querySelector('app-toast').showMessage(message, optTapHandler, optAction, optActionHandler, optDuration)\n    } else {\n      messages.push({message, optTapHandler, optAction, optActionHandler, optDuration})\n    }\n  }\n\n  closeToast () {\n    this.shadowRoot.querySelector('app-toast').close()\n  }\n\n  _contentAdded (pages) {\n    pages.forEach(page => {\n      page.classList.add('page')\n      this._routes[page.getAttribute('route')] = {\n        element: page,\n        auth: page.getAttribute('auth')\n      }\n    })\n    this._pathChanged(this.path)\n  }\n\n  _pathChanged (path) {\n    // load statistics if it went through here\n    if (path === '/_statistic.html' || path === '/_bundle-sizes.html') {\n      window.location.href = path\n      return\n    }\n\n    path = path.replace(/index\\.html$/, '')\n\n    var routeName = null\n    Object.entries(this._routes).forEach(route => {\n      if (routeName) return\n      var params = {}\n      const keys = []\n      const re = pathToRegexp(route[0], keys)\n      const exec = re.exec(path)\n\n      if (exec) {\n        params = {}\n        for (var j = 0; j < keys.length; j++) {\n          params[keys[j].name] = exec[j + 1]\n        }\n        routeName = route[0]\n        this.params = params\n      }\n    })\n\n    this._checkAuth(routeName || 'not-found')\n  }\n\n  _checkAuth (route) {\n    if (this._routes[route] && this._routes[route].auth && auth[this._routes[route].auth]) {\n      if (auth[this._routes[route].auth] instanceof Promise) {\n        auth[this._routes[route].auth]()\n        .then((res) => {\n          if (res) {\n            this._loadPage(route)\n          } else {\n            this._loadPage('not-authorized')\n          }\n        })\n        .catch((e) => {\n          console.log(e)\n          this._loadPage('not-authorized')\n        })\n      } else if (typeof auth[this._routes[route].auth] === 'function' && auth[this._routes[route].auth](this)) {\n        this._loadPage(route)\n      } else {\n        this._loadPage('not-authorized')\n      }\n    } else {\n      this._loadPage(route)\n    }\n  }\n\n  _loadPage (route) {\n    const routes = Object.assign({}, routing, httpCodes)\n    for (var i in this._routes) {\n      if (this._routes[i] && this._routes[i].element) this._routes[i].element.classList.remove('page--on-view')\n    }\n\n    if (this._routes[route] && this._routes[route].element) {\n      this._routes[route].element.classList.add('page--on-view')\n    }\n    if (this._routes[route]) {\n      routes[route]().then(() => {\n        this._routes[route].element._setProperty('params', this.params)\n        this._routes[route].element._setProperty('queryParams', this.paramsObject)\n        if (window.ga) {\n          ga('set', 'page', this.path)\n          ga('send', 'pageview')\n        }\n      })\n    }\n  }\n}\n\nwindow.customElements.define(AppShell.is, AppShell)\n\n// load partials here\nfor (var p in partials) {\n  partials[p]()\n}\n\nexport default AppShell\n\n\n\n// WEBPACK FOOTER //\n// ../core/shell/index.js","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n<link rel=\"import\" href=\"../utils/boot.html\">\n<link rel=\"import\" href=\"../utils/resolve-url.html\">\n<script>\n(function() {\n  'use strict';\n\n  let modules = {};\n  let lcModules = {};\n  function findModule(id) {\n    return modules[id] || lcModules[id.toLowerCase()];\n  }\n\n  function styleOutsideTemplateCheck(inst) {\n    if (inst.querySelector('style')) {\n      console.warn('dom-module %s has style outside template', inst.id);\n    }\n  }\n\n  /**\n   * The `dom-module` element registers the dom it contains to the name given\n   * by the module's id attribute. It provides a unified database of dom\n   * accessible via its static `import` API.\n   *\n   * A key use case of `dom-module` is for providing custom element `<template>`s\n   * via HTML imports that are parsed by the native HTML parser, that can be\n   * relocated during a bundling pass and still looked up by `id`.\n   *\n   * Example:\n   *\n   *     <dom-module id=\"foo\">\n   *       <img src=\"stuff.png\">\n   *     </dom-module>\n   *\n   * Then in code in some other location that cannot access the dom-module above\n   *\n   *     let img = document.createElement('dom-module').import('foo', 'img');\n   *\n   * @customElement\n   * @extends HTMLElement\n   * @memberof Polymer\n   * @summary Custom element that provides a registry of relocatable DOM content\n   *   by `id` that is agnostic to bundling.\n   * @unrestricted\n   */\n  class DomModule extends HTMLElement {\n\n    static get observedAttributes() { return ['id'] }\n\n    /**\n     * Retrieves the element specified by the css `selector` in the module\n     * registered by `id`. For example, this.import('foo', 'img');\n     * @param {string} id The id of the dom-module in which to search.\n     * @param {string=} selector The css selector by which to find the element.\n     * @return {Element} Returns the element which matches `selector` in the\n     * module registered at the specified `id`.\n     */\n    static import(id, selector) {\n      if (id) {\n        let m = findModule(id);\n        if (m && selector) {\n          return m.querySelector(selector);\n        }\n        return m;\n      }\n      return null;\n    }\n\n    attributeChangedCallback(name, old, value) {\n      if (old !== value) {\n        this.register();\n      }\n    }\n\n    /**\n     * The absolute URL of the original location of this `dom-module`.\n     *\n     * This value will differ from this element's `ownerDocument` in the\n     * following ways:\n     * - Takes into account any `assetpath` attribute added during bundling\n     *   to indicate the original location relative to the bundled location\n     * - Uses the HTMLImports polyfill's `importForElement` API to ensure\n     *   the path is relative to the import document's location since\n     *   `ownerDocument` is not currently polyfilled\n     */\n    get assetpath() {\n      // Don't override existing assetpath.\n      if (!this.__assetpath) {\n        // note: assetpath set via an attribute must be relative to this\n        // element's location; accomodate polyfilled HTMLImports\n        const owner = window.HTMLImports && HTMLImports.importForElement ?\n          HTMLImports.importForElement(this) || document : this.ownerDocument;\n        const url = Polymer.ResolveUrl.resolveUrl(\n          this.getAttribute('assetpath') || '', owner.baseURI);\n        this.__assetpath = Polymer.ResolveUrl.pathFromUrl(url);\n      }\n      return this.__assetpath;\n    }\n\n    /**\n     * Registers the dom-module at a given id. This method should only be called\n     * when a dom-module is imperatively created. For\n     * example, `document.createElement('dom-module').register('foo')`.\n     * @param {string=} id The id at which to register the dom-module.\n     */\n    register(id) {\n      id = id || this.id;\n      if (id) {\n        this.id = id;\n        // store id separate from lowercased id so that\n        // in all cases mixedCase id will stored distinctly\n        // and lowercase version is a fallback\n        modules[id] = this;\n        lcModules[id.toLowerCase()] = this;\n        styleOutsideTemplateCheck(this);\n      }\n    }\n  }\n\n  DomModule.prototype['modules'] = modules;\n\n  customElements.define('dom-module', DomModule);\n\n  // export\n  Polymer.DomModule = DomModule;\n\n})();\n</script>\n\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/elements/dom-module.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n\n<link rel=\"import\" href=\"boot.html\">\n\n<script>\n(function() {\n  'use strict';\n\n  /**\n   * Module with utilities for manipulating structured data path strings.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module with utilities for manipulating structured data path strings.\n   */\n  const Path = {\n\n    /**\n     * Returns true if the given string is a structured data path (has dots).\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.isPath('foo.bar.baz') // true\n     * Polymer.Path.isPath('foo')         // false\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} path Path string\n     * @return {boolean} True if the string contained one or more dots\n     */\n    isPath: function(path) {\n      return path.indexOf('.') >= 0;\n    },\n\n    /**\n     * Returns the root property name for the given path.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.root('foo.bar.baz') // 'foo'\n     * Polymer.Path.root('foo')         // 'foo'\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} path Path string\n     * @return {string} Root property name\n     */\n    root: function(path) {\n      let dotIndex = path.indexOf('.');\n      if (dotIndex === -1) {\n        return path;\n      }\n      return path.slice(0, dotIndex);\n    },\n\n    /**\n     * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not\n     * Returns true if the given path is an ancestor of the base path.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.isAncestor('foo.bar', 'foo')         // true\n     * Polymer.Path.isAncestor('foo.bar', 'foo.bar')     // false\n     * Polymer.Path.isAncestor('foo.bar', 'foo.bar.baz') // false\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} base Path string to test against.\n     * @param {string} path Path string to test.\n     * @return {boolean} True if `path` is an ancestor of `base`.\n     */\n    isAncestor: function(base, path) {\n      //     base.startsWith(path + '.');\n      return base.indexOf(path + '.') === 0;\n    },\n\n    /**\n     * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.isDescendant('foo.bar', 'foo.bar.baz') // true\n     * Polymer.Path.isDescendant('foo.bar', 'foo.bar')     // false\n     * Polymer.Path.isDescendant('foo.bar', 'foo')         // false\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} base Path string to test against.\n     * @param {string} path Path string to test.\n     * @return {boolean} True if `path` is a descendant of `base`.\n     */\n    isDescendant: function(base, path) {\n      //     path.startsWith(base + '.');\n      return path.indexOf(base + '.') === 0;\n    },\n\n    /**\n     * Replaces a previous base path with a new base path, preserving the\n     * remainder of the path.\n     *\n     * User must ensure `path` has a prefix of `base`.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.translate('foo.bar', 'zot' 'foo.bar.baz') // 'zot.baz'\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} base Current base string to remove\n     * @param {string} newBase New base string to replace with\n     * @param {string} path Path to translate\n     * @return {string} Translated string\n     */\n    translate: function(base, newBase, path) {\n      return newBase + path.slice(base.length);\n    },\n\n    /**\n     * @param {string} base Path string to test against\n     * @param {string} path Path string to test\n     * @return {boolean} True if `path` is equal to `base`\n     * @this {Path}\n     */\n    matches: function(base, path) {\n      return (base === path) ||\n             this.isAncestor(base, path) ||\n             this.isDescendant(base, path);\n    },\n\n    /**\n     * Converts array-based paths to flattened path.  String-based paths\n     * are returned as-is.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'\n     * Polymer.Path.normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string | !Array<string|number>} path Input path\n     * @return {string} Flattened path\n     */\n    normalize: function(path) {\n      if (Array.isArray(path)) {\n        let parts = [];\n        for (let i=0; i<path.length; i++) {\n          let args = path[i].toString().split('.');\n          for (let j=0; j<args.length; j++) {\n            parts.push(args[j]);\n          }\n        }\n        return parts.join('.');\n      } else {\n        return path;\n      }\n    },\n\n    /**\n     * Splits a path into an array of property names. Accepts either arrays\n     * of path parts or strings.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']\n     * Polymer.Path.split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string | !Array<string|number>} path Input path\n     * @return {!Array<string>} Array of path parts\n     * @this {Path}\n     * @suppress {checkTypes}\n     */\n    split: function(path) {\n      if (Array.isArray(path)) {\n        return this.normalize(path).split('.');\n      }\n      return path.toString().split('.');\n    },\n\n    /**\n     * Reads a value from a path.  If any sub-property in the path is `undefined`,\n     * this method returns `undefined` (will never throw.\n     *\n     * @memberof Polymer.Path\n     * @param {Object} root Object from which to dereference path from\n     * @param {string | !Array<string|number>} path Path to read\n     * @param {Object=} info If an object is provided to `info`, the normalized\n     *  (flattened) path will be set to `info.path`.\n     * @return {*} Value at path, or `undefined` if the path could not be\n     *  fully dereferenced.\n     * @this {Path}\n     */\n    get: function(root, path, info) {\n      let prop = root;\n      let parts = this.split(path);\n      // Loop over path parts[0..n-1] and dereference\n      for (let i=0; i<parts.length; i++) {\n        if (!prop) {\n          return;\n        }\n        let part = parts[i];\n        prop = prop[part];\n      }\n      if (info) {\n        info.path = parts.join('.');\n      }\n      return prop;\n    },\n\n    /**\n     * Sets a value to a path.  If any sub-property in the path is `undefined`,\n     * this method will no-op.\n     *\n     * @memberof Polymer.Path\n     * @param {Object} root Object from which to dereference path from\n     * @param {string | !Array<string|number>} path Path to set\n     * @param {*} value Value to set to path\n     * @return {string | undefined} The normalized version of the input path\n     * @this {Path}\n     */\n    set: function(root, path, value) {\n      let prop = root;\n      let parts = this.split(path);\n      let last = parts[parts.length-1];\n      if (parts.length > 1) {\n        // Loop over path parts[0..n-2] and dereference\n        for (let i=0; i<parts.length-1; i++) {\n          let part = parts[i];\n          prop = prop[part];\n          if (!prop) {\n            return;\n          }\n        }\n        // Set value to object at end of path\n        prop[last] = value;\n      } else {\n        // Simple property set\n        prop[path] = value;\n      }\n      return parts.join('.');\n    }\n\n  };\n\n  /**\n   * Returns true if the given string is a structured data path (has dots).\n   *\n   * This function is deprecated.  Use `Polymer.Path.isPath` instead.\n   *\n   * Example:\n   *\n   * ```\n   * Polymer.Path.isDeep('foo.bar.baz') // true\n   * Polymer.Path.isDeep('foo')         // false\n   * ```\n   *\n   * @deprecated\n   * @memberof Polymer.Path\n   * @param {string} path Path string\n   * @return {boolean} True if the string contained one or more dots\n   */\n  Path.isDeep = Path.isPath;\n\n  Polymer.Path = Path;\n\n})();\n</script>\n\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/utils/path.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n\n<link rel=\"import\" href=\"../utils/boot.html\">\n<link rel=\"import\" href=\"../utils/mixin.html\">\n<link rel=\"import\" href=\"../utils/case-map.html\">\n<link rel=\"import\" href=\"../utils/async.html\">\n\n<script>\n(function() {\n\n  'use strict';\n\n  let caseMap = Polymer.CaseMap;\n\n  let microtask = Polymer.Async.microTask;\n\n  // Save map of native properties; this forms a blacklist or properties\n  // that won't have their values \"saved\" by `saveAccessorValue`, since\n  // reading from an HTMLElement accessor from the context of a prototype throws\n  const nativeProperties = {};\n  let proto = HTMLElement.prototype;\n  while (proto) {\n    let props = Object.getOwnPropertyNames(proto);\n    for (let i=0; i<props.length; i++) {\n      nativeProperties[props[i]] = true;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  /**\n   * Used to save the value of a property that will be overridden with\n   * an accessor. If the `model` is a prototype, the values will be saved\n   * in `__dataProto`, and it's up to the user (or downstream mixin) to\n   * decide how/when to set these values back into the accessors.\n   * If `model` is already an instance (it has a `__data` property), then\n   * the value will be set as a pending property, meaning the user should\n   * call `_invalidateProperties` or `_flushProperties` to take effect\n   *\n   * @param {Object} model Prototype or instance\n   * @param {string} property Name of property\n   * @private\n   */\n  function saveAccessorValue(model, property) {\n    // Don't read/store value for any native properties since they could throw\n    if (!nativeProperties[property]) {\n      let value = model[property];\n      if (value !== undefined) {\n        if (model.__data) {\n          // Adding accessor to instance; update the property\n          // It is the user's responsibility to call _flushProperties\n          model._setPendingProperty(property, value);\n        } else {\n          // Adding accessor to proto; save proto's value for instance-time use\n          if (!model.__dataProto) {\n            model.__dataProto = {};\n          } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n            model.__dataProto = Object.create(model.__dataProto);\n          }\n          model.__dataProto[property] = value;\n        }\n      }\n    }\n  }\n\n  /**\n   * Element class mixin that provides basic meta-programming for creating one\n   * or more property accessors (getter/setter pair) that enqueue an async\n   * (batched) `_propertiesChanged` callback.\n   *\n   * For basic usage of this mixin, simply declare attributes to observe via\n   * the standard `static get observedAttributes()`, implement `_propertiesChanged`\n   * on the class, and then call `MyClass.createPropertiesForAttributes()` once\n   * on the class to generate property accessors for each observed attribute\n   * prior to instancing.  Last, call `this._flushProperties()` once to enable\n   * the accessors.\n   *\n   * Any `observedAttributes` will automatically be\n   * deserialized via `attributeChangedCallback` and set to the associated\n   * property using `dash-case`-to-`camelCase` convention.\n   *\n   * @mixinFunction\n   * @polymer\n   * @memberof Polymer\n   * @summary Element class mixin for reacting to property changes from\n   *   generated property accessors.\n   */\n  Polymer.PropertyAccessors = Polymer.dedupingMixin(superClass => {\n\n    /**\n     * @polymer\n     * @mixinClass\n     * @implements {Polymer_PropertyAccessors}\n     * @extends HTMLElement\n     * @unrestricted\n     */\n    class PropertyAccessors extends superClass {\n\n      /**\n       * Generates property accessors for all attributes in the standard\n       * static `observedAttributes` array.\n       *\n       * Attribute names are mapped to property names using the `dash-case` to\n       * `camelCase` convention\n       *\n       */\n      static createPropertiesForAttributes() {\n        let a$ = this.observedAttributes;\n        for (let i=0; i < a$.length; i++) {\n          this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[i]));\n        }\n      }\n\n      constructor() {\n        super();\n        /** @type {boolean} */\n        this.__serializing;\n        /** @type {number} */\n        this.__dataCounter;\n        /** @type {boolean} */\n        this.__dataEnabled;\n        /** @type {boolean} */\n        this.__dataReady;\n        /** @type {boolean} */\n        this.__dataInvalid;\n        /** @type {!Object} */\n        this.__data;\n        /** @type {Object} */\n        this.__dataPending;\n        /** @type {Object} */\n        this.__dataOld;\n        /** @type {Object} */\n        this.__dataProto;\n        /** @type {Object} */\n        this.__dataHasAccessor;\n        /** @type {Object} */\n        this.__dataInstanceProps;\n        this._initializeProperties();\n      }\n\n      /**\n       * Implements native Custom Elements `attributeChangedCallback` to\n       * set an attribute value to a property via `_attributeToProperty`.\n       *\n       * @param {string} name Name of attribute that changed\n       * @param {?string} old Old attribute value\n       * @param {?string} value New attribute value\n       */\n      attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n          this._attributeToProperty(name, value);\n        }\n      }\n\n      /**\n       * Initializes the local storage for property accessors.\n       *\n       * Provided as an override point for performing any setup work prior\n       * to initializing the property accessor system.\n       *\n       * @protected\n       */\n      _initializeProperties() {\n        this.__serializing = false;\n        this.__dataCounter = 0;\n        this.__dataEnabled = false;\n        this.__dataReady = false;\n        this.__dataInvalid = false;\n        this.__data = {};\n        this.__dataPending = null;\n        this.__dataOld = null;\n        if (this.__dataProto) {\n          this._initializeProtoProperties(this.__dataProto);\n          this.__dataProto = null;\n        }\n        // Capture instance properties; these will be set into accessors\n        // during first flush. Don't set them here, since we want\n        // these to overwrite defaults/constructor assignments\n        for (let p in this.__dataHasAccessor) {\n          if (this.hasOwnProperty(p)) {\n            this.__dataInstanceProps = this.__dataInstanceProps || {};\n            this.__dataInstanceProps[p] = this[p];\n            delete this[p];\n          }\n        }\n      }\n\n      /**\n       * Called at instance time with bag of properties that were overwritten\n       * by accessors on the prototype when accessors were created.\n       *\n       * The default implementation sets these properties back into the\n       * setter at instance time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @protected\n       */\n      _initializeProtoProperties(props) {\n        for (let p in props) {\n          this._setProperty(p, props[p]);\n        }\n      }\n\n      /**\n       * Called at ready time with bag of instance properties that overwrote\n       * accessors when the element upgraded.\n       *\n       * The default implementation sets these properties back into the\n       * setter at ready time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @protected\n       */\n      _initializeInstanceProperties(props) {\n        Object.assign(this, props);\n      }\n\n      /**\n       * Ensures the element has the given attribute. If it does not,\n       * assigns the given value to the attribute.\n       *\n       *\n       * @param {string} attribute Name of attribute to ensure is set.\n       * @param {string} value of the attribute.\n       */\n      _ensureAttribute(attribute, value) {\n        if (!this.hasAttribute(attribute)) {\n          this._valueToNodeAttribute(this, value, attribute);\n        }\n      }\n\n      /**\n       * Deserializes an attribute to its associated property.\n       *\n       * This method calls the `_deserializeValue` method to convert the string to\n       * a typed value.\n       *\n       * @param {string} attribute Name of attribute to deserialize.\n       * @param {?string} value of the attribute.\n       * @param {*=} type type to deserialize to.\n       */\n      _attributeToProperty(attribute, value, type) {\n        // Don't deserialize back to property if currently reflecting\n        if (!this.__serializing) {\n          let property = caseMap.dashToCamelCase(attribute);\n          this[property] = this._deserializeValue(value, type);\n        }\n      }\n\n      /**\n       * Serializes a property to its associated attribute.\n       *\n       * @param {string} property Property name to reflect.\n       * @param {string=} attribute Attribute name to reflect.\n       * @param {*=} value Property value to refect.\n       */\n      _propertyToAttribute(property, attribute, value) {\n        this.__serializing = true;\n        value = (arguments.length < 3) ? this[property] : value;\n        this._valueToNodeAttribute(this, value,\n          attribute || caseMap.camelToDashCase(property));\n        this.__serializing = false;\n      }\n\n      /**\n       * Sets a typed value to an HTML attribute on a node.\n       *\n       * This method calls the `_serializeValue` method to convert the typed\n       * value to a string.  If the `_serializeValue` method returns `undefined`,\n       * the attribute will be removed (this is the default for boolean\n       * type `false`).\n       *\n       * @param {Element} node Element to set attribute to.\n       * @param {*} value Value to serialize.\n       * @param {string} attribute Attribute name to serialize to.\n       */\n      _valueToNodeAttribute(node, value, attribute) {\n        let str = this._serializeValue(value);\n        if (str === undefined) {\n          node.removeAttribute(attribute);\n        } else {\n          node.setAttribute(attribute, str);\n        }\n      }\n\n      /**\n       * Converts a typed JavaScript value to a string.\n       *\n       * This method is called by Polymer when setting JS property values to\n       * HTML attributes.  Users may override this method on Polymer element\n       * prototypes to provide serialization for custom types.\n       *\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided property value.\n       */\n      _serializeValue(value) {\n        /* eslint-disable no-fallthrough */\n        switch (typeof value) {\n          case 'boolean':\n            return value ? '' : undefined;\n\n          case 'object':\n            if (value instanceof Date) {\n              return value.toString();\n            } else if (value) {\n              try {\n                return JSON.stringify(value);\n              } catch(x) {\n                return '';\n              }\n            }\n\n          default:\n            return value != null ? value.toString() : undefined;\n        }\n      }\n\n      /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * This method is called by Polymer when reading HTML attribute values to\n       * JS properties.  Users may override this method on Polymer element\n       * prototypes to provide deserialization for custom `type`s.  Note,\n       * the `type` argument is the value of the `type` field provided in the\n       * `properties` configuration object for a given property, and is\n       * by convention the constructor for the type to deserialize.\n       *\n       * Note: The return value of `undefined` is used as a sentinel value to\n       * indicate the attribute should be removed.\n       *\n       * @param {?string} value Attribute value to deserialize.\n       * @param {*=} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       */\n      _deserializeValue(value, type) {\n        /**\n         * @type {*}\n         */\n        let outValue;\n        switch (type) {\n          case Number:\n            outValue = Number(value);\n            break;\n\n          case Boolean:\n            outValue = (value !== null);\n            break;\n\n          case Object:\n            try {\n              outValue = JSON.parse(/** @type string */(value));\n            } catch(x) {\n              // allow non-JSON literals like Strings and Numbers\n            }\n            break;\n\n          case Array:\n            try {\n              outValue = JSON.parse(/** @type string */(value));\n            } catch(x) {\n              outValue = null;\n              console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);\n            }\n            break;\n\n          case Date:\n            outValue = new Date(value);\n            break;\n\n          case String:\n          default:\n            outValue = value;\n            break;\n        }\n\n        return outValue;\n      }\n      /* eslint-enable no-fallthrough */\n\n      /**\n       * Creates a setter/getter pair for the named property with its own\n       * local storage.  The getter returns the value in the local storage,\n       * and the setter calls `_setProperty`, which updates the local storage\n       * for the property and enqueues a `_propertiesChanged` callback.\n       *\n       * This method may be called on a prototype or an instance.  Calling\n       * this method may overwrite a property value that already exists on\n       * the prototype/instance by creating the accessor.  When calling on\n       * a prototype, any overwritten values are saved in `__dataProto`,\n       * and it is up to the subclasser to decide how/when to set those\n       * properties back into the accessor.  When calling on an instance,\n       * the overwritten value is set via `_setPendingProperty`, and the\n       * user should call `_invalidateProperties` or `_flushProperties`\n       * for the values to take effect.\n       *\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created; the\n       *   protected `_setProperty` function must be used to set the property\n       * @protected\n       */\n      _createPropertyAccessor(property, readOnly) {\n        if (!this.hasOwnProperty('__dataHasAccessor')) {\n          this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n        }\n        if (!this.__dataHasAccessor[property]) {\n          this.__dataHasAccessor[property] = true;\n          saveAccessorValue(this, property);\n          Object.defineProperty(this, property, {\n            /* eslint-disable valid-jsdoc */\n            /** @this {PropertyAccessors} */\n            get: function() {\n              return this.__data[property];\n            },\n            /** @this {PropertyAccessors} */\n            set: readOnly ? function() {} : function(value) {\n              this._setProperty(property, value);\n            }\n            /* eslint-enable */\n          });\n        }\n      }\n\n      /**\n       * Returns true if this library created an accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if an accessor was created\n       */\n      _hasAccessor(property) {\n        return this.__dataHasAccessor && this.__dataHasAccessor[property];\n      }\n\n      /**\n       * Updates the local storage for a property (via `_setPendingProperty`)\n       * and enqueues a `_proeprtiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @protected\n       */\n      _setProperty(property, value) {\n        if (this._setPendingProperty(property, value)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Updates the local storage for a property, records the previous value,\n       * and adds it to the set of \"pending changes\" that will be passed to the\n       * `_propertiesChanged` callback.  This method does not enqueue the\n       * `_propertiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @return {boolean} Returns true if the property changed\n       * @protected\n       */\n      _setPendingProperty(property, value) {\n        let old = this.__data[property];\n        let changed = this._shouldPropertyChange(property, value, old)\n        if (changed) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (this.__dataOld && !(property in this.__dataOld)) {\n            this.__dataOld[property] = old;\n          }\n          this.__data[property] = value;\n          this.__dataPending[property] = value;\n        }\n        return changed;\n      }\n\n      /**\n       * Returns true if the specified property has a pending change.\n       *\n       * @param {string} prop Property name\n       * @return {boolean} True if property has a pending change\n       * @protected\n       */\n      _isPropertyPending(prop) {\n        return Boolean(this.__dataPending && (prop in this.__dataPending));\n      }\n\n      /**\n       * Marks the properties as invalid, and enqueues an async\n       * `_propertiesChanged` callback.\n       *\n       * @protected\n       */\n      _invalidateProperties() {\n        if (!this.__dataInvalid && this.__dataReady) {\n          this.__dataInvalid = true;\n          microtask.run(() => {\n            if (this.__dataInvalid) {\n              this.__dataInvalid = false;\n              this._flushProperties();\n            }\n          });\n        }\n      }\n\n      /**\n       * Call to enable property accessor processing. Before this method is\n       * called accessor values will be set but side effects are\n       * queued. When called, any pending side effects occur immediately.\n       * For elements, generally `connectedCallback` is a normal spot to do so.\n       * It is safe to call this method multiple times as it only turns on\n       * property accessors once.\n       */\n      _enableProperties() {\n        if (!this.__dataEnabled) {\n          this.__dataEnabled = true;\n          if (this.__dataInstanceProps) {\n            this._initializeInstanceProperties(this.__dataInstanceProps);\n            this.__dataInstanceProps = null;\n          }\n          this.ready()\n        }\n      }\n\n      /**\n       * Calls the `_propertiesChanged` callback with the current set of\n       * pending changes (and old values recorded when pending changes were\n       * set), and resets the pending set of changes. Generally, this method\n       * should not be called in user code.\n       *\n       *\n       * @protected\n       */\n      _flushProperties() {\n        if (this.__dataPending && this.__dataOld) {\n          let changedProps = this.__dataPending;\n          this.__dataPending = null;\n          this.__dataCounter++;\n          this._propertiesChanged(this.__data, changedProps, this.__dataOld);\n          this.__dataCounter--;\n        }\n      }\n\n      /**\n       * Lifecycle callback called the first time properties are being flushed.\n       * Prior to `ready`, all property sets through accessors are queued and\n       * their effects are flushed after this method returns.\n       *\n       * Users may override this function to implement behavior that is\n       * dependent on the element having its properties initialized, e.g.\n       * from defaults (initialized from `constructor`, `_initializeProperties`),\n       * `attributeChangedCallback`, or values propagated from host e.g. via\n       * bindings.  `super.ready()` must be called to ensure the data system\n       * becomes enabled.\n       *\n       * @public\n       */\n      ready() {\n        this.__dataReady = true;\n        // Run normal flush\n        this._flushProperties();\n      }\n\n      /**\n       * Callback called when any properties with accessors created via\n       * `_createPropertyAccessor` have been set.\n       *\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {!Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {!Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @protected\n       */\n      _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\n      }\n\n      /**\n       * Method called to determine whether a property value should be\n       * considered as a change and cause the `_propertiesChanged` callback\n       * to be enqueued.\n       *\n       * The default implementation returns `true` for primitive types if a\n       * strict equality check fails, and returns `true` for all Object/Arrays.\n       * The method always returns false for `NaN`.\n       *\n       * Override this method to e.g. provide stricter checking for\n       * Objects/Arrays when using immutable patterns.\n       *\n       * @param {string} property Property name\n       * @param {*} value New property value\n       * @param {*} old Previous property value\n       * @return {boolean} Whether the property should be considered a change\n       *   and enqueue a `_proeprtiesChanged` callback\n       * @protected\n       */\n      _shouldPropertyChange(property, value, old) {\n        return (\n          // Strict equality check\n          (old !== value &&\n           // This ensures (old==NaN, value==NaN) always returns false\n           (old === old || value === value))\n        );\n      }\n\n    }\n\n    return PropertyAccessors;\n\n  });\n\n})();\n</script>\n\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/mixins/property-accessors.html","<!--\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n-->\n\n<link rel=\"import\" href=\"../utils/boot.html\">\n<link rel=\"import\" href=\"../utils/mixin.html\">\n\n<script>\n(function() {\n\n  'use strict';\n\n  // 1.x backwards-compatible auto-wrapper for template type extensions\n  // This is a clear layering violation and gives favored-nation status to\n  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n  // b.) to maintain if/repeat capability in parser-constrained elements\n  //     (e.g. table, select) in lieu of native CE type extensions without\n  //     massive new invention in this space (e.g. directive system)\n  const templateExtensions = {\n    'dom-if': true,\n    'dom-repeat': true\n  };\n  function wrapTemplateExtension(node) {\n    let is = node.getAttribute('is');\n    if (is && templateExtensions[is]) {\n      let t = node;\n      t.removeAttribute('is');\n      node = t.ownerDocument.createElement(is);\n      t.parentNode.replaceChild(node, t);\n      node.appendChild(t);\n      while(t.attributes.length) {\n        node.setAttribute(t.attributes[0].name, t.attributes[0].value);\n        t.removeAttribute(t.attributes[0].name);\n      }\n    }\n    return node;\n  }\n\n  function findTemplateNode(root, nodeInfo) {\n    // recursively ascend tree until we hit root\n    let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n    // unwind the stack, returning the indexed node at each level\n    if (parent) {\n      // note: marginally faster than indexing via childNodes\n      // (http://jsperf.com/childnodes-lookup)\n      for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {\n        if (nodeInfo.parentIndex === i++) {\n          return n;\n        }\n      }\n    } else {\n      return root;\n    }\n  }\n\n  // construct `$` map (from id annotations)\n  function applyIdToMap(inst, map, node, nodeInfo) {\n    if (nodeInfo.id) {\n      map[nodeInfo.id] = node;\n    }\n  }\n\n  // install event listeners (from event annotations)\n  function applyEventListener(inst, node, nodeInfo) {\n    if (nodeInfo.events && nodeInfo.events.length) {\n      for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {\n        inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n      }\n    }\n  }\n\n  // push configuration references at configure time\n  function applyTemplateContent(inst, node, nodeInfo) {\n    if (nodeInfo.templateInfo) {\n      node._templateInfo = nodeInfo.templateInfo;\n    }\n  }\n\n  function createNodeEventHandler(context, eventName, methodName) {\n    // Instances can optionally have a _methodHost which allows redirecting where\n    // to find methods. Currently used by `templatize`.\n    context = context._methodHost || context;\n    let handler = function(e) {\n      if (context[methodName]) {\n        context[methodName](e, e.detail);\n      } else {\n        console.warn('listener method `' + methodName + '` not defined');\n      }\n    };\n    return handler;\n  }\n\n  /**\n   * Element mixin that provides basic template parsing and stamping, including\n   * the following template-related features for stamped templates:\n   *\n   * - Declarative event listeners (`on-eventname=\"listener\"`)\n   * - Map of node id's to stamped node instances (`this.$.id`)\n   * - Nested template content caching/removal and re-installation (performance\n   *   optimization)\n   *\n   * @mixinFunction\n   * @polymer\n   * @memberof Polymer\n   * @summary Element class mixin that provides basic template parsing and stamping\n   */\n  Polymer.TemplateStamp = Polymer.dedupingMixin(superClass => {\n\n    /**\n     * @polymer\n     * @mixinClass\n     * @implements {Polymer_TemplateStamp}\n     */\n    class TemplateStamp extends superClass {\n\n      /**\n       * Scans a template to produce template metadata.\n       *\n       * Template-specific metadata are stored in the object returned, and node-\n       * specific metadata are stored in objects in its flattened `nodeInfoList`\n       * array.  Only nodes in the template that were parsed as nodes of\n       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n       * contains an `index` (`childNodes` index in parent) and optionally\n       * `parent`, which points to node info of its parent (including its index).\n       *\n       * The template metadata object returned from this method has the following\n       * structure (many fields optional):\n       *\n       * ```js\n       *   {\n       *     // Flattened list of node metadata (for nodes that generated metadata)\n       *     nodeInfoList: [\n       *       {\n       *         // `id` attribute for any nodes with id's for generating `$` map\n       *         id: {string},\n       *         // `on-event=\"handler\"` metadata\n       *         events: [\n       *           {\n       *             name: {string},   // event name\n       *             value: {string},  // handler method name\n       *           }, ...\n       *         ],\n       *         // Notes when the template contained a `<slot>` for shady DOM\n       *         // optimization purposes\n       *         hasInsertionPoint: {boolean},\n       *         // For nested `<template>`` nodes, nested template metadata\n       *         templateInfo: {object}, // nested template metadata\n       *         // Metadata to allow efficient retrieval of instanced node\n       *         // corresponding to this metadata\n       *         parentInfo: {number},   // reference to parent nodeInfo>\n       *         parentIndex: {number},  // index in parent's `childNodes` collection\n       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n       *       },\n       *       ...\n       *     ],\n       *     // When true, the template had the `strip-whitespace` attribute\n       *     // or was nested in a template with that setting\n       *     stripWhitespace: {boolean},\n       *     // For nested templates, nested template content is moved into\n       *     // a document fragment stored here; this is an optimization to\n       *     // avoid the cost of nested template cloning\n       *     content: {DocumentFragment}\n       *   }\n       * ```\n       *\n       * This method kicks off a recursive treewalk as follows:\n       *\n       * ```\n       *    _parseTemplate <---------------------+\n       *      _parseTemplateContent              |\n       *        _parseTemplateNode  <------------|--+\n       *          _parseTemplateNestedTemplate --+  |\n       *          _parseTemplateChildNodes ---------+\n       *          _parseTemplateNodeAttributes\n       *            _parseTemplateNodeAttribute\n       *\n       * ```\n       *\n       * These methods may be overridden to add custom metadata about templates\n       * to either `templateInfo` or `nodeInfo`.\n       *\n       * Note that this method may be destructive to the template, in that\n       * e.g. event annotations may be removed after being noted in the\n       * template metadata.\n       *\n       * @param {!HTMLTemplateElement} template Template to parse\n       * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n       *   template, for parsing nested templates\n       * @return {!TemplateInfo} Parsed template metadata\n       */\n      static _parseTemplate(template, outerTemplateInfo) {\n        // since a template may be re-used, memo-ize metadata\n        if (!template._templateInfo) {\n          let templateInfo = template._templateInfo = {};\n          templateInfo.nodeInfoList = [];\n          templateInfo.stripWhiteSpace =\n            (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||\n            template.hasAttribute('strip-whitespace');\n          this._parseTemplateContent(template, templateInfo, {parent: null});\n        }\n        return template._templateInfo;\n      }\n\n      static _parseTemplateContent(template, templateInfo, nodeInfo) {\n        return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n      }\n\n      /**\n       * Parses template node and adds template and node metadata based on\n       * the current node, and its `childNodes` and `attributes`.\n       *\n       * This method may be overridden to add custom node or template specific\n       * metadata based on this node.\n       *\n       * @param {Node} node Node to parse\n       * @param {!TemplateInfo} templateInfo Template metadata for current template\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n      static _parseTemplateNode(node, templateInfo, nodeInfo) {\n        let noted;\n        let element = /** @type Element */(node);\n        if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n          noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n        } else if (element.localName === 'slot') {\n          // For ShadyDom optimization, indicating there is an insertion point\n          templateInfo.hasInsertionPoint = true;\n        }\n        if (element.firstChild) {\n          noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;\n        }\n        if (element.hasAttributes && element.hasAttributes()) {\n          noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n        }\n        return noted;\n      }\n\n      /**\n       * Parses template child nodes for the given root node.\n       *\n       * This method also wraps whitelisted legacy template extensions\n       * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n       * wrappers, collapses text nodes, and strips whitespace from the template\n       * if the `templateInfo.stripWhitespace` setting was provided.\n       *\n       * @param {Node} root Root node whose `childNodes` will be parsed\n       * @param {!TemplateInfo} templateInfo Template metadata for current template\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       */\n      static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n        for (let node=root.firstChild, parentIndex=0, next; node; node=next) {\n          // Wrap templates\n          if (node.localName == 'template') {\n            node = wrapTemplateExtension(node);\n          }\n          // collapse adjacent textNodes: fixes an IE issue that can cause\n          // text nodes to be inexplicably split =(\n          // note that root.normalize() should work but does not so we do this\n          // manually.\n          next = node.nextSibling;\n          if (node.nodeType === Node.TEXT_NODE) {\n            let /** Node */ n = next;\n            while (n && (n.nodeType === Node.TEXT_NODE)) {\n              node.textContent += n.textContent;\n              next = n.nextSibling;\n              root.removeChild(n);\n              n = next;\n            }\n            // optionally strip whitespace\n            if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n              root.removeChild(node);\n              continue;\n            }\n          }\n          let childInfo = { parentIndex, parentInfo: nodeInfo };\n          if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n            childInfo.infoIndex = templateInfo.nodeInfoList.push(/** @type {!NodeInfo} */(childInfo)) - 1;\n          }\n          // Increment if not removed\n          if (node.parentNode) {\n            parentIndex++;\n          }\n        }\n      }\n\n      /**\n       * Parses template content for the given nested `<template>`.\n       *\n       * Nested template info is stored as `templateInfo` in the current node's\n       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n       * It will then be the responsibility of the host to set it back to the\n       * template and for users stamping nested templates to use the\n       * `_contentForTemplate` method to retrieve the content for this template\n       * (an optimization to avoid the cost of cloning nested template content).\n       *\n       * @param {HTMLTemplateElement} node Node to parse (a <template>)\n       * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n       *   that includes the template `node`\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n      static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n        let templateInfo = this._parseTemplate(node, outerTemplateInfo);\n        let content = templateInfo.content =\n          node.content.ownerDocument.createDocumentFragment();\n        content.appendChild(node.content);\n        nodeInfo.templateInfo = templateInfo;\n        return true;\n      }\n\n      /**\n       * Parses template node attributes and adds node metadata to `nodeInfo`\n       * for nodes of interest.\n       *\n       * @param {Element} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n      static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n        // Make copy of original attribute list, since the order may change\n        // as attributes are added and removed\n        let noted = false;\n        let attrs = Array.from(node.attributes);\n        for (let i=attrs.length-1, a; (a=attrs[i]); i--) {\n          noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n        }\n        return noted;\n      }\n\n      /**\n       * Parses a single template node attribute and adds node metadata to\n       * `nodeInfo` for attributes of interest.\n       *\n       * This implementation adds metadata for `on-event=\"handler\"` attributes\n       * and `id` attributes.\n       *\n       * @param {Element} node Node to parse\n       * @param {!TemplateInfo} templateInfo Template metadata for current template\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @param {string} name Attribute name\n       * @param {string} value Attribute value\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n      static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n        // events (on-*)\n        if (name.slice(0, 3) === 'on-') {\n          node.removeAttribute(name);\n          nodeInfo.events = nodeInfo.events || [];\n          nodeInfo.events.push({\n            name: name.slice(3),\n            value\n          });\n          return true;\n        }\n        // static id\n        else if (name === 'id') {\n          nodeInfo.id = value;\n          return true;\n        }\n        return false;\n      }\n\n      /**\n       * Returns the `content` document fragment for a given template.\n       *\n       * For nested templates, Polymer performs an optimization to cache nested\n       * template content to avoid the cost of cloning deeply nested templates.\n       * This method retrieves the cached content for a given template.\n       *\n       * @param {HTMLTemplateElement} template Template to retrieve `content` for\n       * @return {DocumentFragment} Content fragment\n       */\n      static _contentForTemplate(template) {\n        let templateInfo = /** @type {HTMLTemplateElementWithInfo} */ (template)._templateInfo;\n        return (templateInfo && templateInfo.content) || template.content;\n      }\n\n      /**\n       * Clones the provided template content and returns a document fragment\n       * containing the cloned dom.\n       *\n       * The template is parsed (once and memoized) using this library's\n       * template parsing features, and provides the following value-added\n       * features:\n       * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n       * * Generates an \"id map\" for all nodes with id's under `$` on returned\n       *   document fragment\n       * * Passes template info including `content` back to templates as\n       *   `_templateInfo` (a performance optimization to avoid deep template\n       *   cloning)\n       *\n       * Note that the memoized template parsing process is destructive to the\n       * template: attributes for bindings and declarative event listeners are\n       * removed after being noted in notes, and any nested `<template>.content`\n       * is removed and stored in notes as well.\n       *\n       * @param {!HTMLTemplateElement} template Template to stamp\n       * @return {!StampedTemplate} Cloned template content\n       */\n      _stampTemplate(template) {\n        // Polyfill support: bootstrap the template if it has not already been\n        if (template && !template.content &&\n            window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n          HTMLTemplateElement.decorate(template);\n        }\n        let templateInfo = this.constructor._parseTemplate(template);\n        let nodeInfo = templateInfo.nodeInfoList;\n        let content = templateInfo.content || template.content;\n        let dom = /** @type DocumentFragment */ (document.importNode(content, true));\n        // NOTE: ShadyDom optimization indicating there is an insertion point\n        dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n        let nodes = dom.nodeList = new Array(nodeInfo.length);\n        dom.$ = {};\n        for (let i=0, l=nodeInfo.length, info; (i<l) && (info=nodeInfo[i]); i++) {\n          let node = nodes[i] = findTemplateNode(dom, info);\n          applyIdToMap(this, dom.$, node, info);\n          applyTemplateContent(this, node, info);\n          applyEventListener(this, node, info);\n        }\n        return /** @type {!StampedTemplate} */(dom);\n      }\n\n      /**\n       * Adds an event listener by method name for the event provided.\n       *\n       * This method generates a handler function that looks up the method\n       * name at handling time.\n       *\n       * @param {Node} node Node to add listener on\n       * @param {string} eventName Name of event\n       * @param {string} methodName Name of method\n       * @param {*=} context Context the method will be called on (defaults\n       *   to `node`)\n       * @return {Function} Generated handler function\n       */\n      _addMethodEventListenerToNode(node, eventName, methodName, context) {\n        context = context || node;\n        let handler = createNodeEventHandler(context, eventName, methodName);\n        this._addEventListenerToNode(node, eventName, handler);\n        return handler;\n      }\n\n      /**\n       * Override point for adding custom or simulated event handling.\n       *\n       * @param {Node} node Node to add event listener to\n       * @param {string} eventName Name of event\n       * @param {Function} handler Listener function to add\n       */\n      _addEventListenerToNode(node, eventName, handler) {\n        node.addEventListener(eventName, handler);\n      }\n\n      /**\n       * Override point for adding custom or simulated event handling.\n       *\n       * @param {Node} node Node to remove event listener from\n       * @param {string} eventName Name of event\n       * @param {Function} handler Listener function to remove\n       */\n      _removeEventListenerFromNode(node, eventName, handler) {\n        node.removeEventListener(eventName, handler);\n      }\n\n    }\n\n    return TemplateStamp;\n\n  });\n\n})();\n</script>\n\n\n\n// WEBPACK FOOTER //\n// ../bower_components/polymer/lib/mixins/template-stamp.html","\nimport resolveUrl from '../utils/resolve-url.js'\n\nexport default (superClass) => {\n  return class extends superClass {\n    // static get observedAttributes () {\n    //   const observedAttributes = super.observedAttributes || []\n    //   return observedAttributes.concat(['path', 'query', 'urlSpaceRegex', 'hash', 'dwellTime', 'urlSpaceRegex', '_urlSpaceRegExp', '_lastChangedAt', '_initialized'])\n    // }\n\n    // _propertiesChanged (currentProps, changedProps, oldProps) {\n    //   if (super._propertiesChanged) {\n    //     super._propertiesChanged(currentProps, changedProps, oldProps)\n    //   }\n    //   if ('path' in changedProps && 'query' in changedProps && 'hash' in changedProps) {\n    //     if (changedProps['path'] !== oldProps['path'] && changedProps['query'] !== oldProps['query'] && changedProps['hash'] !== oldProps['hash']) {\n    //       this._updateUrl(changedProps['path'], changedProps['query'], changedProps['hash'])\n    //     }\n    //   }\n    //   if ('urlSpaceRegex' in changedProps) {\n    //     if (changedProps['urlSpaceRegex'] !== oldProps['urlSpaceRegex']) {\n    //       this.__urlSpaceRegExp = this._makeRegExp(changedProps['urlSpaceRegex'])\n    //     }\n    //   }\n    // }\n\n    constructor () {\n      super()\n      this._boundHashChanged = this._hashChanged.bind(this)\n      this._boundUrlChanged = this._urlChanged.bind(this)\n      this._boundGlobalOnClick = this._globalOnClick.bind(this)\n    }\n\n    connectedCallback () {\n      if (super.disconnectedCallback) {\n        super.connectedCallback()\n      }\n      window.addEventListener('hashchange', this._boundHashChanged)\n      window.addEventListener('location-changed', this._boundUrlChanged)\n      window.addEventListener('popstate', this._boundUrlChanged)\n      document.body.addEventListener('click', this._boundGlobalOnClick, true)\n      this._lastChangedAt = window.performance.now() - (this.dwellTime - 200)\n      this._initialized = true\n\n      // set initialize values\n      this.path = window.decodeURIComponent(window.location.pathname)\n      this.query = window.location.search.slice(1)\n      this.hash = window.decodeURIComponent(window.location.hash.slice(1))\n      this.dwellTime = 2000\n      this._initialized = false\n      this._urlChanged()\n    }\n\n    disconnectedCallback () {\n      if (super.disconnectedCallback) {\n        super.disconnectedCallback()\n      }\n      window.removeEventListener('hashchange', this._boundHashChanged)\n      window.removeEventListener('location-changed', this._boundUrlChanged)\n      window.removeEventListener('popstate', this._boundUrlChanged)\n      document.body.removeEventListener('click', this._boundGlobalOnClick)\n      this._initialized = false\n    }\n\n    _hashChanged () {\n      this.hash = window.decodeURIComponent(window.location.hash.substring(1))\n    }\n\n    _urlChanged () {\n      // We want to extract all info out of the updated URL before we\n      // try to write anything back into it.\n      //\n      // i.e. without _dontUpdateUrl we'd overwrite the new path with the old\n      // one when we set this.hash. Likewise for query.\n      this._dontUpdateUrl = true\n      this._hashChanged()\n      this.path = window.decodeURIComponent(window.location.pathname)\n      this.query = window.location.search.substring(1)\n      this._dontUpdateUrl = false\n      this._updateUrl()\n    }\n\n    _getUrl () {\n      var partiallyEncodedPath = window.encodeURI(\n          this.path).replace(/\\#/g, '%23').replace(/\\?/g, '%3F')\n      var partiallyEncodedQuery = ''\n      if (this.query) {\n        partiallyEncodedQuery = '?' + this.query.replace(/\\#/g, '%23')\n      }\n      var partiallyEncodedHash = ''\n      if (this.hash) {\n        partiallyEncodedHash = '#' + window.encodeURI(this.hash)\n      }\n      return (partiallyEncodedPath + partiallyEncodedQuery + partiallyEncodedHash)\n    }\n\n    _updateUrl () {\n      if (this._dontUpdateUrl || !this._initialized) {\n        return\n      }\n\n      if (this.path === window.decodeURIComponent(window.location.pathname) &&\n          this.query === window.location.search.substring(1) &&\n          this.hash === window.decodeURIComponent(\n              window.location.hash.substring(1))) {\n        // Nothing to do, the current URL is a representation of our properties.\n        return\n      }\n      var newUrl = this._getUrl()\n      // Need to use a full URL in case the containing page has a base URI.\n      var fullNewUrl = resolveUrl(newUrl, window.location.protocol + '//' + window.location.host).href\n      var now = window.performance.now()\n      var shouldReplace = this._lastChangedAt + this.dwellTime > now\n      this._lastChangedAt = now\n      if (shouldReplace) {\n        window.history.replaceState({}, '', fullNewUrl)\n      } else {\n        window.history.pushState({}, '', fullNewUrl)\n      }\n      window.dispatchEvent(new CustomEvent('location-changed'))\n    }\n\n    /**\n     * A necessary evil so that links work as expected. Does its best to\n     * bail out early if possible.\n     *\n     * @param {MouseEvent} event .\n     */\n    _globalOnClick (event) {\n      // If another event handler has stopped this event then there's nothing\n      // for us to do. This can happen e.g. when there are multiple\n      // iron-location elements in a page.\n      if (event.defaultPrevented) {\n        return\n      }\n      var href = this._getSameOriginLinkHref(event)\n      if (!href) {\n        return\n      }\n      event.preventDefault()\n      // If the navigation is to the current page we shouldn't add a history\n      // entry or fire a change event.\n      if (href === window.location.href) {\n        return\n      }\n      window.history.pushState({}, '', href)\n      window.dispatchEvent(new CustomEvent('location-changed'))\n    }\n\n    /**\n     * Returns the absolute URL of the link (if any) that this click event\n     * is clicking on, if we can and should override the resulting full\n     * page navigation. Returns null otherwise.\n     *\n     * @param {MouseEvent} event .\n     * @return {string?} .\n     */\n    _getSameOriginLinkHref (event) {\n      // We only care about left-clicks.\n      if (event.button !== 0) {\n        return null\n      }\n      // We don't want modified clicks, where the intent is to open the page\n      // in a new tab.\n      if (event.metaKey || event.ctrlKey) {\n        return null\n      }\n      var eventPath = event.composedPath()\n      var anchor = null\n      for (var i = 0; i < eventPath.length; i++) {\n        var element = eventPath[i]\n        if (element.tagName === 'A' && element.href) {\n          anchor = element\n          break\n        }\n      }\n      // If there's no link there's nothing to do.\n      if (!anchor) {\n        return null\n      }\n      // Target blank is a new tab, don't intercept.\n      if (anchor.target === '_blank') {\n        // capture link click\n        if (anchor.href && window.ga) {\n          ga('send', 'event', 'Link', 'Click', anchor.href, 1)\n        }\n        return null\n      }\n      // If the link is for an existing parent frame, don't intercept.\n      if ((anchor.target === '_top' ||\n          anchor.target === '_parent') &&\n          window.top !== window) {\n        return null\n      }\n      var href = anchor.href\n      // It only makes sense for us to intercept same-origin navigations.\n      // pushState/replaceState don't work with cross-origin links.\n      var url\n      if (document.baseURI != null) {\n        url = resolveUrl(href, /** @type {string} */(document.baseURI))\n      } else {\n        url = resolveUrl(href)\n      }\n      var origin\n      // IE Polyfill\n      if (window.location.origin) {\n        origin = window.location.origin\n      } else {\n        origin = window.location.protocol + '//' + window.location.host\n      }\n      var urlOrigin\n      if (url.origin) {\n        urlOrigin = url.origin\n      } else {\n        urlOrigin = url.protocol + '//' + url.host\n      }\n      if (urlOrigin !== origin) {\n        return null\n      }\n      var normalizedHref = url.pathname + url.search + url.hash\n      // pathname should start with '/', but may not if `new URL` is not supported\n      if (normalizedHref[0] !== '/') {\n        normalizedHref = '/' + normalizedHref\n      }\n      // If we've been configured not to handle this url... don't handle it!\n      if (this._urlSpaceRegExp &&\n          !this._urlSpaceRegExp.test(normalizedHref)) {\n        return null\n      }\n      // Need to use a full URL in case the containing page has a base URI.\n      var fullNormalizedHref = resolveUrl(\n          normalizedHref, window.location.href).href\n      return fullNormalizedHref\n    }\n\n    _makeRegExp (urlSpaceRegex) {\n      return RegExp(urlSpaceRegex)\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../core/mixins/location-mixin.js","var workingURL\nvar urlDoc, urlBase, anchor\n/**\n * @param {string} path\n * @param {string=} base\n * @return {!URL|!HTMLAnchorElement}\n */\nexport default (path, base) => {\n  if (workingURL === undefined) {\n    workingURL = false\n    try {\n      var u = new URL('b', 'http://a')\n      u.pathname = 'c%20d'\n      workingURL = (u.href === 'http://a/c%20d')\n      workingURL = workingURL && (new URL('http://www.google.com/?foo bar').href === 'http://www.google.com/?foo%20bar')\n    } catch (e) {}\n  }\n  if (workingURL) {\n    return new URL(path, base)\n  }\n  if (!urlDoc) {\n    urlDoc = document.implementation.createHTMLDocument('url')\n    urlBase = urlDoc.createElement('base')\n    urlDoc.head.appendChild(urlBase)\n    anchor = /** @type {HTMLAnchorElement} */(urlDoc.createElement('a'))\n  }\n  urlBase.href = base\n  anchor.href = path.replace(/ /g, '%20')\n  return anchor\n}\n\n\n\n// WEBPACK FOOTER //\n// ../core/utils/resolve-url.js","// import 'polymer/lib/mixins/property-effects.html'\nexport default (superClass) => {\n  return class extends superClass {\n    connectedCallback () {\n      if (super.connectedCallback) {\n        super.connectedCallback()\n      }\n\n      // initialize values\n      this.paramsObject = {}\n      this._dontReact = false\n    }\n\n    // static get observedAttributes () {\n    //   const observedAttributes = super.observedAttributes || []\n    //   return observedAttributes.concat(['paramsString', 'paramsObject', '_dontReact'])\n    // }\n\n    // _propertiesChanged (currentProps, changedProps, oldProps) {\n    //   if (super._propertiesChanged) {\n    //     super._propertiesChanged(currentProps, changedProps, oldProps)\n    //   }\n    //   if ('paramsString' in changedProps) {\n    //     if (changedProps['paramsString'] !== oldProps['paramsString']) {\n    //       this._paramsStringChanged()\n    //     }\n    //   }\n    //   if ('query' in changedProps) {\n    //     if (changedProps['query'] !== oldProps['query']) {\n    //       this._queryChanged(changedProps['query'])\n    //     }\n    //   }\n    // }\n\n    _queryChanged (query) {\n      this.paramsString = query\n    }\n\n    _paramsStringChanged () {\n      this._dontReact = true\n      this.paramsObject = this._decodeParams(this.paramsString)\n      this._dontReact = false\n    }\n\n    paramsObjectChanged () {\n      console.log('paramsObject')\n      if (this._dontReact) {\n        return\n      }\n      this.paramsString = this._encodeParams(this.paramsObject)\n          .replace(/%3F/g, '?').replace(/%2F/g, '/').replace(/'/g, '%27')\n    }\n\n    _encodeParams (params) {\n      var encodedParams = []\n      for (var key in params) {\n        var value = params[key]\n        if (value === '') {\n          encodedParams.push(encodeURIComponent(key))\n        } else if (value) {\n          encodedParams.push(\n              encodeURIComponent(key) +\n              '=' +\n              encodeURIComponent(value.toString())\n          )\n        }\n      }\n      return encodedParams.join('&')\n    }\n\n    _decodeParams (paramString) {\n      var params = {}\n      // Work around a bug in decodeURIComponent where + is not\n      // converted to spaces:\n      paramString = (paramString || '').replace(/\\+/g, '%20')\n      var paramList = paramString.split('&')\n      for (var i = 0; i < paramList.length; i++) {\n        var param = paramList[i].split('=')\n        if (param[0]) {\n          params[decodeURIComponent(param[0])] =\n              decodeURIComponent(param[1] || '')\n        }\n      }\n      return params\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../core/mixins/query-params-mixin.js","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\n\n\n// WEBPACK FOOTER //\n// ../node_modules/path-to-regexp/index.js","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n// WEBPACK FOOTER //\n// ../node_modules/isarray/index.js","\n    export default {\n      '/': () => { return import(/* webpackChunkName: \"uxia-home-page\" */ './modules/uxia-module/pages/uxia-home-page/uxia-home-page.html') }, \n'style-guide': () => { return import(/* webpackChunkName: \"example-style-guide-page\" */ './modules/example-module/pages/example-style-guide-page/example-style-guide-page.js') }\n    }\n  \n\n\n// WEBPACK FOOTER //\n// ../src/routing.js","\n    export default {\n      'not-found': () => { return import(/* webpackChunkName: \"example-not-found-page\" */ './modules/example-module/pages/example-not-found-page/example-not-found-page.js') }, \n'not-authorized': () => { return import(/* webpackChunkName: \"example-not-authorized-page\" */ './modules/example-module/pages/example-not-authorized-page/example-not-authorized-page.js') }\n    }\n  \n\n\n// WEBPACK FOOTER //\n// ../src/http-codes.js","export default {\n  exampleAuthentication: () => {\n    // returns a 'falsy' value, which means the user is not authenticated\n    return false\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/authentication/index.js","/* eslint-env browser */\n\nclass RegisterHtmlTemplate {\n  /**\n   * Create a `<template>` element to hold `<dom-module>` content.\n   * This bit of code will execute in the context of the main document,\n   * calling `importNode` on the `<template>`, which in turn triggers\n   * the lifecycle of the `<dom-module>` and allows it to insert its\n   * content into Polymer's global module map. When a Polymer element\n   * boots up it will fetch its template from this module map.\n   * https://github.com/Polymer/polymer/blob/master/lib/mixins/element-mixin.html#L501-L538\n   * @param {string} val A `<dom-module>` as an HTML string\n   */\n  static register(val) {\n    let content;\n    const template = document.createElement('template');\n    template.innerHTML = val;\n    if (template.content) {\n      content = template.content; // eslint-disable-line prefer-destructuring\n    } else {\n      content = document.createDocumentFragment();\n      while (template.firstChild) {\n        content.appendChild(template.firstChild);\n      }\n    }\n    document.importNode(content, true);\n  }\n  /**\n   * Content that will be injected into the main document. This is primarily\n   * for things like `<iron-iconset>` and `<custom-style>` which do not have\n   * templates but rely on HTML Imports ability to apply content to the main\n   * document.\n   * @param {string} val An HTML string\n   */\n  static toBody(val) {\n    const trimmedVal = val.trim();\n    if (trimmedVal) {\n      const div = document.createElement('div');\n      div.innerHTML = trimmedVal;\n      if (div.firstChild) {\n        if (document.body) {\n          document.body.insertBefore(div.firstChild, document.body.firstChild);\n        } else {\n          document.addEventListener('DOMContentLoaded', () => {\n            document.body.insertBefore(div.firstChild, document.body.firstChild);\n          });\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = RegisterHtmlTemplate;\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/polymer-webpack-loader/register-html-template.js"],"sourceRoot":""}